#圆形/gi缓冲区/gi
圆形/gi缓冲区/gi（/wcircular buffer/nz）/w，/w也/d称作/v圆形/gi队列/gi（/wcircular queue/nz）/w，/w循环/gi缓冲区/gi（/wcyclic buffer/nz）/w，/w环形/n缓冲区/gi（/wring buffer/nz）/w，/w是/vshi一种/nz数据结构/gi用于/v表示/v一个/mq固定/a尺寸/gi、/w头尾/n相连/vi的/ude1，/w适合/v缓存/gi。/w目录/gi[/nz]/nz用法/gi[/nz]/nz圆形/gi缓冲区/gi的/ude1一个/mq有/vyou用/p特性/gi是/vshi：/w当/p一个/mq数据/gi元素/gi被/pbei用掉/v后/f，/w其余/rz数据/gi元素/gi不/d需要/v移动/vn其/rz存储/gi位置/gi。/w相反/vi，/w一个/mq非/b圆形/gi缓冲区/gi（/w例如/v一个/mq普通/a的/ude1队列/gi）/w在用/b掉/v一个/mq数据/gi元素/gi后/f，/w其余/rz数据/gi元素/gi需要/v向前/gi搬移/nz。/w换句话说/c，/w圆形/gi缓冲区/gi适合/v实现/gi缓冲区/gi，/w而非/c圆形/gi缓冲区/gi适合/v缓冲区/gi。/w圆形/gi缓冲区/gi适合于/v事先/d明确/a了/ule缓冲区/gi的/ude1最大/gm容量/gi的/ude1情形/n。/w扩展/gi一个/mq圆形/gi缓冲区/gi的/ude1容量/gi，/w需要/v搬移/nz其中/rz的/ude1数据/gi。/w因此/c一个/mq缓冲区/gi如果/c需要/v经常/d调整/vn其/rz容量/gi，/w用/p链表/gi实现/gi更为/d合适/a。/w写/v操作/gi覆盖/gi圆形/gi缓冲区/gi中/f未/d被/pbei处理/vn的/ude1数据/gi在/p某些/rz情况下/nz是/vshi允许/v的/ude1。/w特别是在/l多媒体/gi处理/vn时/qt。/w例如/v，/w音频/gi的/ude1生产者/n可以/v覆盖/gi掉/v尚未/d来得及/v处理/vn的/ude1音频/gi数据/gi。/w工作/gi过程/gi[/nz]/nz一个/mq圆形/gi缓冲区/gi最初/d为/p空/ng并/cc有/vyou预定/vn的/ude1长度/gi。/w例如/v，/w这/rzv是/vshi一个/mq具有/v七个/nz元素/gi空间/n的/ude1圆形/gi缓冲区/gi，/w其中/rz底部/f的/ude1单线/n与/cc箭头/n表示/v“头/nz尾/ng相接/vi”/w形成/v一个/mq圆形/gi地址/gi空间/n：/w假定/v1/nz被/pbei写入/gi缓冲区/gi中部/f（/w对于/p圆形/gi缓冲区/gi来说/uls，/w最初/d的/ude1写入/gi位置/gi在/p哪里/rys是/vshi无关紧要/vl的/ude1）/w：/w再/d写入/gi2/nz个/q元素/gi，/w分别/d是/vshi2/nz  /x3/nz /x―/w /x被/pbei追加/v在/p1/nz之后/f：/w如果/c两/nz个/q元素/gi被/pbei处理/vn，/w那么/c是/vshi缓冲区/gi中/f最/d老/a的/ude1两/nz个/q元素/gi被/pbei移除/v。/w在/p本例/nz中/f，/w1/nz  /x2/nz被/pbei移除/v，/w缓冲区/gi中/f只/d剩下/v3/nz:/w如果/c缓冲区/gi中/f有/vyou7/nz个/q元素/gi，/w则/d是/vshi满/a的/ude1：/w如果/c缓冲区/gi是/vshi满/a的/ude1，/w又/d要/v写入/gi新的/a数据/gi，/w一种/nz策略/gi是/vshi覆盖/gi掉/v最/d老/a的/ude1数据/gi。/w此例/nz中/f，/w2/nz个/q新/a数据/gi―/w a  b /nz―/w /x写入/gi，/w覆盖/gi了/ule3/nz  /x4/nz:/w也/d可以/v采取/v其他/rzv策略/gi，/w禁止/v覆盖/gi缓冲区/gi的/ude1数据/gi，/w采取/v返回/v一个/mq错误/gi码/v或者/c抛出/v。/w最终/d，/w如果/c从/p缓冲区/gi中/f移除/v2/nz个/q数据/gi，/w不是/c3/nz  /x4/nz /x而是/c /x5/nz  /x6/nz /x。/w因为/c a  b /nz已经/d覆盖/gi了/ule3/nz  /x4/nz：/w圆形/gi缓冲区/gi工作/gi机制/gi[/nz]/nz由于/p计算机/gi内存/gi是/vshi线性/gi地址/gi空间/n，/w因此/c圆形/gi缓冲区/gi需要/v特别/d的/ude1设计/gi才/d可以/v从/p逻辑上/nz实现/gi。/w读/v指针/gi与/cc写/v指针/gi[/nz]/nz一般/ad的/ude1，/w圆形/gi缓冲区/gi需要/v4/nz个/q指针/gi：/w在/p内存/gi中/f实际/n开始/v位置/gi；/w在/p内存/gi中/f实际/n结束/v位置/gi，/w也/d可以/v用/p缓冲区/gi长度/gi代替/v；/w存储/gi在/p缓冲区/gi中的/v有效/gi数据/gi的/ude1开始/v位置/gi（/w读/v指针/gi）/w；/w存储/gi在/p缓冲区/gi中的/v有效/gi数据/gi的/ude1结尾/n位置/gi（/w写/v指针/gi）/w。/w读/v指针/gi、/w写/v指针/gi可以/v用/p整型/nz来/vf表示/v。/w下例/n为/p一个/mq未满/nz的/ude1缓冲区/gi的/ude1读写/gi指针/gi：/w下例/n为/p一个/mq满/a的/ude1缓冲区/gi的/ude1读写/gi指针/gi：/w区分/v缓冲区/gi满/a或者/c空/ng[/nz]/nz缓冲区/gi是/vshi满/a、/w或/c是/vshi空/ng，/w都/d有可能/nz出现/v读/v指针/gi与/cc写/v指针/gi指向/v同一/b位置/gi：/w有/vyou多/a种/q策略/gi用于/v检测/gi缓冲区/gi是/vshi满/a、/w或/c是/vshi空/ng./nz总是/d保持/v一个/mq存储单元/gm为/p空/ng[/nz]/nz缓冲区/gi中/f总是/d有一个/nz存储单元/gm保持/v未/d使用/gi状态/gi。/w缓冲区/gi最多/ad存入/v个/q数据/gi。/w如果/c读写/gi指针/gi指向/v同一/b位置/gi，/w则/d缓冲区/gi为/p空/ng。/w如果/c写/v指针/gi位于/v读/v指针/gi的/ude1相邻/vi后/f一个/mq位置/gi，/w则/d缓冲区/gi为/p满/a。/w这种/r策略/gi的/ude1优点/gi是/vshi简单/a、/w鲁棒/nz；/w缺点/gi是/vshi语义上/nz实际/n可存/nz数据量/n与/cc缓冲区/gi容量/gi不/d一致/a，/w测试/gi缓冲区/gi是否/v满/a需要/v做/v取/v余数/n计算/gi。/w使用/gi数据/gi计数/vi[/nz]/nz这种/r策略/gi不/d使用/gi显式/nz的/ude1写/v指针/gi，/w而是/c保持/v着/uzhe缓冲/vn区内/n存储/gi的/ude1数据/gi的/ude1计数/vi。/w因此/c测试/gi缓冲区/gi是/vshi空/ng是/vshi满/a非常简单/nz；/w对/p性能/gi影响/gi可以/v忽略/v。/w缺点/gi是/vshi读写操作/n都/d需要/v修改/gi这个/rz存储/gi数据/gi计数/vi，/w对于/p访问/gi缓冲区/gi需要/v。/w镜像/gi指示/gi位/q[/nz]/nz缓冲区/gi的/ude1长度/gi如果/c是/vshin/nz，/w逻辑/n地址/gi空间/n则/d为/p0/nz至/pn/nz-/nz1/nz；/w那么/c，/w规定/nn/nz至/p2/nzn/nz-/nz1/nz为/p镜像/gi逻辑/n地址/gi空间/n。/w本/rz策略规定/nz读写/gi指针/gi的/ude1地址/gi空间/n为/p0/nz至/p2/nzn/nz-/nz1/nz，/w其中/rz低半部/nz分/qt对应/vi于/p常规/n的/ude1逻辑/n地址/gi空间/n，/w高半部/nz分/qt对应/vi于/p镜像/gi逻辑/n地址/gi空间/n。/w当/p指针/gi大于/v等于/v2/nzn/nz时/qt，/w使/v其/rz折返/v（/wwrapped/nz）/w到/vptr/nz-/nz2/nzn/nz。/w使用/gi一位/nz表示/v写/v指针/gi或/c读/v指针/gi是否/v进入/v了/ule虚拟/gi的/ude1镜像/gi存储/gi区/n：/w置位/nz表示/v进入/v，/w不置/v位/q表示/v没/d进入/v还/d在/p基本/a存储/gi区/n。/w在/p读写/gi指针/gi的/ude1相同/a情况下/nz，/w如果/c二者/rzv的/ude1指示/gi位/q相同/a，/w说明/v缓冲区/gi为/p空/ng；/w如果/c二者/rzv的/ude1指示/gi位/q不同/a，/w说明/v缓冲区/gi为/p满/a。/w这种/r方法/gi优点/gi是/vshi测试/gi缓冲区/gi满/a//nz空/ng很/d简单/a；/w不/d需要/v做/v取/v余数/n操作/gi；/w读写/gi线程/gi可以/v分别/d设计/gi专用/gi算法/gi策略/gi，/w能/v实现/gi精致/a的/ude1并发/gi控制/vn。/w /x缺点/gi是/vshi读写/gi指针/gi各/rz需要/v额外/b的/ude1一位/nz作为/p指示/gi位/q。/w如果/c缓冲区/gi长度/gi是/vshi2/nz的/ude1，/w则/d本/rz方法/gi可以/v省略/v镜像/gi指示/gi位/q。/w如果/c读写/gi指针/gi的/ude1相等/vi，/w则/d缓冲区/gi为/p空/ng；/w如果/c读写/gi指针/gi相差/vn/nz，/w则/d缓冲区/gi为/p满/a，/w这/rzv可以/v用/p条件/n表达式/gi（/w写/v指针/gi /x=/nz=/nz /x(/nz读/v指针/gi缓冲区/gi长度/gi)/nz）/w来/vf判断/gi。/w读/v//nz写/v /x计数/vi[/nz]/nz用/p两/nz个/q有/vyou符号/gi整型/nz变量/gi分别/d保存/gi写入/gi、/w读出/v缓冲区/gi的/ude1数据/gi数量/n。/w其/rz差/a就是/v缓冲区/gi中/f尚未/d被/pbei处理/vn的/ude1有效/gi数据/gi的/ude1数量/n。/w这种/r方法/gi的/ude1优点/gi是/vshi读/v线程/gi、/w写/v线程/gi互不/d干扰/gi；/w缺点/gi是/vshi需要/v额外/b两/nz个/q变量/gi。/w记录/gi最后/f的/ude1操作/gi[/nz]/nz使用/gi一位/nz记录/gi最后/f一次/nz操作/gi是/vshi读/v还是/c写/v。/w读写/gi指针/gi相等/vi情况下/nz，/w如果/c最后/f一次/nz操作/gi为/p写入/gi，/w那么/c缓冲区/gi是/vshi满/a的/ude1；/w如果/c最后/f一次/nz操作/gi为/p读出/v，/w那么/c缓冲区/gi是/vshi空/ng。/w /x这种/r策略/gi的/ude1缺点/gi是/vshi读写操作/n共享/gi一个/mq标志/n位/q，/w多线程/gi时/qt需要/v并发/gi控制/vn。/wposix/nz优化/gi实现/gi[/nz]/nzlinux/gi内核/gi的/ude1kfifo/nz[/nz]/nz在/plinux/gi内核/gi文件/gikfifo/nz./nzh/nz和/cckfifo/nz./nzc/nz中/f，/w定义/gi了/ule一个/mq先进先出/gi圆形/gi缓冲区/gi实现/gi。/w如果/c只有/c一个/mq读/v线程/gi、/w一个/mq写/v线程/gi，/w二者/rzv没有/v共享/gi的/ude1被/pbei修改/gi的/ude1控制变量/gi，/w那么/c可以/v证明/v这种/r情况下/nz不/d需要/v。/wkfifo/nz就/d满足/v上述/b条件/n。/wkfifo/nz要求/n缓冲区/gi长度/gi必须/d为/p2/nz的/ude1幂/n。/w读/v、/w写/v指针/gi分别/d是/vshi无/v符号/gi整型/nz变量/gi。/w把/pba读写/gi指针/gi变换/gi为/p缓冲/vn区内/n的/ude1索引/gi，/w仅/d需要/v“/w按/p位与/v”/w操作/gi：/w（/w指针/gi /x按/p位与/v /x（/w缓冲区/gi长度-/nz1/nz）/w）/w。/w这/rzv避免/v了/ule计算/gi代价/gi高昂/a的/ude1“求/nz余/ng”/w操作/gi。/w且/c下述/nz关系/gi总是/d成立/vi：/w读/v指针/gi  /x缓冲区/gi存储/gi的/ude1数据/gi长度/gi /x=/nz=/nz /x写/v指针/gi即使/c在/p写/v指针/gi达到/v了无/v符号/gi整型/nz的/ude1上界/n，/w上/f溢出/gi后写/v指针/gi的/ude1小于/v读/v指针/gi的/ude1，/w上述/b关系/gi仍然/d保持/v成立/vi（/w这/rzv是因为/c无符号/nz整型/nz加法/gi的/ude1性质/n）/w。/w kfifo/nz的/ude1写/v操作/gi，/w首先/d计算/gi缓冲区/gi中/f当前/t可/v写入/gi存储空间/gi的/ude1数据/gi长度/gi：/wlen /nz=/nz min/nz{/nz待/vi写入/gi数据/gi长度/gi,/nz /x缓冲区/gi长度/gi /x-/nz /x（/w写/v指针/gi /x-/nz /x读/v指针/gi）/w}/nz然后/c，/w分/qt两/nz段/q写入/gi数据/gi。/w第一段/nz是从/v写/v指针/gi开始/v向/p缓冲区/gi末尾/n方向/gi；/w第二段/nz是从/v缓冲区/gi起始/gi处/n写入/gi余下/v的/ude1可/v写入/gi数据/gi，/w这/rzv部分/n可能/v数据/gi长度/gi为/p0/nz即/v并/cc无/v实际/n数据/gi写入/gi。/w