#版本控制/gi学习/gi(/nzGit/gi分布式/gi)/nz
1.1/nz /x关于/p版本控制/gi什么/ry是/vshi版本控制/gi?/nz我/rr为什么/ryv要/v关心/v它/rr呢/y?/nz版本控制/gi是/vshi记录/gi一个/mq或者/c若干/m文件/gi的/ude1变化/gi,/nz以/p便于/v将来/t查看/gi各种/rz特定/b版本/n修订/v情况/n的/ude1系统/gi./nz在/p本书/gi中所/j展现/v的/ude1例子/gi中/f,/nz我们/rr仅/d对/p保存/gi着/uzhe软件/gi源代码/gi的/ude1文本/gi文件/gi做/v版本控制/gi管理/gi集中式/n版本控制系统/gi集中化/vn的/ude1版本控制系统/gi(/nzcentralized version control system/nz)/nz简称/vcvcs/nz,/nz这类/r系统/gi,/nz诸如/vcvs/gi,/nzsubversion/nz以及/cc perforce/nz等/udeng,/nz都/d有/vyou一个/mq单一/gi的/ude1集中管理/nz的/ude1服务器/gi,/nz保存/gi着/uzhe所有/b文件/gi的/ude1修订/v版本/n,/nz而/cc协同工作/n的/ude1人们/n通过/p客户端/gi连接/gi到/v这/rzv台/q服务器/gi,/nz取出/v最新/a的/ude1文件/gi或者/c提交/gi更新/gi./nz多/a年/qt以来/f这/rzv已经/d成为/v版本控制系统/gi的/ude1标准/gi做法/n./nz这种/r做法/n带来/v了/ule许/v多/a好处/gi,/nz特别/d是/vshi相对于/nz老式/b的/ude1vcs/nz来说/uls./nz现在/t,/nz每个/r人/n可以/v在/p一定/b程度/n上/f看到/v项目/gi中的/v其他人/r正在/d做/v什么/ry./nz而/cc管理员/gi也/d可以/v轻松/a的/ude1掌控/v每个/r开发者/gi的/ude1权限/gi,/nz并且/c管理/gi一个/mqcvcs/nz要/v远比/v在/p各个/rz客户端/gi上/f维护/gi本地/gi数据/gi来/vf的/ude1容易/ad事/n分/qt两面/mq,/nz有好有坏/i./nz这么/rz做/v最/d显而易见/bl的/ude1缺点/gi是/vshi中央/n服务器/gi的/ude1单点故障/gi./nz如果/c宕机/nz一小时/nz,/nz那么/c在/p这/rzv一/nz小时/n内/f,/nz谁/ry都/d无法/v提交/gi更新/gi,/nz也/d无法/v协同工作/n,/nz,/nz要是/c中央/n服务器/gi的/ude1磁盘/gi发生/v故障/gi,/nz,/nz碰巧/d没/d做/v备份/gi,/nz,/nz或者/c备份/gi不够/a及时/ad,/nz就/d会/v有/vyou丢失/v数据/gi的/ude1风险/gi./nz最坏/gi的/ude1情况/n是/vshi丢失/v整个/b项目/gi的/ude1所有/b历史/n更改/gi记录/gi./nz而/cc被/pbei客户端/gi偶然/a提取/v出来/vf的/ude1某些/rz快照/gi就/d撑/v了/ule恢复/gi数据/gi的/ude1希望/v./nz但/c这样的话/l依然/d是/vshi个/q问题/gi,/nz你/rr不能/v保证/v所有/b的/ude1数据/gi都/d有人/r事先/d完整/a提取/v出来/vf过/uguo,/nz本地/gi的/ude1版本控制/gi也/d存在/v类/gi的/ude1问题/gi,/nz只要/c整个/b项目/gi历史记录/nz被/pbei保存/gi在/p单一/gi的/ude1位置/gi,/nz就/d有/vyou丢失/v历史/n更新/gi记录/gi的/ude1风险/gi./nz分布式/gi版本控制系统/gi于是/cc分布式/gi版本控制系统/gi(/nzdistributed version control system/nz,/nz简称/vdvcs/nz)/nz就/d出现/v了/ule,/nz在/p这类/r系统/gi中/f,/nz像/vgit/gi,/nzmercurial/nz,/nzbazaar/nz以及/ccdarcs/nz等/udeng,/nz客户端/gi并不/d只是/d提取/v最新/a版本/n的/ude1文件/gi快照/gi,/nz而是/c吧/y代码/gi仓库/gi完整/a的/ude1复制/gi下来/vf,/nz这么一来/l,/nz任何/rz一/nz处/n协同工/nz做/v的/ude1服务器/gi发生/v故障/gi,/nz事后/f都/d可以/v任何/rz一个/mq镜像/gi下来/vf的/ude1本地/gi仓库/gi恢复/gi,/nz因为/c每一次/d提取/v操作/gi,/nz实际上/d都/d是/vshi一次/nz对/p代码/gi仓库/gi的/ude1完成/v备份/gi./nz更进一步/vl,/nz许多/m这类/r系统/gi都/d可以/v指定/v若/c干/v不同/a的/ude1远端/nz代码/gi仓库/gi进行/vn交互/gi,/nz藉此/d,/nz你/rr就/d可以/v在/p一个/mq项目/gi中/f,/nz分别/d和/cc不同/a小组/nis的/ude1人/n相互协作/l./nz你/rr也/d可以/v根据/p需要/v设定/v不同/a的/ude1协作/gi流程/gi,/nz比如/v层次/n模式/gi的/ude1工作流/gi./nz而/cc这/rzv是/vshi在/p以前/f的/ude1集中式/n版本控制系统/gi中/f无法/v实现/gi的/ude1./nz1.2/nz gitgit/nz是/vshi怎样/ryv的/ude1一个/mq系统/gi呢/y直接/ad记录/gi快照/gi,/nz而非/c差异/n比较/gigit/gi和/cc其他/rzv版本控制系统/gi的/ude1主要/b区别/gi在于/v,/nzgit/gi只/d关心/v文件/gi数据/gi的/ude1整体/n是否/v发生变化/l,/nz而/cc大多/d数/n系统/gi则/d只/d关心/v文件/gi内容/gi的/ude1具体/a差异/n./nz这类/r系统/gi(/nzcvs/gi,/nzsubversion/nz,/nzperforce/nz,/nzbazaar/nz等/udeng)/nz每次/r记录/gi有/vyou哪些/ry文件/gi做/v了/ule更新/gi,/nz以及/cc都/d更新/gi了/ule什么/ry内容/gi./nzgit/gi并不/d保存/gi这些/rz前后/f变化/gi的/ude1具体/a差异/n./nz实际上/d,/nzgit/gi更/d像是/v把/pba变化/gi的/ude1文件/gi作为/p快照/gi后/f,/nz记录/gi在/p一个/mq微型/b的/ude1文件系统/gi中/f./nz每次/r提交/gi更新/gi时/qt,/nz它/rr会/v总览/nz一遍/nz所有/b文件/gi的/ude1指纹/n信息/gi并/cc对/p文件/gi做/v一快照/nz,/nz然后/c保存/gi指向/v这/rzv一/nz快照/gi的/ude1索引/gi,/nz为/p提高/v性能/gi,/nz若/c文件/gi没有/v变化/gi,/nzgit/gi不会/v再次/d保存/gi,/nz而/cc只/d对/p上/f一次/nz保存/gi的/ude1快照/gi做/v一次/nz链接/gi近乎/v所有/b的/ude1操作/gi都/d是/vshi本地/gi执行/v因为/c本地/gi保存/gi着/uzhe所有/b版本/n的/ude1历史/n更新/gi例如/v,/nz如果/c要/v浏览/gi项目/gi历史/n更新/gi摘要/n,/nzgit/gi不用/d跑到/v外面/f的/ude1服务器/gi上去/vf取回/v数据/gi来/vf,/nz而/cc直接/ad从/p本地/gi数据库/gi中/f提取/v出来/vf展示/gi给/p你/rr看/v时刻/n保存/gi数据/gi的/ude1完整性/gi在/p保存/gi到/vgit/gi之前/f,/nz所有/b的/ude1数据/gi都/d要/v进行/vn内容/gi的/ude1校验/v和/cc计算/gi,/nz并/cc将/d此/rzs结果/n作为/p数据/gi的/ude1唯一/b标识/n和/cc索引/gi,/nz换句话说/c,/nz不/d可能/v在/p你/rr修改/gi了/ule文件/gi或者/c目录/gi后/f,/nzgit/gi一无所知/vl,/nz这项/r特性/gi作为/pgit/gi设计/gi哲学/n,/nz建在/v整体/n架构/gi的/ude1最底层/n./nz所以/c,/nz如果/c文件/gi在/p传输/gi时/qt变得/vi不/d完整/a,/nz或者/c磁盘/gi损坏/v导致/gi文件/gi数据/gi缺失/n,/nzgit/gi都/d能/v立即/d察觉/v./nz多数/a操作/gi权限/gi添加/gi数据/gi常用/a的/ude1git/gi操作/gi大多/d仅仅/d是/vshi吧/y数据/gi添加/gi到/v数据库/gi,/nz因为/c任何/rz一种/nz不可逆的/gm操作/gi,/nz比如/v删除/gi数据/gi,/nz都会/n使/v回退/gi或/c重现/v历史/n版本/n变得/vi尤其/d困难/an,/nz在/pgit/gi中/f,/nz一旦/d提交/gi快照/gi之后/f就/d完全/ad不用/d担心/v数据/gi丢失/v,/nz特别/d是/vshi养成/v定期/d推送/nz到/v其他/rzv仓库/gi的/ude1习惯/n的话/udh./nz这种/r高可靠性/n令/v我们/rr的/ude1开发/gi工作/gi安心/a不/d少/a,/nz尽管/c去/vf做/v各种/rz实验性/n的/ude1尝试/v好/a了/ule,/nz再/d怎样/ryv也/d不会/v弄丢/nz数据/gi,/nz文件/gi的/ude1三种/nz状态/gi任何/rz一个/mq文件/gi,/nz在/pgit/gi中都/ns有/vyou三种/nz状态/gi:/w已/d提交/gi(/nzcommitted/nz)/nz,/nz已/d修改/gi(/nzmodified/nz)/nz,/nz和/cc已/d暂存/nz(/nzstaged/nz)/nz./nz已/d提交/gi表示/v该/rz文件/gi已/d被/pbei安全/gi的/ude1保存/gi在/p本地/gi数据库/gi中/f了/ule;/nz已/d修改/gi表示/v已经/d修改/gi了/ule某个/rz文件/gi,/nz但是/c还/d没有/v提交/gi保存/gi;/nz已/d暂存/nz表示/v已经/d把/pba下次/t要/v提交/gi的/ude1文件/gi保存/gi在/p清单/n中/f./nz每个/r项目/gi都/d有/vyou一个/mqgit/gi目录/gi(/nz译注/n:/w如果/cgit clone/nz出来/vf的话/udh,/nz就是/v其中/rz的/ude1./nzgit/gi目录/gi;/nz如果/cgit clone /nz-/nzbare/nz的话/udh,/nz新建/v的/ude1目录/gi本身/rz就是/vgit/gi目录/gi)/nz,/nz它/rr是/vshigit/gi用来/v保存/gi元数据/gi和/cc数据/gi对象/gi的/ude1地方/n./nz该/rz目录/gi非常/d重要/a,/nz每次/r克隆镜/nz像/v仓库/gi的/ude1时候/n,/nz这些/rz文件/gi其实/d都/d是从/vgit/gi目录/gi中/f压缩/gi对象/gi数据库/gi中/f提取/v出来/vf的/ude1,/nz接下来/vl就/d可以/v在/p工作/gi目录/gi中/f对/p这些/rz文件/gi进行/vn编辑/gi