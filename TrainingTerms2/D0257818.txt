#【/w设计模式/nz】/w对/p六大/n原则/gi的/ude1宏观/gi把/pba控/v和/cc微观/n细化/v
  /x一天/nz之前/f，/w终于/d将/d设计模式/nz的/ude1第二遍/nz看完/v了/ule。/w。/w在/p这/rzv两/nz遍/qv中/f，/w我/rr又/d学到/v了/ule很/d多/a知识/gi。/w在/p之前/f看/vootv/nz设计/gi大赛/vn时/qt，/w总是/d提到/v面向对象设计/gi的/ude1原则/gi，/w这/rzv让/v我/rr不明/v所以/c，/w直到/v看/v完整/a本书/gi之后/f，/w才/d知道/v书/gi中/f自有/b黄金屋/n。/w。/w这/rzv篇文章/n主要/b写/v的/ude1就是/v面向对象设计/gi的/ude1六大/n原则/gi。/w  /x根据/p上/f图/gi，/w我们/rr可以/v轻松/a地/ude2得出/v，/w面向对象设计/gi是/vshi以/p高/a内聚/nz、/w低/a耦合/vn为/p设计/gi核心/n，/w抽象/gi为基础/nz，/w封装/gi、/w继承/gi和/cc多态/gi为/p特点/n。/w综合/vn面向对象/gi的/ude1原则/gi、/w基础/gi和/cc特点/n，/w我们/rr总结/gi出/vf了/ule它/rr的/ude1六大/n原则/gi。/w通过/p这/rzv六大/n原则/gi，/w我们/rr还/d可以/v演化出/n多/a种/q设计模式/nz。/w。/w下面/f就/d写/v一下/m我/rr对/p这/rzv六大/n原则/gi的/ude1理解/gi。/w。/w  /x依赖/v倒转/vi  /x是/vshi面向对象/gi的/ude1标志/n！/w用/p哪种/ry语言/gi来/vf编写程序/n不/d重要/a，/w重要/a的/ude1是/vshi程序/gi中的/v依赖/v关系/gi都/d是/vshi终止/v于/p抽象类/gi或者/c接口/gi，/w这/rzv就是/v面向对象/gi的/ude1设计/gi。/w  /x定义/gi  /x1/nz、/w高层/n模块/gi不/d应该/v依赖/v低层/n模块/gi，/w两/nz个/q都/d应该/v依赖/v抽象/gi  /x2/nz、/w抽象/gi不/d应该/v依赖/v细节/gi，/w细节/gi应该/v依赖/v抽象/gi  /x单一/gi职责/gi  /x如果/c一个/mq类/gi承担/v过多/d的/ude1职责/gi，/w就/d等于/v把/pba这些/rz职责/gi耦合/vn在/p一起/s。/w一个/mq职责/gi的/ude1变化/gi可能会/nz削弱/v或/c抑制/v这个/rz类/gi完成/v其他/rzv职责/gi的/ude1能力/gi。/w所以/c，/w软件设计/nz真正/d要/v做/v的/ude1，/w就是/v发现/v职责/gi并/cc把/pba那些/rz职责/gi相互/d分离/vi。/w  /x定义/gi  /x就/d一个/mq类/gi而言/uls，/w应该/v仅有/nz一个/mq引起/v它/rr变化/gi的/ude1原因/n  /x迪米特/nrf  /x这个/rz原则/gi的/ude1前提/n是/vshi在/p类/gi的/ude1结构设计/nz上/f，/w每/rz一个/mq类/gi都/d应当/v尽量/d降低成员/nz的/ude1访问/gi权限/gi。/w其/rz根本/a思想/gi，/w是/vshi强调/v类/gi之间/f的/ude1弱/a耦合/vn。/w类/gi之间/f的/ude1耦合/vn越/d弱/a，/w越/d有利于/v复用/gi，/w一个/mq处在/v弱/a耦合/vn的/ude1类/gi被/pbei修改/gi，/w不会/v对/p有/vyou关系/gi的/ude1类/gi造成/v较大/d波及/v。/w  /x定义/gi  /x1/nz、/w如果/c两/nz个/q类/gi不必/d彼此/rr直接/ad通信/gi，/w那么/c这/rzv两/nz个/q类/gi就/d不/d应当/v发生/v直接/ad的/ude1相互作用/n  /x2/nz、/w如果/c其中/rz一个/mq类/gi需要/v调用/gi另一个/nz类/gi的/ude1某/rz一个/mq方法/gi，/w可以/v通过/p第三者/n转发/gi这个/rz调用/gi。/w  /x合成/gi//nz聚合/gi复用/gi  /x它/rr的/ude1优点/gi是/vshi，/w有助于/v保持/v每个/r类/gi被/pbei封装/gi，/w并/cc被/pbei集中/v在/p单个/b任务/gi上/f。/w这样一来/dl，/w就/d会/v降低/v继承/gi所/usuo带来/v的/ude1强耦合/nz，/w使/v程序/gi不太可能/i增长/gi为/p不可/v控制/vn的/ude1庞然大物/n。/w  /x定义/gi  /x尽量/d使用/gi合成/gi//nz聚合/gi，/w尽量/d不要/d使用/gi类/gi继承/gi  /x里氏/n代/q换/v  /x如果/c一个/mq软件/gi的/ude1实体/n使用/gi的/ude1是/vshi一个/mq父类/nz的话/udh，/w那么/c就/d一定/b适用/vi于/p其子/r类/gi，/w并且/c，/w察觉/v不出/v父/ng类/gi和/cc子类/gm对象/gi的/ude1区别/gi。/w更/d直白/a的/ude1说/v，/w就是/v在/p软件/gi里面/f，/w把/pba父类/nz都/d替换成/i它/rr的/ude1子类/gm，/w程序/gi的/ude1行为/n没有/v变化/gi。/w  /x定义/gi  /x子/ng类型/gi必须/d能够/v替换/v掉/v他们/rr的/ude1父/ng类型/gi。/w  /x正是/v因为/c有/vyou了/ule里氏/n代换/v原则/gi，/w才/d使得/vi下面/f的/ude1开放/gi封闭/gi成为/v可能/v。/w由于/p子类/gm的/ude1可/v替换/v性/ng才/d使得/vi父类/nz的/ude1模块/gi在/p无需/v修改/gi的/ude1情况下/nz可以/v扩展/gi。/w  /x开放/gi封闭/gi  /x无论/c模块/gi是/vshi多么/d的/ude1“/w封闭/gi”/w，/w都会/n存在/v一些/m无法/v对/p之/uzhi封闭/gi的/ude1变化/gi。/w既然/c不/d可能/v完全/ad封闭/gi，/w设计/gi人员/gi就/d必须/d先/d猜测出/l最/d有可能/nz发生/v的/ude1变化/gi，/w然后/c构造/n抽象/gi来/vf隔离/vn那些/rz变化/gi。/w  /x开放/gi封闭/gi原则/gi是/vshi面向对象设计/gi的/ude1重点/n所在/n。/w开发人员/n应该/v仅/d对/p程序/gi中/f，/w呈现出/v频繁/a变化/gi的/ude1那些/rz部分/n做出/v抽象/gi。/w  /x定义/gi  /x面对/v需求/gi的/ude1更新/gi，/w对/p程序/gi的/ude1改动/vn是/vshi通过/p增加/v新/a代码/gi进行/vn的/ude1，/w而/cc不是/c更改/gi现有/v的/ude1代码/gi。/w  /x小结/n  /x六大/n设计原则/gi是/vshi面向对象/gi技术/gi的/ude1演化/gi，/w可以/v理解/gi为/p是/vshi对/p面向对象/gi的/ude1继承/gi。/w通过/p结合/v这/rzv六大/n原则/gi，/w我们/rr再/d对/p23/nz种/q设计模式/nz进行/vn理解/gi，/w那/rzv就/d事半功倍/vl了/ule。/w这/rzv又是/c米/q老师/gi的/ude1思想/gi，/w宏观/gi把/pba控/v，/w微观/n细化/v。/w米/q老师/gi真是/d无处不在/bl呀/y。/w。/w