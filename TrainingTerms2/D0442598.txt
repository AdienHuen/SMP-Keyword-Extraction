#Oracle/gi如何/ryv按/p月/n分表/n
 /x当/p数据库/gi的/ude1一/nz张/q表/n的/ude1数据/gi达到/v几百万/nz时/qt，/w对/p该/rz表/n的/ude1查询/gi所花/n的/ude1时间/gi会/v变/v的/ude1很/d多/a。/w如果/c有/vyou联合/gi查询/gi的话/udh，/w将/d会/v更加/d耗费/v资源/gi和/cc时间/gi。/w如何/ryv解决/v这/rzv一/nz问题/gi？/w答案/gi就是/v创建/gi数据库/gi分表/n，/w定期/d（/w如/v每月/r一次/nz）/w将/d没用/vi的/ude1数据/gi挪/v到/v分表/n中/f，/w保证/v主表/nz的/ude1数据量/n不会/v非常/d庞大/a。/w这样/rzv在/p查询/gi时/qt，/w所/usuo花费/v的/ude1时间/gi就/d在/p合理/a范围内/nz了/ule。/w /x那么/c如何/ryv创建/gi定期/d创建/gi数据库/gi分表/n？/w我/rr的/ude1做法/n是/vshi在/poracle/gi中/f创建/gi一个/mq存储过程/gi，/w然后/c用/pjava/gi定时器/gi定期/d触发/gi它/rr。/w下面/f就是/v创建/gi存储过程/gi的/ude1sql语句/gi。/w /x该/rz表/n的/ude1总体/n业务流程/nz如下/vi：/w获得/v上月/t时间/gi，/w并以/c“/w表名/nz_/nzyymm/nz”/w的/ude1式/k得到/v新表/nz的/ude1表名/nz；/w创建/gi新表/nz，/w表名/nz是/vshi刚刚/d生成/v的/ude1表名/nz，/w表/n结构/gi与/cc主表/nz表/n结构/gi一模一样/al；/w用/pinsert into table /nz(/nzselect xx from yy where z/nz=/nzz/nz)/nz的/ude1sql语句/gi，/w将/d上月/t数据/gi从/p主表/nz中/f复制到/v分表/n中/f；/w将/d已经/d复制/gi出去/vf的/ude1数据/gi从/p主表/nz中/f删除/gi；/w /x一/nz些/q注意事项/nz：/w该/rz存储过程/gi是/vshi按/p月/n分表/n的/ude1，/w你/rr可以/v按/p自己/rr的/ude1间隔/n进行/vn分表/n；/wreturn/nz_/nzcode/gi、/wreturn/nz_/nzmsg/nz是/vshi用来/v将/d错误信息/nz、/w错误/gi码/v返回/v给/p调用者/n的/ude1，/w方便/a在/p正常/a系统/gi运行/gi时/qt，/w记录/gi错误/gi原因/n的/ude1；/wexception/nz就是/v用来/v处理/vn异常/gi时/qt，/w记录/gi错误/gi原因/n的/ude1。/w这/rzv部分/n代码/gi我/rr暂/d未/d将/d所有/b可能性/gi纳入/v进来/vf，/w今后/t有待/v扩展/gi空间/n；/w本例/nz列出/v的/ude1sql语句/gi，/w在/p我/rr这里/rzs是/vshi能/v成功/a执行/v，/w并且/c也/d可以/v实现/gi预计/v的/ude1业务逻辑/gi。/w但是/c在/p粘贴/v到/v本文/r中/f时/qt，/w为了/p避免/v一/nz些/q不必要/a的/ude1麻烦/an，/w我/rr把/pba变量/gi命名/v和/ccsql语句/gi都/d进行/vn了/ule简化/gi和/cc修改/gi，/w所以/c并/cc不能/v保证/v修改/gi以后/f可以/v直接/ad运行/gi通过/p。/w而且/c借鉴/gi本例/nz的/ude1读者/n需要/v根据/p自己/rr的/ude1实际/n情况/n编写/gi建表/nz语句/gi、/winsert/gi语句/gi和/ccdelete/nz语句/gi。/w /x在/pjava/gi代码/gi中/f，/w是/vshi按/p以下/f方法/gi来/vf调用/gi存储过程/gi的/ude1。/w为了/p不必要/a的/ude1麻烦/an，/w一/nz些/qimport/nz语句/gi和/cc类/gi声明/gi等/udeng，/w我/rr都/d省略/v了/ule。/w只/d留下/v最主要/nz的/ude1部分/n。/w代码/gi中的/vgettemplate/nz(/nz)/nz./nzgetconnection/nz(/nz)/nz方法/gi是/vshi我们/rr系统/gi中/f自己/rr封装/gi的/ude1，/w你/rr可以/v根据/p自己/rr的/ude1实际/n情况/n写/v自己/rr的/ude1代码/gi，/w只要/c返回/v的/ude1类型/gi是/vshijava/gi./nzsql/gi./nzconnection/nz就/d可以/v了/ule。/w