#[/nz转载/v]/nz理清/v /x进程上下文/gi与/cc中断上下文/gi
内核/gi空间/n和/cc用户/gi空间/n是/vshi操作系统/gi理论/gi的/ude1基础/gi之一/rz，/w即/v内核/gi功能模块/nz运行/gi在/p内核/gi空间/n，/w而/cc应用程序/nz运行/gi在/p用户/gi空间/n。/w现代/ntc的/ude1cpu/gi都/d具有/v不同/a的/ude1操作/gi模式/gi，/w代表/nnt不同/a的/ude1级别/n，/w不同/a的/ude1级别/n具有/v不同/a的/ude1功能/gi，/w在/p较低/d的/ude1级别/n中将/nnt禁止/v某些/rz操作/gi。/wlinux/gi系统设计/gi时/qt利用/v了/ule这种/r硬件/gi特性/gi，/w使用/gi了/ule两/nz个/q级别/n，/w最高级别/nz和/cc最低/a级别/n，/w内核/gi运行/gi在/p最高级别/nz（/w内/f核态/nz）/w，/w这个/rz级别/n可以/v进行/vn所有/b操作/gi，/w而/cc应用程序/nz运行/gi在/p较低/d级别/n（/w用户/gi态/ng）/w，/w在/p这个/rz级别/n，/w处理器/gi控制/vn着/uzhe对/p硬件/gi的/ude1直接/ad访问/gi以及/cc对/p内存/gi的/ude1非/b授权/v访问/gi。/w内/f核态/nz和/cc用户/gi态/ng有/vyou自己/rr的/ude1内存/gi映射/gi，/w即/v自己/rr的/ude1地址/gi空间/n。/w正是/v有/vyou了/ule不同/a运行/gi状态/gi的/ude1划分/v，/w才/d有/vyou了/ule上下文/gi的/ude1概念/gi。/w用户/gi空间/n的/ude1应用程序/nz，/w如果/c想要/v请求/gi系统/gi服务/gi，/w比如/v操作/gi一个/mq物理/n设备/gi，/w或者/c映射/gi一段/nz设备/gi空间/n的/ude1地址/gi到/v用户/gi空间/n，/w就/d必须/d通过/p系统/gi调用/gi来/vf（/w操作系统/gi提供/v给/p用户/gi空间/n的/ude1接口函数/nz）/w实现/gi。/w如/v下图/n所示/nz：/w通过/p系统/gi调用/gi，/w用户/gi空间/n的/ude1应用程序/nz就/d会/v进入/v内核/gi空间/n，/w由/p内核/gi代表/nnt该/rz进程/gi运行/gi于/p内核/gi空间/n，/w这/rzv就/d涉及/v到/v上下文/gi的/ude1切换/vn，/w用户/gi空间/n和/cc内核/gi空间/n具有/v不同/a的/ude1地址映射/gi，/w通用/gi或/c专用/gi的/ude1寄存器/gi组/n，/w而/cc用户/gi空间/n的/ude1进程/gi要/v传递/v很/d多/a变量/gi、/w参数/gi给/p内核/gi，/w内核/gi也/d要/v保存/gi用户/gi进程/gi的/ude1一些/m寄存器/gi、/w变量/gi等/udeng，/w以便/d系统/gi调用/gi结束/v后/f回到/v用户/gi空间/n继续执行/n。/w所谓/v的/ude1进程上下文/gi，/w就是/v一个/mq进程/gi在/p执行/v的/ude1时候/n，/wcpu/gi的/ude1所有/b寄存器/gi中的/v值/n、/w进程/gi的/ude1状态/gi以及/cc堆栈/n中的/v内容/gi，/w当/p内核/gi需要/v切换/vn到/v另一个/nz进程/gi时/qt，/w它/rr需要/v保存/gi当前/t进程/gi的/ude1所有/b状态/gi，/w即/v保存/gi当前/t进程/gi的/ude1进程上下文/gi，/w以便/d再次/d执行/v该/rz进程/gi时/qt，/w能够/v恢复/gi切换/vn时/qt的/ude1状态/gi，/w继续执行/n。/w同理/v，/w硬件/gi通过/p触发/gi信号/gi，/w导致/gi内核/gi调用/gi中断/gi处理程序/n，/w进入/v内核/gi空间/n。/w这个/rz过程/gi中/f，/w硬件/gi的/ude1一些/m变量/gi和/cc参数/gi也/d要/v传递/v给/p内核/gi，/w内核/gi通过/p这些/rz参数/gi进行/vn中断/gi处理/vn，/w中断上下文/gi就/d可以/v理解/gi为/p硬件/gi传递/v过来/vf的/ude1这些/rz参数/gi和/cc内核/gi需要/v保存/gi的/ude1一/nz些/q环境/n，/w主要/b是/vshi被/pbei中断/gi的/ude1进程/gi的/ude1环境/n。/w linux/nz内核/gi工作/gi在/p进程上下文/gi或者/c中断上下文/gi。/w提供/v系统/gi调用/gi服务/gi的/ude1内核/gi代码/gi代表/nnt发起/v系统/gi调用/gi的/ude1应用程序/nz运行/gi在/p进程上下文/gi；/w另一方面/c，/w中断/gi处理程序/n，/w异步/gi运行/gi在/p中断上下文/gi。/w中断上下文/gi和/cc特定/b进程/gi无关/v。/w /x运行/gi在/p进程上下文/gi的/ude1内核/gi代码/gi是/vshi可以/v被/pbei抢占/gi的/ude1（/wlinux/gi2.6/nz支持/v抢占/gi）/w。/w但是/c一个/mq中断上下文/gi，/w通常/d都会/n始终/d占有/vcpu/gi（/w当然/d中断/gi可以/v嵌套/v，/w但/c我们/rr一般/ad不/d这样/rzv做/v）/w，/w不/d可以/v被/pbei打断/v。/w正/d因为/c如此/rzv，/w运行/gi在/p中断上下文/gi的/ude1代码/gi就要/d受/v一/nz些/q限制/vn，/w不能/v做/v下面/f的/ude1事情/n：/w /x1/nz、/w睡眠/vn或者/c放弃/gicpu/gi。/w       /x这样/rzv做/v的/ude1后果/gi是/vshi灾难性/nz的/ude1，/w因为/c内核/gi在/p进入/v中断/gi之前/f会/v关闭/gi进程调度/gi，/w一旦/d睡眠/vn或者/c放弃/gicpu/gi，/w这时/rzt内核/gi无法/v调度/vn别的/rzv进程/gi来/vf执行/v，/w系统/gi就/d会/v死掉/nz /x2/nz、/w尝试/v获得/v信号量/gi       /x如果/c获得/v不到/v信号量/gi，/w代码/gi就/d会/v睡眠/vn，/w会/v产生/v和/cc上面/f相同/a的/ude1情况/n /x3/nz、/w执行/v耗时/vi的/ude1任务/gi       /x中断/gi处理/vn应该/v尽可能/d快/a，/w因为/c内核/gi要/v响应/v大量/m服务/gi和/cc请求/gi，/w中断上下文/gi占用/vcpu/gi时间/gi太长/n会/v严重影响/v系统/gi功能/gi。/w /x4/nz、/w访问/gi用户/gi空间/n的/ude1虚拟地址/gi       /x因为/c中断上下文/gi是/vshi和/cc特定/b进程/gi无关/v的/ude1，/w它/rr是/vshi内核/gi代表/nnt硬件/gi运行/gi在/p内核/gi空间/n，/w所以/c在/p终端/gi上下文/gi无法访问/l用户/gi空间/n的/ude1虚拟地址/gi