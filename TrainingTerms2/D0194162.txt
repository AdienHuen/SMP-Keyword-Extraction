#c++/gi /x设计模式/nz（/w三/nz）/wsingleton /nz单例模式/gi
单例模式/gi的/ude1意图/gi：/w保证/v一个/mq类/gi只有/c一个/mq实例/gi，/w并/cc提供/v一个/mq访问/gi它/rr的/ude1全局/n节点/gi适用性/n：/w      /x当类/nz只能/v一个/mq实例/gi而且/c客户/n可以/v从/p从/p一个/mq周所周知/nz的/ude1访问/gi点/gi访问/gi它/rr      /x当/p这个/rz唯一/b的/ude1实例/gi应该/v是/vshi通过/p子类/gm化/v可扩张/nz的/ude1，/w并且/c客户/n应该/v无需/v修改/gi代码/gi就/d能/v使用/gi一个/mq扩展/gi的/ude1实例/gi记住/v上面/f这段话/l，/w在/p下面/f的/ude1分析/gi过程/gi我们/rr反复/d来/vf品味/v这段话/l的/ude1所/usuo表达/gi的/ude1意思/n，/w融会贯通/vl。/w一/nz、/w什么/ry是/vshi单例模式/gi，/w单例模式/gi实际/n中/f有/vyou哪些/ry例子/gi    /x单例模式/gi也/d称为/v单件/n模式/gi或者/c单子/n模式/gi，/w在/p设计模式/nz中用/a的/ude1最/d广/a的/ude1设计模式/nz，/w其/rz意图/gi上面/f就/d提到/v过/uguo说/v过/uguo：/w保证/v一个/mq类/gi仅有/nz一个/mq实例/gi，/w并/cc提供/v一个/mq访问/gi它/rr的/ude1全局/n访问/gi点/gi，/w该/rz实例/gi被/pbei所有/b程序模块/gi共享/gi。/w在/p实际/n编程/gi很/d多/a地方/n能用/v到/v这样/rzv的/ude1设计模式/nz，/w如/v输出/gi系统日志/gi的/ude1输出/gi，/w单/b鼠标/gi模式/gi，/w一个/mqgui/nz应用/gi只能/v是/vshi单/b鼠标/gi模式/gi，/w一台/nz电脑配置/nz一个/mq键盘/gi....../w./nz./nz二/nz、/w单例模式/gi最简单/nz的/ude1实现/gi    /x在/p实际/n编程/gi中/f，/w我们/rr很容易/nz用/p一个/mq全局变量/gi来/vf表示/v单例模式/gi，/w但是/c在/pc/nz中/f，/w这样/rzv做/v之后/f无法/v保证/v在/p声明/gi一个/mq全局/n对象/gi之后/f不能/v再/d创建/gi相同/a的/ude1本地/gi实例/gi对象/gi。/w    /x在/pc/nz设计模式/nz中/f提出/v一种/nz很/d简单/a的/ude1实现/gi方法/gi：/w其实/d现/tg过程/gi是/vshi这样/rzv的/ude1，/w首先/d要/v保证/v一个/mq类/gi只有/c一个/mq实例/gi，/w而且/c使用/gi类/gi静态/gi指针/gi指向/v唯一/b的/ude1实例/gi；/w当然/d就/d在/p类/gi中/f构造/n一个/mq实例/gi，/w那么/c就要/d调用/gi构造函数/gi，/w为了/p防止/gi在/p类/gi的/ude1外部/f调用/gi类/gi的/ude1构造函数/gi创建/gi实例/gi，/w需要/v将/d构造函数/gi访问/gi权限/gi设计/gi成/v私有/gi的/ude1；/w当然/d要/v提供/v一个/mq全局/n的/ude1访问/gi节点/gi，/w那么/c就/d类/gi中/f定义/gi一个/mqstatic/gi函数/gi，/w在/p其/rz函数/gi体/ng中/f调用/gi类/gi的/ude1构造函数/gi创建/gi实例/gi并且/c返回/v这个/rz唯一/b的/ude1构造/n实例/gi。/w说/v了/ule这么/rz多/a，/w还/d不如上/nz代码/gi仔细/ad品味/v这段话/l的/ude1意思/n，/w代码/gi如下/vi仔细分析/n一下/m代码/gi就/d只/dsingleton/gi类/gi的/ude1特征/gi：/w他/rr有/vyou一个/mq指向/v唯一/b实例/gi的/ude1静态/gi指针/gip/nz_/nzinstance/gi，/w这个/rz指针/gi的/ude1类型/gi还是/c类/gi本身/rz的/ude1类型/gi。/w他/rr还有/v一个/mq公/ng有的/rz静态/gi的/ude1函数/gi，/w唯一/b访问/gi实例/gi的/ude1函数/gi，/w在/p需要/v实例/gi的/ude1去/vf创建/gi实例/gi。/w构造函数/gi是/vshi私有/gi的/ude1，/w他/rr是/vshi唯一/b能/v创建/gi实例/gi访问/gi实例/gi的/ude1函数。三/nz、/w继续/v分析/gi：/w    /x有/vyou一定/b经验/gi的/ude1程序员/gi一/nz就/d看出/v问题/gi，/w这个/rz类/gi有/vyou指针/gi成员/nnt而且/c没有/v任何/rz涉及/v到/v资源/gi的/ude1管理/gi的/ude1设计/gi，/w当类/nz需要/v释放/gi所/usuo分配/gi的/ude1资源/gi的/ude1时候/n，/w怎么办/ryv？/w    /x我们/rr知道/v，/w在/p程序/gi结束/v的/ude1时候/n，/w系统/gi会/v自动/d释放/gi所有/b的/ude1全局变量/gi和/cc静态/gi变量/gi，/w他们/rr都/d是/vshi存储/gi在/p内层/nz的/ude1静态/gi区域/n。/w利用/v这个/rz特点/n我们/rr设计/gi一个/mq资源/gi释放/gi管理/gi的/ude1类/gi（/w这里/rzs我/rr告诉/v大家/rr，/w这种/r设计/gi方式/n在/pc/nz称之为/vc raii/nz机制/gi，/w大家/rr不妨/d自行/d研究/gi一/nz下/f）/w。/w看/v下面/f的/ude1代码/gi：/w   /x在/p程序运行/n结束/v时/qt，/w系统/gi会/v调用/gisingleton/gi的/ude1静态/gi成员/nntgc/nz的/ude1析构函数/gi，/w该/rz析构函数/gi会/v进行/vn资源/gi的/ude1释放/gi，/w而/cc这种/r资源/gi的/ude1释放/gi方式/n是/vshi在/p程序员/gi“/w不/d知道/v”/w的/ude1情况下/nz进行/vn的/ude1，/w而/cc程序员/gi不用/d特别/d的/ude1去/vf关心/v，/w使用/gi单例模式/gi的/ude1代码/gi时/qt，/w不必/d关心/v资源/gi的/ude1释放/gi。/w四/nz、/w继续/v分析/gi：/w看/v下面/f的/ude1代码/gi   /x我们/rr使用/gi局部/n静态/gi变量/gi，/w在/p类/gi中/f公共/b的/ude1静态/gi的/ude1函数/gi返回/v一个/mq类/gi类型/gi的/ude1静态/gi局部/n变量/gi，/w这样/rzv完全/ad实现/gi了/ule单例模式/gi，/w也/d不用/d关心/v单例模式/gi的/ude1资源/gi释放/gi问题/gi。/w使用/gi静态/gi局部/n变量/gi完全避免/nz手动/b释放/gi类/gi所/usuo分配资源/n和/cc线程安全/gi问题/gi（/wc/nz11/nz新标准/nz支持/vstatic/gi局部/n变量/gi安全问题/gi）/w我们/rr看到/v了/ule：/wsingleton object /nz=/nz singleton/nz:/w:/wget/gi_/nzinstance/gi(/nz)/nz;/nz上面/f使用/gi类/gi的/ude1默认/v构造/n的/ude1拷贝/gi构造函数/gi，/w如果/c我们/rr要/v禁止/v程序员/gi拷贝/gi和/cc拷贝/gi复制/gi使用/gi单例/gi的/ude1情况/n，/w那么/c可以/v这样/rzv设计/gi，/w在/pc/nz中/f，/w我们/rr要/v阻止/v类/gi的/ude1拷贝/gi和/cc复制/gi那么/c就/d可以/v把/pba他们/rr的/ude1拷贝函数/nz和/cc拷贝/gi赋函数/nz设计/gi成/v私有/gi的/ude1，/w那么/c就/d出现/v了/ule下面/f的/ude1单例/gi实现/gi模式。五/nz、/w继续/v思考/gi：/w   /x我们/rr从头到尾/dl都/d没/d考虑/v线程安全/gi问题/gi，/w如果/c你/rr使用/gi第四种/nz方法/gi，/w恭喜/v你/rr无意识/d中/f避免/v了/ule线程安全/gi，/w这/rzv又/d另外/c一个/mq话题/n了/ule：/w在/pc /nz11/nz新标准/nz中/f，/w静态/gi局部/n变量/gi是/vshi线程安全/gi的/ude1参考/gi文章/gi：/w   /x其/rz二和三/nz方法/gi的/ude1代码/gi中都/ns是/vshi要/v考虑/v线程安全/gi的/ude1问题/gi。/w实现/gi方法/gi如下/vi：/w   /x上面/f使用/gic /nz11/nz支持/v的/ude1多线程/gi相关/vn的/ude1线程安全/gi机制/gi。/w这里/rzs使用/gi了/ule两/nz次/qv判断/gip/nz_/nzinstance /nz=/nz=/nz null/nz，/w这/rzv就是/v大家/rr所说/c双/q检锁/nz机制/gi，/w因为/c进行/vn一次/nz加锁/gi和/cc解锁/gi是/vshi需要/v付出/v对应/vi的/ude1代价/gi，/w而/cc进行/vn两/nz次/qv判断/gi，/w就/d可以/v避免/v多/a次/qv加锁/gi和/cc解锁/gi操作/gi，/w同时/c也/d保证/v了/ule线程安全/gi。/w这种/r方法/gi虽然/c很/d不错/a，/w但是/c还是/c没有/v第四提/nz出来/vf静态/gi局部/n变量/gi种/q方法/gi好/a。/w参考/gi文章/gi：/w《/wc/nz中的/vraii/nz机制/gihttp /nz》/w /x