#IOS/nz多线程/gi基本/a使用/gi
1./nz多线程/gi的/ude1介绍/gi??/nz对于/p一个/mqapp/gi来说/uls，/w如果/c要/v进行/vn一/nz些/q比较/gi耗时/vi的/ude1操作/gi，/w同时/c又/d不想/v影响/gi用户/gi的/ude1体验/v的/ude1时候/n，/w我们/rr一般/ad就/d会/v想到/v使用/gi多线程/gi来/vf处理/vn那些/rz耗时/vi的/ude1操作/gi。/w多线程/gi，/w在/p很/d多/a的/ude1编程语言/gi中都/ns是/vshi一个/mq相对/d比较/gi难/a的/ude1地方/n，/w主要/b涉及/v到/v线程/gi的/ude1生命周期管理/gi，/w要/v创建/gi多少/ry条/q线程/gi才/d合理/a，/w等/udeng很/d多/a问题/gi，/w在/pios/gi开发/gi中/f，/w多线程/gi使用/gi相对/d难道/d不是/c很大/d，/w很/d多/a复杂/a的/ude1处理过程/l系统/gi已经/d给/p我们/rr封装/gi好/a了/ule，/w我们/rr只/d需要/v调用/gi系统/gi给/p我们/rr封装/gi好/a的/ude1方法/gi就/d能够/v实现/gi多线程/gi，/w其中/rz比较/gi好/a用/p的/ude1有/vyougcd/nz和/ccnsoperationqueue/nz,/nz这/rzv两/nz个/q就/d能/v为/p我们/rr很/d方便/a的/ude1实现/gi多线程/gi，/w当然/dnsthread/nz也/d能/v实现/gi多线程/gi，/w不过/c相对于/nz前/f两/nz个/qnsthread/nz就/d需要/v更多/ad方面/n的/ude1注意/v了/ule，/w好/a了/ule下面/f给/p大家/rr简单/a的/ude1介绍/gi一/nz下/f这/rzv几个/nz开启/gi多线程/gi的/ude1方法/gi。/w2./nznsthread/nz的/ude1简单/a使用/gi??/nznsthread/nz使用/gi相对/d还是/c比较简单/l,/nz可以/v通过/p出/vf一个/mq实例化/gi方法/gi，/w然后/c调用/gi方法/gi来/vf创建/gi一个/mq线程/gi;/nz??/nz上面/f我们/rr是/vshi通过/p创建/gi一个/mq实例/gi的/ude1方式/n来/vf创建/gi一个/mq线程/gi，/wnsthread/nz提供/v了/ule一个/mq类/gi方法/gi通过/p这个/rz类/gi方法/gi我们/rr也/d可以/v很/d方便/a的/ude1创建/gi一个/mq线程/gi;/nz??/nznsthread/nz通过/p上面/f两/nz种/q方式/n就/d能够/v创建/gi出/vf多线程/gi，/w完成/v耗时/vi操作/gi的/ude1任务/gi，/w在/pnsthread/nz类/gi里面/f也/d有/vyou几/d个/q比较/gi常用/a的/ude1属性/gi和/cc方法/gi需要/v我们/rr熟悉/v??/nz除了/pnsthread/nz可以/v开启/gi新/a线程/gi以为/v，/w我们/rr在/p处理/vn比较简单/l的/ude1耗时/vi操作/gi的/ude1时候/n还/d可以/v使/v用来/v完成/v相应/vi的/ude1操作/gi。/w??/nznsthread/nz如何/ryv开启/gi新/a线程/gi的/ude1方法/gi就/d介绍/gi到/v这里/rzs，/w当然/d还有/v很/d多/a很/d多/a的/ude1地方/n没有/v介绍/gi到/v，/w这里/rzs直接/ad简单/a的/ude1给/p大家/rr说说/v平时/t使用/gi比较/gi多/a的/ude1方法/gi，/w欢迎/v大家/rr多/a提意见/nz，/w共同/d学习/gi和/cc进步/vn。/w介绍/gi完/vinsthread/nz之后/f，/w接下来/vl进入/v我们/rrios/gi中/f比较/gi重要/a的/ude1gcd/nz了/ule。/w3./nzgcd/nz(/nz很/d牛逼/nz的/ude1中枢/n调度器/nz)/nz的/ude1简单/a使用/gi??/nz先/d给/p大家/rr介绍/gi一个/mq简单/a的/ude1使用/gigcd/nz创建/gi的/ude1多线程/gi:/w??/nz通过/p上面/f的/ude1例子/gi我们/rr可以/v看出/v，/w使用/gigcd/nz很/d方便/a的/ude1就/d开启/gi了/ule一个/mq新的/a线程/gi来/vf执行/v我们/rr的/ude1耗时/vi操作/gi，/w在/p上面/f调用/gi来/vf创建/gi一个/mq并发/gi的/ude1队列/gi,/nz函数/gi的/ude1时候/n需要/v传入/gi一个/mq优先级/n，/w和/cc一个/mqflags/nz，/w其中/rzflags/nz是/vshi一个/mq备用/vn参数/gi系统/gi让/v我们/rr只/d需要/v传入/gi0/nz就/d可以/v，/w优先级/n系统/gi给/p我们/rr提供/v了/ule四个/nz选项/gi??/nz如果/c在/p刚才/t的/ude1queue/nz里面/f同时/c添加/gi两/nz个/q任务/gi的话/udh，/w两/nz个/q任务/gi会/v并发/gi执行/v，/w因为/c我/rr刚刚/d创建/gi的/ude1是/vshi一个/mq并发/gi队列/gi；/w执行/v结果/n:/w  /x从/p这个/rz结果/n我们/rr可以/v看出/v两/nz个/q任务/gi在/p不同/a的/ude1线程/gi，/w并且/c他们/rr的/ude1执行/v时间/gi是/vshi相同/a的/ude1，/w这/rzv就是/v并发/gi队列/gi的/ude1效果/gi。/w /x??/nz有/vyou并发/gi队列/gi就/d有/vyou串行/b队列/gi，/w串行/b队列/gi的/ude1特点/n就是/v执行/v完/vi第一个/gi任务/gi才/d会/v开始/v执行/v第二个/nz任务/gi，/w在/pgcd/nz里面/f我们/rr可以/v通过/p创建/gi一个/mq串行/b队列/gi，/w我们/rr只/d需要/v把/pba我们/rr的/ude1任务/gi加入/v到/v串行/b队列/gi里面/f，/w任务/gi就/d会/v按照/p顺序/gi执行/v。/w执行/v结果/n:/w  /x从/p两/nz个/q任务/gi的/ude1执行/v的/ude1时间/gi我们/rr可以/v很/d清楚/a的/ude1看出/v是/vshi先/d执行/v完了/vi第一个/gi任务/gi才/d执行/v第二个/nz任务/gi。/w简单/a的/ude1并发/gi和/cc串行/b任务/gi讲完/v之后/f，/w我/rr想/v大家/rr肯定/v还有/v如果/c有/vyoua/nz、/wb/nz、/wc/nz三个/nz任务/gi要/v把/pbaa/nz、/wb/nz执行/v完成/v之后/f才/d执行/vc/nz任务/gi的/ude1需求/gi，/w做/v这种/r的/ude1需要/v的/ude1时候/n我们/rr就/d会/v使用/gi来/vf创建/gi一个/mq组/n，/w把/pbaa/nz、/wb/nz两/nz个/q任务/gi添加/gi到/v组/n里面/f，/w然后/c等/udeng组/n执行/v完/vi之后/f才/d执行/vc/nz，/w具体/a看/v以下/f代码执行/n结果/n:/w  /x能够/v看出/vab/nz两/nz个/q任务/gi并发/gi执行/v，/w执行/v完成/v之后/f才/d执行/vc/nz任务/gi的/ude1。/w gcd/nz的/ude1基本/a使用/gi方法/gi就/d介绍/gi到/v这里/rzs，/w再/d给/p大家/rr列举/v一/nz些/q可能会/nz用/p到/v的/ude1方法/gi名称/n:/w4./nznsoperationqueue/nz实现/gi多/a线/n程废话/nz就/d不说/c了/ule，/w先/d来/vf一段/nz代码/gi，/w让/v大家/rr先/d看看/v到底/d是/vshi怎么/ryv实现/gi的/ude1执行/v结果/n:/w  /x??/nz从/p上面/f代码/gi我们/rr可以/v看出/v，/w在/p使用/gi的/ude1时候/n还是/c必须/d先/d创建/gi一个/mq队列/gi，/w然后/c再/d创建/gi需要/v加入/v多线程/gi的/ude1任务/gi，/w然后/c把/pba创建/gi好/a的/ude1任务/gi添加/gi到/v队列/gi里面/f，/w这样/rzv一个/mq多线程/gi就/d创建/gi完成/v了/ule。/w上面/f往/p队列/gi里面/f添加/gi任务/gi分别/d用/p了/ule两/nz种/q不同/a的/ude1方式/n，/w一种/nz是/vshi创建/gi了/ule一个/mq而/cc另外/c一种/nz则/d是/vshi调用/gi队列/gi的/ude1方法/gi往/p队列/gi里面/f添加/gi任务/gi。/w两种/nz方式/n实现/gi的/ude1最后/f效果/gi都/d是/vshi一样/uyy的/ude1。/w??/nz在/p使用/ginsoperationqueue/nz创建/gi多线程/gi的/ude1时候/n方式/n其实/d和/ccgcd/nz基本一致/d，/w都/d是/vshi创建/gi任务/gi然后/c加入/v队列/gi里面/f，/w在/pnsoperationqueue/nz可以/v设置/gi最大/gm线程/gi数/n和/cc任务/gi之间/f的/ude1相互依赖/nz，/w以下/f代码实现/gi不同/a任务/gi间/f的/ude1依赖/v关系/gi??/nznsoperationqueue/nz里面/f还有/v几/d个/q常用/a的/ude1方法/gi大家/rr需要/v记住/v5./nz线程安全/gi??/nz线程安全/gi实质/gi就是/v多/a个/q线程/gi同时/c访问/gi或者/c修改/gi同一个/b资源/gi的/ude1时候/n导致/gi，/w资源/gi的/ude1内容/gi与/cc实际/n内容/gi不/d匹配/gi，/w这个/rz时候/n我们/rr就/d需要/v给/p修改/gi的/ude1资源/gi添加/gi如下/vi代码/gi通过/p这个/rz代码/gi就/d可以/v防止/gi多/a个/q线程/gi同时/c修改/gi一个/mq资源/gi，/w保证/v了/ule每次/r修改/gi该/rz资源/gi只有/c一个/mq线程/gi。/w