#机房/gi收费/gi系统--设计/nz模式/gi思考/gi
    /x今天/t与/cc阿真/nz同学/n简略/a讨论/gi了/ule一下/m外观模式/gi和/cc抽象工厂/gi反射/gi配置文件/gi在/p机房重构/gi中的/v应用/gi，/w引发/v了/ule几/d个/q简单/a的/ude1思考/gi，/w现/tg与/cc君/ng共/d勉/vg：/w    /x1./nz b/nz层/gi为什么/ryv觉得/v按照/p数据库表/gi来/vf划分/v比较/gi合理/a？/w       /x思考/gi再三/d：/wb/nz层/gi方法/gi是/vshi实现/gi对/p数据表/gi的/ude1增删/v改查/nz进行/vn逻辑/n操作/gi，/w而且/c还要/d考虑/v解耦/gi效果/gi（/w我/rr是/vshi这么/rz理解/gi耦合/vn的/ude1，/w如果/c一个/mq类/gi中/f只/d放/v一个/mq方法/gi，/w一旦/d出错/gi，/w它/rr只/d影响/gi自己/rr，/w耦合度/gp就/d低/a；/w如果/c有/vyou十个/nz方法/gi，/w一个/mq方法/gi出错/gi，/w该类/r的/ude1实例化/gi就/d会/v出错/gi，/w这样/rzv耦合/vn程度/n就越/d强/a）/w，/w所以/cb/nz层/gi的/ude1类/gi中/f放/v的/ude1方法/gi不应/v太多/ad；/w考虑到/v每个/r窗体/gi大部分/n都/d是/vshi对/p一/nz张/q表/n进行/vn的/ude1操作/gi，/w这样/rzv，/w将/d每张/r表/n对应/vi的/ude1增删/v改查/nz操作/gi放到/v一个/mqb/nz层/gi类/gi中/f，/w大部分/n调用/gi时/qt只/d需要/v实例化/gi一个/mqb/nz层/gi类/gi就/d可以/v实现/gi对/p整个/b窗体/gi的/ude1操纵/gi任务/gi，/w既/c减少/v程序执行/n流程/gi，/w又/d减轻/v电脑/gi负担/n，/w何乐而不为/vl呢/y？/w   /x2./nz /x外观层/nz可不可以/v用/p一个/mq类/gi来/vf实现/gi呢/y？/w对比/gi于/p一个/mq窗体/gi一个/mqfacade/gi类/gi有/vyou什么/ry区别/gi？/w外观/gi类/gi按照/p数据表/gi来/vf分/qt有/vyou什么/ry坏处/n？/w   /x讨论/gi想法/gi：/w外观/gi类/gi先/d对/p方法/gi实例化/gi然后/c再/d调用/gi的/ude1，/w每/rz实例化/gi一次/nz，/w相当于/v把/pba外观/gi中用/a到/v的/ude1类/gi都/d实例化/gi了/ule一次/nz，/w无论是/c用/p到/v还是/c没有/v用/p到/v的/ude1。/w      /x如果/cfacade/gi用/p一个/mq类/gi实现/gi所有/bb/nz层/gi方法/gi，/w那么/c20/nz多/a个/q窗体/gi每个/r窗体/gi调用/gi都/d要/v实例化/gi一次/nzfacade/gi类/gi，/w就是/vb/nz层/gi所有/b的/ude1方法/gi都/d调用/gi了/ule20/nz多/a次/qv，/w造成/v大量/m无用/vi程序/gi的/ude1执行/v。/w   /x一个/mq窗体/gi一个/mqfacade/gi类/gi，/w用/p到/vfacade/gi类/gi中/f实例化/gi的/ude1方法/gi都/d是/vshi马上/d要用/v到/v的/ude1，/w这样/rzv所有/bb/nz层/gi方法/gi实例化/gi次数/gi大大降低/n，/w基本上/d就是/v每个/r执行/v1/nz--/nz2/nz次/qv，/w这样/rzv电脑/gi的/ude1负担/n不会/v很大/d了/ule。/w   /x还是/c同样/d的/ude1分析方法/nz，/w尽管/cb/nz层/gi方法/gi不会/v调用/gi多/a次/qv，/w但/c诸如/v上机/vi结账/gi等/udeng窗体/gi不止/v用/p到/v一/nz张/q表/n，/w而/cc恰恰/dfacade/gi类/gi也/d是/vshi按照/p表分/nz的/ude1，/w那么/c对/pfacade/gi类/gi的/ude1调用/gi次数/gi势必会/n增加/v。/w  /x3./nz /x抽象工厂/gi反射/gi配置文件/gi的/ude1应用/gi优势/gi    /x说/v到/v工厂/gi家族/gi，/w难免会/l想到/v它们/rr对/pswitch/nz语句/gi的/ude1钟爱/v，/w但/c如果/c数据库表/gi的/ude1数目/gi过于/d庞大/a，/w又/d要求/n可以/v使用/gi不同/a的/ude1数据库/gi切换/vn时/qt，/wswtich/nz难免会/l增加/v许多无谓/nz的/ude1判断/gi，/w这样/rzv通过/p工厂/gi反射/gi配置文件/gi的/ude1方式/n，/w实现/gi对/pd/nz层/gi方法/gi直接/ad调用/gi，/w同时/c容易/ad实现/gi对/p数据库/gi的/ude1切换/vn。/w【/w总结/gi】/w    /x在/p机房/gi设计/gi初期/f只是/d听说/v这些/rz设计/gi方法/gi和/cc设计模式/nz就/d直接/ad加以/vx应用/gi了/ule，/w而且/c对/p外观模式/gi应用/gi认识/v不到/v位/q，/w导致/giu/nz层/gi出现/v了/ule很/d多/a逻辑/n判断/gi，/w反过头/nz来/vf思考/gi才能/n意识到/v这些/rz设计模式/nz的/ude1妙处/n，/w相信/v对接/vi下来/vf的/ude1设计模式/nz的/ude1应用/gi学习会/n更加/d灵活/a方便/a。/w