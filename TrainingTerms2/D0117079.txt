#linux/gi下/f零拷贝/gi技术/gi
传统/n的/ude1数据传输/gi方式/n /x很长/d一段时间/nz内/f，/w数据/gi拷贝/gi的/ude1认识/v仅仅/d停留/vi在/p应用/gi程序层/nz，/w实际上/d隐藏/v在/p背后/f的/ude1数据/gi拷贝/gi行为/n比/p想象/v的/ude1要/v多/a的/ude1多/a。/w在/p传输数据/n的/ude1时候/n，/w用户/gi应用程序/nz需要/v分配/gi一块/s合适/a大小/n的/ude1缓冲区/gi来/vf存放/v需要/v传输/gi的/ude1数据/gi。/w用户/gi从/p应用程序/nz中/f读取数据/n，/w然后/c发送/gi出去/vf，/w只/d需要/v两/nz个/q系统/gi调用/giread/nz,/nzwrite/gi即可/v完成/v数据传输/gi工作/gi，/w应用程序/nz并不知道/l这个/rz数据传输/gi过程/gi中/f操作系统/gi进行/vn了/ule多少/ry次/qv拷贝/gi操作/gi。/w某些/rz情况下/nz，/w这些/rz数据/gi拷贝/gi操作/gi会/v极大/a的/ude1降低/v数据传输/gi的/ude1性能/gi。/w(/nznic/nz,/nznetwork interface card /nz)/nz  /x传统/n的/ude1数据/gi拷贝/gi方式/n，/w如下/vi图/gi：/w上线/n文/ng切换/vn，/w如/v图/gi：/w涉及/v的/ude1步骤/gi：/w(/nz1/nz)/nzread/nz(/nz)/nz调用/gi引发/v从/p用户/gi模式/gi到/v内核/gi模式/gi的/ude1上下文/gi切换/vn（/w第一次/nz切换/vn）/w，/w在/p内部/f，/w发出/vsys/nz_/nzread/nz(/nz或者/c同等/b内容/gi)/nz从/p设备/gi中/f读取数据/n，/w直接/ad内存/gi读取/gi(/nzdirect memory access/nz,/nzdma/nz)/nz执行/v了/ule拷贝/gi（/w第一次/nz拷贝/gi）/w，/w它/rr从/p磁盘/gi中/f读取/gi内容/gi，/w然后/c将/d他们/rr存储/gi到/v一个/mq内核/gi地址/gi空间/n缓冲区/gi中/f；/w(/nz2/nz)/nz数据/gi从/p读/v缓冲区/gi拷贝到/nz用户/gi缓冲区/gi（/w第二次/nz拷贝/gi）/w，/wread/nz(/nz)/nz调用/gi返回/v。/w该/rz调用/gi返回/v引发/v内核/gi模式/gi到/v用户/gi模式/gi的/ude1切换/vn（/w第二次/nz切换/vn）/w。/w现在/t数据/gi被/pbei存储/gi在/p用户/gi空间/n缓冲区/gi中/f；/w(/nz3/nz)/nz send/nz(/nz)/nz套接字/n调用/gi引发/v用户/gi模式/gi到/v内核/gi模式/gi的/ude1上下文/gi切换/vn（/w第三次/nz切换/vn）/w，/w数据/gi再次/d被/pbei放置/gi到/v内核/gi地址/gi空间/n缓冲区/gi中/f（/w第三次/nz拷贝/gi）/w。/w这次/r放置/gi的/ude1缓冲区/gi与/cc目标/gi套接字/n关联/vn；/w(/nz4/nz)/nz send/nz(/nz)/nz系统/gi调用/gi返回/v，/w从/p内核/gi模式/gi切换/vn到/v用户/gi模式/gi（/w第四次/nz切换/vn）/w，/wdma/nz引擎/n将/d数据/gi从/p内核/gi缓冲区/gi传输/gi到/v协议/gi引擎/n（/w第四次/nz拷贝/gi）/w。/wdma/nz允许/v外围设备/gi和/cc贮存/v之间/f直接/ad传输/giio/gi数据/gi，/wdma/nz依赖于/v系统/gi。/w每/rz一/nz种/q体系结构/gidma/nz传输/gi不同/a，/w编程/gi接口/gi也/d不同/a。/w数据传输/gi可以/v以/p两种/nz方式/n触发/gi：/w一种/nz所/usuo软件/gi请求/gi数据/gi，/w另一种/nz所/usuo硬件/gi异步/gi传输/gi。/w以/pread/nz为/p例/n，/w它/rr即/v采用/v第一种/nz方式/n,/nz其/rz步骤/gi如下/vi：/w(/nz1/nz)/nz /x进程/gi调用/giread/nz时/qt，/w驱动程序/gi分配/gi一个/mqdma/nz缓冲区/gi，/w随后/d指示/gi硬件/gi传送/v它/rr的/ude1数据/gi，/w进程/gi进入/v睡眠/vn；/w(/nz2/nz)/nz /x硬件/gi将/d数据/gi写入/gidma/nz缓冲区/gi并/cc在/p完成/v时/qt产生/v一个/mq中断/gi；/w(/nz3/nz)/nz /x中断/gi处理程序/n获取/gi输入/v数据/gi，/w应答/gi中断/gi，/w最后/f唤醒/gi进程/gi，/w可以/v读取数据/n了/ule。/w由此可见/c，/w在/p传统/n的/ude1数据传输/gi中/f，/w系统/gi方面/n总共/d进行/vn了/ule4/nz次/qv数据/gi拷贝/gi，/w4/nz次/qv上线/n文/ng切换/vn，/w这些/rz都会/n对/p服务器/gi性能/gi造成/v很大/d影响/gi。/w零拷贝/gi概述/gi  /x简单/a的/ude1说/v，/w零拷贝/gi是/vshi一种/nz避免/vcpu/gi将/d数据/gi从/p一快/nz存储/gi拷贝到/nz另外/c一块/s存储/gi的/ude1技术/gi。/w零拷贝/gi技术/gi的/ude1目标/gi：/w /x避免/v数据/gi拷贝/gi  /x#/nz避免/v操作系统/gi内核/gi缓冲区/gi之间/f进行/vn数据/gi拷贝/gi操作/gi；/w  /x#/nz避免/v操作系统/gi内核/gi和/cc用户/gi应用程序/nz地址/gi空间/n之间/f进行/vn数据/gi拷贝/gi操作/gi；/w  /x#/nz用户/gi应用程序/nz可以/v避免/v操作系统/gi直接/ad访问/gi硬件/gi存储/gi；/w  /x#/nz数据传输/gi尽量/d让/vdma/nz来/vf处理/vn。/w /x多/a种/q操作/gi结合/v在/p一起/s  /x#/nz避免/v不必要/a的/ude1系统/gi调用/gi和/cc上下文/gi切换/vn；/w  /x#/nz需要/v拷贝/gi的/ude1数据/gi可以/v先/d缓存/gi起来/vf；/w  /x#/nz对/p数据/gi进行/vn的/ude1处理/vn尽量/d让/v硬件/gi来/vf做/v。/w零拷贝/gi的/ude1实现/gi方式/n分类/gi直接/adio/gi主要/b是/vshi通过/p减少/v操作系统/gi内核/gi缓冲区/gi和/cc应用程序/nz地址/gi空间数据/nz拷贝/gi次数/gi，/w降低/v对/p文件读取/gi和/cc写入/gi时/qt带来/v的/ude1cpu/gi使用/gi和/cc带宽/n的/ude1开销/n。/w对于/p某些/rz应用程序/nz，/w比如说/vl自/p缓冲/vn应用程序/nz来说/uls，/w会/v是/vshi一个/mq比较/gi好/a的/ude1选择/gi。/w如果/c要/v传输/gi的/ude1数据量/n大/a，/w使用/gi直接/adio/gi的/ude1方式/n进行/vn数据传输/gi，/w而/cc不/d需要/v操作系统/gi内核/gi地址/gi空间/n拷贝/gi数据/gi的/ude1参与/gi，/w这/rzv将/d会/v提高/v性能/gi。/w  /x直接/adio/gi并/cc不是/c所有/b的/ude1情况下/nz都/d有效/gi。/w设置/gi直接/adio/gi的/ude1开销/n非常/d大/a，/w而且/c不能/v利用/v缓存/giio/gi的/ude1优势/gi。/w直接/adio/gi的/ude1读/v操作/gi会/v造成/v磁盘/gi的/ude1同步/gi读/v，/w执行/v进程/gi需要/v在/p很长/d的/ude1时间/gi才能/n执行/v完/vi；/w而/cc写/v操作/gi会/v导致/gi应用程序/nz关闭/gi缓慢/a。/w应用程序/nz使用/gi直接/adio/gi进行/vn数据传输/gi通常/d和/cc异步/giio/gi结合/v使用/gi。/w linux/nz内核/gi已经/d为/p块/q设备/gi执行/v直接/adio/gi提供/v了/ule支持/v，/w应用程序/nz直接/ad访问/gi文件/gi而/cc不/d经过/p操作系统/gi页/q高速缓冲存储器/nz的/ude1时候/n，/w打开/gi文件/gi(/nzopen/nz(/nz)/nz syscall/nz)/nz指定/vo/nz_/nzdirect/nz标示符/nz。/w  /x总之/c，/w这种/r数据传输/gi方式/n，/w应用程序/nz直接/ad访问/gi硬件/gi存储/gi，/w操作系统/gi内核/gi只是/d辅助/vn数据传输/gi；/w它/rr一般/ad用于/v操作系统/gi不/d需要/v对/p数据/gi进行/vn处理/vn的/ude1情况/n，/w数据/gi可以/v再/d应用程序/nz地址/gi空间/n的/ude1缓冲区/gi和/cc磁盘/gi之间/f进行/vn传输/gi，/w而/cc不/d需要/vlinux/gi操作系统/gi内核/gi提供/v页/q缓存/gi支持/v。/w针对/gi数据传输/gi不/d需要/v经过/p应用程序/nz地址/gi空间/n的/ude1零拷贝/gi技术/gi数据传输/gi过程/gi中/f，/w避免/v数据/gi在/p系统/gi内核/gi地址/gi空间/n的/ude1缓冲区/gi和/cc用户/gi应用程序/nz地址/gi空间/n的/ude1缓冲区/gi进行/vn拷贝/gi。/w有时候/d，/w应用程序/nz在/p数据传输/gi的/ude1过程/gi中/f不/d需要/v对/p数据/gi进行/vn访问/gi，/w将/d数据/gi从/plinux/gi的/ude1页/q缓存/gi拷贝到/nz用户/gi进程/gi的/ude1缓冲区/gi就/d可以/v完全避免/nz，/w传输/gi的/ude1数据/gi在/p页/q缓冲/vn中/f就/d可以/v处理/vn。/w在/p某些/rz情况下/nz，/w这种/r零拷贝/gi技术/gi能/v获得/v很好/ad的/ude1性能/gi。/wlinux/gi下/f提供/v类/gi的/ude1系统/gi调用/gi主要/b有/vyoummap/nz(/nz)/nz,/nzsendfile/nz(/nz)/nz,/nzsplice/nz(/nz)/nz./nz  /x使用/gimmap/nz替代/vread/nz,/nz可以/v减少/vcpu/gi拷贝/gi次数/gi。/w当/p应用程序/nz调用/gimmap/nz(/nz)/nz之后/f，/w数据/gi通过/pdma/nz拷贝/gi拷贝到/nz内核/gi缓冲区/gi，/w应用程序/nz和/cc操作系统/gi共享/gi这个/rz缓冲区/gi。/w这样/rzv，/w操作系统/gi内核/gi和/cc应用程序/nz存储空间/gi不再/d需要/v进行/vn任何/rz的/ude1数据/gi拷贝/gi操作/gi。/w当/p进行/vnwrite/gi(/nz)/nz系统/gi调用/gi时/qt，/w数据/gi由/p内核/gi缓冲区/gi拷贝到/nzsocket/gi缓冲区/gi，/w再/d拷贝到/nz协议/gi引擎/n中/f。/w /x这种/r也/d比较/gi适用/vi于/p传送/v的/ude1数据/gi不/d需要/v经过/p操作系统/gi内核/gi的/ude1处理/vn或者/c不/d需要/v经过/p程序/gi的/ude1处理/vn直接/ad传输/gi的/ude1情况/n。/w结合/vsocket/gi也/d能/v使用/gimmap/nz,/nz不过/c只能/v在/praw/nz的/ude1情况下/nz使用/gi。/w对于/p传统/n的/ude1c/nz//nzs/nz网络游戏/nz结构/gi来说/uls，/w使用/gi的/ude1意义/n不大/d。/w对/p应用程序/nz地址/gi空间/n和/cc内核/gi空间/n的/ude1数据传输/gi进行/vn优化/gi的/ude1零拷贝/gi技术/gi对/p数据/gi在/plinux/gi页/q缓存/gi和/cc用户/gi进程/gi缓冲区/gi之间/f的/ude1传输/gi进行/vn优化/gi。/w该/rz零拷贝/gi技术/gi侧重/gi于/p灵活/a的/ude1处理/vn数据/gi在/p用户/gi进程/gi中的/v缓冲区/gi和/cc操作系统/gi的/ude1页/q缓冲区/gi之间/f的/ude1拷贝/gi操作/gi。/w这种/r方式/n延续/v了/ule传统/n的/ude1通信/gi方式/n，/w但是/c更加/d灵活/a。/wlinux/gi中/f该/rz方法/gi主要/b利用/v写/v时/qt复制技术/n。/w  /x写/v时/qt复制/gi是/vshi计算机/gi编程/gi中/f常见/a的/ude1一种/nz优化/gi策略/gi，/w基本/a思想/gi是/vshi这样/rzv的/ude1：/w如果/c多/a个/q应用程序/nz需要/v同时/c访问/gi一块/s数据/gi，/w那么/c可以/v为/p这些/rz应用程序/nz分配/gi指向/v这块/r数据/gi的/ude1指针/gi，/w在/p每个/r应用程序/nz看来/v，/w他们/rr都/d拥有/v这块/r数据/gi的/ude1一份/nz拷贝/gi，/w当/p其中/rz一个/mq应用程序/nz需要/v对/p自己/rr的/ude1这份/r数据/gi进行/vn修改/gi时/qt，/w就/d需要/v将/d数据/gi真正/d的/ude1拷贝到/nz应用程序/nz的/ude1地址/gi空间/n去/vf。/w如果/c应用程序/nz永远/d不会/v对/p这块/r数据/gi进行/vn修改/gi，/w那么/c就/d永远/d不/d需要/v将/d数据/gi拷贝到/nz应用程序/nz的/ude1地址/gi空间/n去/vf。/w在/pstl/gi中/fstring/gi的/ude1实现/gi类/gi这种/r策略/gi。/w参考/gi：/wlinux /nz中的/v零拷贝/gi技术/gi /x第/mq1/nz部分/nlinux /nz中的/v零拷贝/gi技术/gi /x第/mq2/nz部分/nlinux/gi系统/gi内核/gi空间/n与/cc用户/gi空间通信/n的/ude1实现/gi与/cc分析/gi从/plinux/gi内核/gi访问/gi用户/gi空间/n内存/gilinux/gi中/f直接/adio/gi机制/gi的/ude1介绍/gi通过/p零拷贝/gi实现/gi有效/gi的/ude1数据传输/gi