#java/gi排序算法/gi
1/nz，/w排序算法/gi：/w /x排序算法/gi：/w分为/v内部/f排序/gi和/cc外部/f排序/gi。/w /x内部/f排序/gi：/w数据/gi记录/gi在/p内存/gi中/f进行/vn排序/gi。/w外部/f排序/gi：/w是/vshi因/p排序/gi的/ude1数据/gi很大/d，/w一次/nz不能容纳/nz全部/m的/ude1排序/gi记录/gi。/w在/p排序/gi过程/gi中/f需要/v访问/gi外存/n。/w八大/j排序算法/gi：/w /x内部/f排序/gi：/w /x插入排序/gi：/w直接插入排序/gi，/w希尔排序/gi，/w二分/gi插入/gi算法/gi（/w插入/gi算法/gi是/vshi比较稳定/n的/ude1排序/gi）/w  /x选择排序/gi：/w简单/a选择排序/gi，/w堆排序/gi。/w /x交换排序/gi：/w冒泡排序/gi，/w快速排序/gi。/w /x归并排序/gi /x基数排序/gi /x外部/f排序/gi：/w内外/f存/v相结合/nz的/ude1排序/gi。/w//nz//nz堆排序/gi算法/gi：/w一种/nz树形选择排序/gi算法/gi，/w是/vshi对/p直接/ad选择排序/gi的/ude1有效/gi改进/gi。/w堆/gi的/ude1定义/gi如下/vi：/w若以/c一维/n数组/gi存贮/vn一个堆/nz，/w则/d堆/gi对应/vi一/nz棵/q完全/ad二叉树/gi。/w且/c所有/b非叶节点/nz的/ude1均/d不/d大于/v（/w或/c不/d小于/v）/w其/rz子女/n的/ude1，/w根/n节点/gi（/w堆顶/nz元素/gi）/w的/ude1置/v是/vshi最小/a（/w或/c最大/gm）/w的/ude1。/w排序/gi原理/gi：/w初始/b时/qt把/pba要/v排序/gi的/ude1n/nz个数/n的/ude1序列/gi看做/v是/vshi一棵树/nz顺序存储/gi的/ude1二叉树/gi，/w调整/vn他们/rr的/ude1存储/gi顺序/gi，/w使/v之/uzhi成为/v一个/mq堆/gi。/w将/d堆/gi顶/v元素/gi输出/gi，/w得到/vn/nz个/q元素/gi中/f最小/a（/w或/c最大/gm）/w的/ude1元素/gi，/w这时/rzt堆/gi的/ude1根/n节点/gi的/ude1数/n最小/a（/w或者/c最大/gm）/w，/w然后/c对/p前面/f（/wn/nz-/nz1/nz）/w个/q元素/gi重新/d调整/vn之/uzhi使/v之/uzhi成为/v堆/gi,/nz输出/gi堆/gi顶/v元素/gi为/p堆/gi。/w得到/vn/nz个/q元素/gi中/f次/qv小/a（/w或/c次/qv大/a）/w的/ude1元素/gi。/w以此类推/vl，/w知道/v只有/c两/nz个/q节点/gi的/ude1堆/gi，/w并/cc对/p他们/rr做/v交换/gi，/w最后/f得到/v有/vyoun/nz个/q节点/gi的/ude1有序/gi序列/gi，/w成/v这个/rz过程/gi为/p堆排序/gi。/w实现/gi:/w /x1/nz,/nz将/dn/nz个/q待/vi排序/gi的/ude1数/n建成/v堆/gi。/w /x2/nz，/w输出/gi堆/gi顶/v元素/gi后/f，/w怎样/ryv调整/vn剩余/vnn/nz-/nz1/nz个/q元素/gi，/w使/v其/rz成为/v一个/mq新堆/nz。/w