#面向对象/gi设计模式/nz基础/gi
首先/d：/w使用/gi面向对象/gi设计模式/nz能够/v使/v代码/gi：/w易/ad维护/gi，/w可/v复用/gi，/w可扩展/nz，/w灵活性/gi好/a；/w（/w这/rzv是/vshi我们/rr需要/v达到/v的/ude1目标/gi）/w /x其次/c：/w如果/c想要/v达到/v这样/rzv的/ude1目标/gi，/w就/d需要/v在/p代码/gi的/ude1设计/gi过程/gi中/f，/w遵守/v以下/f的/ude1原则/gi：/w /x（/w显示/gi简单/a的/ude1说明/v）/w1./nz开放/gi封闭/gi的/ude1原则/gi /x尽量/d对/p修改/gi关闭/gi，/w对/p扩展/gi开启/gi /x2./nz高/a内聚/nz低/a耦合/vn的/ude1原则/gi /x模块/gi内部/f紧凑/a，/w模块/gi之间/f耦合度/gp较小/d /x3./nz单一职责原则/gi /x每/rz一个/mq模块/gi应该/v负责/v单一/gi的/ude1职责/gi /x4./nz依赖倒转原则/gi:/w /x(/nzpc/nz机/ng复杂/a，/w但是/c便于/v修理/vn，/w是因为/c内存/gi和/cccpu/gi没有/v依赖于/v主板/gi进行/vn开发/gi,/nz都/d是/vshi面向/v接口/gi的/ude1开发/gicpu/gi和/cc内存/gi不/d依赖于/v主板/gi，/w主板/gi也/d不/d依赖于/v内存/gi，/w大家/rr都/d依赖于/v接口/gi，/w就是/v依赖倒转原则/gi)/nz /x原有/v的/ude1面向/v过程/gi的/ude1模式/gi中高层/b模块/gi依赖于/v低层/n模块/gi,/nz这样/rzv底层/n模块/gi出现/v问题/gi时/qt，/w高层/n就/d会/v全部/m出现/v问题/gi，/w所以/c,/nz细节/gi应该/v依赖于/v抽象/gi(/nz也/d就是说/c无论是/c高层/n模块/gi还是/c低层/n模块/gi，/w都/d不要/d相互依赖/nz，/w而是/c依赖于/v某个/rz接口/gi规范/gi)/nz,/nz要/v达到/v所有/b的/ude1依赖/v关系/gi都/d终止/v于/p抽象类/gi或者/c接口/gi！/w依赖/v抽象/gi!/nz!/nz!/nz!/nz!/nz /x5./nz李氏/nz代换/v原则/gi：/w /x子/ng类型/gi必须/d能够/v替换/v掉/v他们/rr的/ude1父/ng类型/gi(/nz这/rzv是/vshi实现/gi开闭/nz原则/gi的/ude1基础/gi)/nz /x6./nz迪米特/nrf法则/gi：/w /x如果/c两/nz个/q类/gi不必/d彼此/rr直接/ad通信/gi，/w那么/c这/rzv两/nz个/q类/gi不应/v发生/v直接/ad的/ude1相互作用/n。/w如果/c其中/rz一个/mq类/gi需要/v调用/gi另一个/nz类/gi，/w可以/v通过/p第三方/nz转发/gi这个/rz调用/gi。/w强调/v类/gi之间/f的/ude1低/a耦合/vn /x7./nz合成/gi//nz聚合/gi复用/gi原则/gi：/w /x尽量/d使用/gi聚合/gi而/cc不要/d使用/gi继承/gi，/w一味/d的/ude1使用/gi继承/gi结构/gi会/v使得/vi整个/b程序结构/n不/d可控/nz，/w即/v修改/gi部分/n需求/gi需要/v修改/gi大量/m的/ude1原代码/nz，/w注意/v继承/gi是/vshi一种/nz强耦合/nz结构/gi为了/p体现/v面向对象/gi的/ude1优势/gi，/w就要/d达到/v这样/rzv的/ude1设计原则/gi，/w设计模式/nz是/vshi原则/gi的/ude1应用/gi！/w！/w！/w