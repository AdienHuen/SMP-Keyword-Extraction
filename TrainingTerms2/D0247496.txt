#【/w设计模式/nz】/w合成/gi复用/gi原则/gi
    /x我们/rr知道/v面向对象/gi的/ude1三大/j基本特征/nz是/vshi封装/gi、/w继承/gi和/cc多态/gi。/w可见/c继承/gi在/p面向对象/gi中的/v重要性/n。/w但是/c在/p设计模式/nz中/f，/w我们/rr要/v遵守/v这样/rzv一个/mq原则/gi，/w这个/rz原则/gi要/v让/v我们/rr要/v尽量少/l用/p继承/gi。/w这/rzv是/vshi为何/ryv？/w    /x在/p解决/v这个/rz问题/gi之前/f，/w我们/rr先/d看看/v何为/c继承/gi何为/c组合/gi。/w    /x继承/gi就/d不/d多/a解释/gi了/ule。/w合成/gi，/w就是/v在/p一个/mq新的/a对象/gi里/f使用/gi一/nz些/q已经/d有的/rz对象/gi，/w使/v之/uzhi成为/v新/a对象/gi的/ude1一/nz部分/n，/w新的/a对象/gi来/vf委派/v调用/gi已有/v对象/gi的/ude1方法/gi。/w       /x下面/f看/v一个/mq实例/gi来说/uls说/v一/nz下/f继承/gi和/cc合成/gi。/w    /x首先/d定义/gi了/ule一个/mq类/gia    /nz然后/c定义/gi了/ule一个/mq类/gib/nz，/w继承/gi类/giａ    /nz然后/c是/vshi客户端/gi代码/gi下面/f是/vshi一个/mq组合/gi的/ude1代码/gi  /x改写/v后/f的/ude1类/gib/nz改写/v的/ude1客户端/gi    /x通过/p上面/f的/ude1例子/gi我们/rr可以/v看到/v，/w使用/gi继承复/nz用/p会/v破坏/v系统/gi的/ude1封装/gi性/ng。/w因为/c继承/gi会/v将/d基类/nz的/ude1实现/gi暴漏/nz给/p子类/gm。/w如果/c基类/nz发生变化/l，/w那么/c子类/gm的/ude1实现/gi也/d不得不/d发生变化/l。/w从/p基类/nz继承/gi而来/c的/ude1实现/gi是/vshi静态/gi的/ude1。/w不/d可能/v在/p运行/gi时/qt发生/v改变/v，/w没有/v足够/v的/ude1灵活性/gi。/w所以/c继承/gi又叫/v“/w白箱/n复用/gi”/w    /x由于/p组合/gi或/c聚合/gi关系/gi可以/v将/d已有/v的/ude1对象/gi（/w也/d可/v称为/v成员/nnt对象/gi）/w纳入/v到/v新/a对象/gi中/f，/w使/v之/uzhi成为/v新/a对象/gi的/ude1一/nz部分/n，/w因此/c新/a对象/gi可以/v调用/gi已有/v对象/gi的/ude1功能/gi，/w这样/rzv做/v可以/v使得/vi成员/nnt对象/gi的/ude1内部/f实现/gi细节/gi对于/p新/a对象/gi不/d可见/c，/w所以/c这种/r复用/gi又/d称为/v“/w黑箱/gi”复/nz用/p。/w  /x组合/gi//nz聚合/gi复用/gi和/cc继承/gi复用/gi的/ude1比较/gi（/w一/nz）/w继承/gi优点/gi：/w  /x新的/a实现/gi较为/d容易/ad，/w因为/c基类/nz的/ude1大部分/n功能/gi可以/v通过/p继承/gi关系/gi自动/d进入/v派生类/n；/w /x修改/gi或/c扩展/gi继承/gi而来/c的/ude1实现/gi较为/d容易/ad。/w   /x缺点/gi：/w    /x继承/gi复用/gi破坏/v包装/n，/w因为/c继承/gi将/d基类/nz的/ude1实现/gi细节/gi暴露/v给/p派生类/n，/w这种/r复用/gi也/d称为/v白箱/n复用/gi；/w    /x如果/c基类/nz的/ude1实现/gi发生/v改变/v，/w那么/c派生类/n的/ude1实现/gi也/d不得不/d发生/v改变/v；/w    /x从/p基类/nz继承/gi而来/c的/ude1实现/gi是/vshi静态/gi的/ude1，/w不/d可能/v在/p运行/gi时/qt发生/v改变/v，/w不够/a灵活/a。/w（/w二/nz）/w合成/gi聚合/gi  /x优点/gi：/w    /x新/a对象/gi存取/gi成分/n对象/gi的/ude1唯一/b方法/gi是/vshi通过/p成分/n对象/gi的/ude1接口/gi；/w /x这种/r复用/gi是/vshi黑箱/gi复用/gi，/w因为/c成分/n对象/gi的/ude1内部/f细节/gi是/vshi新/a对象/gi所/usuo看不见/v的/ude1；/w /x这种/r复用/gi支持/v包装/n；/w /x这种/r复用/gi所需/nz的/ude1依赖/v较少/ad；/w /x每/rz一个/mq新的/a类/gi可以/v将/d焦点/n集中/v在/p一个/mq任务/gi上/f；/w /x这种/r复用/gi可以/v在/p运行/gi时/qt动态/gi进行/vn，/w新/a对象/gi可以/v使用/gi合成/gi//nz聚合/gi关系/gi将/d新的/a责任/n委派/v到/v合适/a的/ude1对象/gi。/w /x缺点/gi：/w /x通过/p这种/r方式/n复用/gi建造/v的/ude1系统/gi会/v有/vyou较多/d的/ude1对象/gi需要/v管理/gi。/w /x在/p复用/gi时/qt应/v优先/vd考虑/v使用/gi合成/gi聚合/gi而/cc不是/c继承/gi，/w而/cc判定/gi的/ude1判断/gi为/p以下/f四个/nzcoad/nz条件/n：/w /x①/nz /x派生类/n是/vshi基类/nz的/ude1一个/mq特殊/a种类/n，/w而/cc不是/c基类/nz的/ude1一个/mq角色/gi，/w即要/c分清/vhas/nz-/nza/nz和/ccis/nz-/nza/nz的/ude1区别/gi；/w /x②/nz /x永远/d不会/v出现/v需要/v将/d派生类/n换成/v另一个/nz类/gi的/ude1派生类/n的/ude1情况/n；/w /x③/nz /x派生类/n具有/v扩展/gi基类/nz的/ude1责任/n，/w而/cc不是/c具有/v置换/gi或者/c注销/vn掉/v基类/nz的/ude1责任/n；/w /x④/nz /x只有/c在/p分类学/n角度/n有/vyou意义/n时/qt，/w才/d可以/v使用/gi继承/gi。/w总结/gi：/w     /x我们/rr对于/p代码/gi的/ude1认识/v在/p不断/d的/ude1提高/v，/w以前/f只是/d说/v跑通/nz就/d可以/v了/ule，/w正/d所谓/v不谋/v全局/n者/k不足/an谋/v一域/nz。/w现在/t的/ude1我们/rr已经/d渐渐/d的/ude1开始/v从/p软件工程/gi的/ude1思想/gi去/vf看/v我们/rr的/ude1软件/gi。/w我们/rr知道/v了/ule软件/gi要/v有/vyou文档/gi和/cc程序/gi的/ude1。/w而/cc通过/p对/p设计模式/nz的/ude1学习/gi我们/rr还/d明白/v了/ule我们/rr写/v代码/gi是/vshi不能/v随心/nz来/vf写/v的/ude1。/w我们/rr还是/c要为/c以后/f打算/gi的/ude1，/w毕竟/d客户/n的/ude1需求/gi是/vshi不断/d在/p变化/gi的/ude1，/w而/cc全心全意/dl为人民服务/nz的/ude1宗旨/n也/d是/vshi我们/rr一直/d的/ude1宗旨/n。/w所以/c怎么样/ryv在/p全心全意/dl为人民服务/nz的/ude1前提/n下/f，/w让/v我们/rr的/ude1程序/gi在/p需求/gi变化/gi的/ude1时候/n能够/v更好/d的/ude1维护/gi，/w设计模式/nz就/d给/p我们/rr提供/v了/ule一个/mq很好/ad的/ude1范例/n。/w