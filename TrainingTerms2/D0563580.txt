#停止/gijava/gi基于/p线程/gi的/ude1服务/gi
停止/gi基于/p线程/gi的/ude1服务/gi对于/p持有/v线程/gi的/ude1服务/gi，/w只要/c服务/gi的/ude1存在/v时间/gi大于/v线程/gi的/ude1方法/gi的/ude1存在/v时间/gi，/w那么/c就/d应该/v提供/v生命周期/nz方法/gi。/w（/w1/nz）/w例子/gi：/w日志/gi服务/gi方式/n：/w通过/p调用/gilog/gi方法/gi将/d日志/gi消息/n放入/v某个/rz队列/gi中/f，/w并/cc由/p其他/rzv线程/gi来/vf处理/vn；/w停止/gi该/rz服务/gi的/ude1方式/n：/w通过/p原子/gi方式/n来/vf检查/gi关闭/gi请求/gi，/w并且/c有条件/nz地/ude2递增/vi一个/mq计数器/gi来/vf保存/gi提交/gi信息/gi的/ude1权利/n；/w（/w2/nz）/w关闭/giexecutorservice/nz复杂/a的/ude1程序/gi，/w通常/d会/v将/dexecutorservice/nz封装/gi在/p某个/rz更高/d级别/n的/ude1服务/gi中/f，/w并且/c该/rz服务/gi能/v提供/v其/rz自己/rr的/ude1生命周期/nz方法/gi。/w（/w3/nz）/w毒丸/nz对象/gi毒丸/nz是/vshi指/v一个/mq放在/v队列/gi上/f的/ude1对象/gi，/w其/rz含义/n是/vshi：/w当/p得到/v这个/rz对象/gi时/qt，/w立即/d停止/gi；/w限制/vn：/w只有/c在/p生产者/n和/cc消费者/n的/ude1数量/n都/d已知/nz的/ude1情况下/nz，/w才/d可以/v使用/gi“毒丸/nz”/w对象/gi；/w当/p生产者/n和/cc消费者/n数目/gi较大/d时/qt，/w这种/r方法/gi变得/vi难以使用/l。/w（/w4/nz）/w例子/gi：/w只/d执行/v一次/nz的/ude1服务/gi场景/gi：/w某个/rz方法/gi需要/v处理/vn一/nz批/q任务/gi，/w并且/c当/p所有/b任务/gi都/d处理/vn完/vi后/f才/d返回/v，/w可以/v通过/p一个/mq私有/gi的/ude1executor/nz来/vf简化/gi服务/gi的/ude1生命周期管理/gi，/w其中/rz该/rzexecutor/nz的/ude1生命周期/nz是/vshi由/p这个/rz方法/gi控制/vn的/ude1。/w（/w5/nz）/wshutdownnow/nz的/ude1局限性/n当/p通过/pshutdownnow/nz来/vf强行/d关闭/giexecutorservice/nz时/qt，/w尝试/v取消/v正在/d执行/v的/ude1任务/gi，/w并/cc返回/v所有/b已经/d提交/gi但/c未/d开始/v的/ude1任务/gi。/w但/c无法/v在/p关闭/gi过程/gi中/f知道/v正在/d执行/v的/ude1任务/gi的/ude1状态/gi。/w除非/c任务/gi本身/rz会/v执行/v某种/rz检查/gi。/w