#Activity/nz学习/gi小结/n
保存/giactivity/gi状态-/nzsaving activity state/nz在/p管理/giactivity/gi生命周期/nz中/f提到/v当/pactivity/gi暂停/v或者/c停止/gi的/ude1时候/n，/w会/v保留/vactivity/gi状态/gi，/w这/rzv是/vshi成立/vi的/ude1，/w因为/c当/p他/rr暂停/v或者/c停止/gi的/ude1时候/n，/w内存/gi中/f仍然/d有/vyou对象/gi，/w并且/c包含/v成员/nnt信息/gi和/cc当前/t的/ude1状态/gi，/w因此/c，/w在/p用户/gi模式/gi下/f的/ude1任何/rz对/pactivity/gi的/ude1操作/gi，/w在/pactivity/gi返回/v到/v前台/n的/ude1时候/n将/d被/pbei还原/gi(/nz恢复/gi状态/gi)/nz。/w然而/c，/w系统/gi为了/p回收/vn资源/gi而/cc销毁/v，/w这时/rzt系统/gi不能/v简单/a地/ude2恢复/gi到/v之前/f的/ude1完整/a状态/gi。/w相反/vi，/w如果/c用户/gi返回/v到/vactivity/gi,/nz系统/gi必须/d重新/d创建对象/n /x??/nz。/w此时/r,/nz用户/gi并不/d关系/gi系统/gi销毁/vactivity/gi，/w并/cc重新/d创建/gi它/rr。/w用户/gi此时/r更/d关系/giactivity/gi是否/v能/v恢复/gi到/v所/usuo期望/vn的/ude1状态/gi。/w在/p这种/r情况下/nz，/w要/v保证/v有关/vnactivity/gi状态/gi的/ude1重要/a信息/gi是/vshi通过/p实现/gi一个/mq叫做/v辅助/vn回调/gi函数/gi来/vf完成/v的/ude1,/nz它/rr允许/v你/rr保存/giactivity/gi的/ude1状态/gi信息/gi。/w在/pactivity/gi变得/vi不/d太/d稳定/an的/ude1前/f，/w系统/gi调用/gi。/w该/rz系统/gi传递/v给/p其/rz一个/mq，/w您/rr可以/v在/p其中/rz以/p名称-对/nz的/ude1形式/gi保存/gi为/p有关/vnactivity/gi的/ude1状态/gi信息/gi，/w如/v使用/gi方法/gi和/cc。/w然后/c，/w如果/c系统/gikill/nz你/rr的/ude1应用/gi进程/gi，/w当/p用户/gi返回/vactivity/gi，/w系统/gi重建/vactivity/gi时/qt，/w系统/gi会/v同时/c传给/v和/cc。/w使用/gi这/rzv两/nz种/q方法/gi，/w你/rr可以/v从/p提取/v到/v保存/gi的/ude1状态/gi信息/gi来/vf恢复/giactivity/gi。/w如果/c没有/v恢复/gi的/ude1状态/gi信息/gi，/w传递/v的/ude1是/vshi空/ng（/w首次/mq创建/giactivity/gi的/ude1情况/n）/w。/w图/gi2。/nz按照/p状态/gi的/ude1完整性/gi，/wactivity/gi有/vyou两/nz种/q方式/n返回/v到/v用户/gi的/ude1焦点/n：/w要么/cactivity/gi被/pbei销毁/v，/w然后/c重新/d创建/giactivity/gi,/nz必须/d要/v恢复/gi以前/f保存/gi的/ude1状态/gi。/w或/c停止/giactivity/gi，/w然后/c恢复/gi，/w这时/rztactivity/gi保持/v状态/gi的/ude1完整/a。/w注/v：/wactivity/gi被/pbei销毁/v之前/f不/d保证/v会/v调用/gi，/w因为/c有/vyou情况下/nz，/w它/rr不/d需要/v保存/gi状态/gi（/w例如/v，/w当/p用户/gi使用/gi“/w后/f退“/nz /x按钮/n离开/vactivity/gi的/ude1时候/n，/w因为/c用户/gi已/d明确/a关闭/gi的/ude1activity/gi）/w。/w如果/c是/vshi系统/gi调用/gi，/w那么/c他/rr会/v在/p前/f也/d可能/v在/p前/f调用/gi /x。/w然而/c，/w即使/c你/rr什么/ry也/d不/d做/v，/w也/d不/d实现/gi，/w某些/rzactivity/gi状态/gi恢复/gi会/v使用/gi类/gi的/ude1默认/v实现/gi /x。/w具体来说/nz，/w默认/v实现/gi对于/p布局/gi中的/v每个/r调用/gi相应/vi的/ude1方法/gi，/w它/rr允许/v每个/r视图/gi提供/v保存/gi自身/rr的/ude1相应/vi信息/gi。/w几乎/d在/pandroid/gi框架/gi每一个/nz部件/n都会/n适当/a的/ude1实现/gi此/rzs方法/gi，/w这样/rzv，/w当/p重新/d创建/giactivity/gi时候/n任何/rzui/gi的/ude1变化/gi将/d自动/d保存/gi和/cc恢复/gi /x。/w例如/v，/w控件/gi保存/gi由/p用户/gi输入/v和/cc任何/rz文字/gi，/w控件/gi保存/gi它/rr是否/v检查/gi。/w对于/p你/rr要/v保存/gi其/rz状态/gi每一个/nz部件/n，/w /x你/rr所/usuo需要/v做/v的/ude1唯一/b的/ude1工作/gi是/vshi提供/v一个/mq唯一/b的/ude1id/nz（/w使用/gi属性/gi）/w。/w一个/mq组件/gi，/w如果/c没有/v一个/mqid/nz，/w系统/gi无法/v保存/gi其/rz状态/gi。/w您/rr还/d可以/v显式/nz阻止/v布局/gi视图/gi保存/gi其/rz状态/gi，/w通过/p设置/gi属性/gi为/p“/wfalse/nz”/w或/c调用/gi方法/gi。/w通常/d情况下/nz，/w你/rr不/d应该/v禁/v他/rr，/w但/c如果/c您/rr想/v使/v你/rr的/ude1activity/gi恢复/gi状态/gi时有/d不同/aui/gi效果/gi就/d启用/gi它/rr。/w虽然/c默认/v实现/gi保存/gi有关/vnactivity ui/nz的/ude1有/vyou用/p信息/gi，/w你/rr仍/d可能/v需要/v重写/gi它/rr，/w以/p保存/gi更多/ad的/ude1信息/gi。/w例如/v，/w在/pactivity/gi中/f你/rr可能/v需要/v在/p成员/nnt变量/gi发生/v改变/v时/qt保存/gi他们/rr。/w /x（/w可能/v在/pui/gi恢复/gi时/qt需要/v关联/vn这些/rz，/w但/c默认/v情况下/nz，/w拥有/vui/gi的/ude1的/ude1成员/nnt都/d不会/v被/pbei还原/gi）/w。/w由于/p的/ude1默认/v实施/gi能/v保存/giui/gi的/ude1状态/gi，/w如果/c要为/c保存/gi额外/b的/ude1状态/gi信息/gi而/cc重写/gi此/rzs方法/gi，/w那么/c在/p做/v任何/rz工作/gi之前/f，/w你/rr一定/b要/v在/p实现/gi之前/f调用/gi其/rz超类/nz方法/gi。/w同样/d，/w如果/c你/rr重写/gi它/rr，/w你/rr也/d应该/v调用/gi实现/gi的/ude1超类/nz方法/gi，/w以此/d默认/v实现/gi恢复/gi视图/gi状态/gi。/w注/v：/w因为/c不能/v保证/v被/pbei调用/gi，/w所以/c当/p用户/gi离开/vactivity/gi，/w你/rr应该/v只/d使用/gi它/rr记录/giactivity/gi的/ude1瞬时/t状态/gi（/wui/gi的/ude1状态/gi）/w，/w你/rr不/d应该/v用/p它/rr来/vf??/nz存储/gi持久数据/n。/w相反/vi，/w你/rr应该/v使用/gi存储/gi持久数据/n（/w如/v保存/gi到/v数据库/gi中的/v数据/gi）/w。/w测试/gi您/rr的/ude1应用程序/nz恢复/gi其/rz状态/gi的/ude1能力/gi的/ude1一个/mq好/a方法/gi是/vshi简单/a地/ude2旋转/gi装置/n，/w使/v屏幕/gi的/ude1方向/gi变化/gi。/w当/p屏幕/gi方向/gi的/ude1变化/gi，/w系统/gi的/ude1销毁/v并/cc重新/d创建/giactivity/gi，/w对于/p新的/a屏幕/gi配置/gi替换/v资源/gi。/w因此/c，/w当/p被/pbei重建/v时/qt，/w您/rr的/ude1activity/gi完全恢复/i其/rz状态/gi时/qt就/d非常/d重要/a了/ule，/w因为/c用户/gi经常/d在/p使用/gi应用程序/nz时/qt旋转/gi屏幕/gi。/w生命周期/nz很好/ad的/ude1定义/gi了/ule回调/gi顺序/gi，/w特别是在/l同一/b进程/gi中/f两/nz个/qactivity/gi中/f，/w一个/mq启动/gi另外/c一个/mq的/ude1时候/n。/w如下/vi是/vshi当/pactivity a /nz启动/giacivity b/nz是/vshi产生/v的/ude1操作/gi顺序/gi：/w1./nzactivitya/nz执行/v（/w）/w方法/gi。/w2./nzactivityb /nz按照/p，/w，/w的/ude1顺序/gi执行/v方法/gi。/w（/wactivityb/nz现在/t取得/v用户/gi的/ude1焦点/n。/w）/w3./nz然后/c，/w如果/cactivitya /nz已/d不再/d是/vshi显示/gi在/p屏幕/gi上/f，/w它/rr执行/v方法/gi。/w这个/rz可/v预测/gi的/ude1生命周期/nz回调/gi顺序/gi，/w可让/v您/rr管理/gi的/ude1从/p一个/mqactivity/gi到/v另一个/nzactivity/gi的/ude1转换/gi信息/gi。/w例如/v，/w如果/c第一个/giactivity/gi停止/gi时/qt你/rr必须/d写/v数据库/gi /x,/nz /x让/v之后/f的/ude1activity /nz读取/gi数据库/gi，/w那么/c你/rr应该/v在/p期间/f写/v数据库/gi而/cc不是/c。/w