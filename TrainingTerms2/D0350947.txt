#网络层/gi―/w广播/gi路由/gi选择/gi算法/gi
不同于/c单播/gi（/w点对点/nz）/w通信/gi的/ude1路由/gi选择/gi协议/gi，/w广播/gi路由/gi选择/gi需要/v提供/v一种/nz从/p源结/nz点/gi到/v网络/gi中的/v所有/b其他/rzv结点/gm交付/v分组/gi的/ude1服务/gi。/w本文/r主要/b对/p广播/gi路由/gi选择/gi算法/gi进行/vn详细/gi说明/v：/w1/nz、/wn/nz次/qv单播/gi如果/c有/vyoun/nz个/q目的/gi结点/gm，/w那么/c在/p源结/nz点中/v就/d产生/vn/nz个/q分组/gi副本/n，/w然后/c将/d这/rzvn/nz份/q分组/gi传到/vn/nz个/q目的/gi结点/gm，/w这种/r方法/gi看上去/v十分/d简单/a，/w而且/c是/vshi可以/v利用/v单播/gi的/ude1协议/gi进行/vnn/nz次/qv传送/v。/w但是/c这/rzv方法/gi有/vyou很/d多/a致命/vi的/ude1缺点/gi，/w比如/v：/wn/nz次/qv单播/gi的/ude1第一段/nz路径/gi都/d相同/a，/w那么/c这段/r路径/gi就是/v被/pbei利用/v了/ulen/nz次/qv，/w第二个/nz路由器/gi也/d收到/v了/ulen/nz个/q重复/gi的/ude1分组/gi。/w那么/c，/w如果/c从/p第二个/nz路由器/gi开始/v发送/gi这/rzvn/nz个/q分组/gi会/v不会/v更好/d点/gi呢/y？/w所以/c这种/r方法/gi会/v使得/vi效率/gi变得/vi很低/d。/w2/nz、/w无/v控制/vn的/ude1洪泛/nr首先/d需要/v知道/v的/ude1是/vshi什么/ry是/vshi洪泛/nr（/wflooding/nz）/w，/w洪泛/nr是/vshi：/w每个/r结点/gm收到/v了/ule分组/gi之后/f向/p它/rr的/ude1所有/b邻居/n（/w除了/p发送给/n他/rr分组/gi的/ude1那个/rz邻居/n）/w发送/gi分组/gi。/w这个/rz方法/gi看起来/v是/vshi挺好/nz的/ude1，/w但是/c却/d存在/v这/rzv两/nz个/q问题/gi：/w第一个/gi问题/gi是/vshi如果/c这个/rz拓扑/n中/f有/vyou圆/v，/w那么/c在/p这个/rz圆/v中/f传播/gi的/ude1分组/gi将要/d无休止/nz地/ude2循环/gi下去/vf。/w第二个/nz问题/gi是/vshi路由器/gi将/d会/v收到/v很/d多/a重复/gi的/ude1分组/gi。/w3/nz、/w受控/v的/ude1洪泛/nr受控/v的/ude1洪泛/nr主要/b是/vshi通过/p两/nz种/q方法/gi进行/vn控制/vn的/ude1。/w第一种/nz方法/gi是/vshi序号/n控制/vn洪泛/nr（/wsequence /nz-/nz number /nz-/nz controlled flooding/nz）/w中/f，/w对/p需要/v洪泛/nr的/ude1分组/gi添加/gi一个/mq广播/gi序号/n，/w然后/c每个/r路由器/gi都/d维护/gi一个/mq序号/n列表/vi。/w当/p每个/r路由器/gi收到/v一个/mq分组/gi的/ude1时候/n，/w先/d检查/gi是否/v已经/d存在/v于/p序号/n列表/vi中/f，/w如果/c不在/v，/w则/d记录/gi该/rz序号/n，/w然后/c转发/gi分组/gi，/w如果/c在/p的话/udh，/w就/d直接/ad丢弃/v分组/gi并不/d转发/gi分组/gi。/w第二种/nz方法/gi是/vshi反向/gi路径/gi转发/gi（/wreverse path forwarding /nz，/wrpf/nz）/w（/w也/d可以/v称为/v反向/gi路径/gi广播/gi）/w。/w如果/c一台/nz路由器/gi接收/gi到/v一个/mq分组/gi的/ude1时候/n，/w需要/v做/v一件/nz事情/n，/w查看/gi一下/m分组/gi的/ude1源地址/n，/w检查/gi这个/rz分组/gi是否是/l从/p源结/nz点/gi到/v此/rzs结点/gm的/ude1最短路径/gi上/f。/w如果/c是/vshi的话/udh，/w就/d进行/vn继续/v转发/gi，/w如果/c不是/c，/w则/d直接/ad丢弃/v分组/gi。/w4/nz、/w生成/v树/gi广播/gi现在/t已经/d研制出/v了/ule很/d多/a种/q生成树/nz的/ude1算法/gi，/w这里/rzs我们/rr只/d研究/gi一种/nz简单/a的/ude1算法/gi，/w采用/v基于/p中心/gi的/ude1方法/gi（/wcenter /nz-/nz based approach/nz）/w建立/gi一/nz颗/q生成树/nz。/w首先/d需要/v定义/gi一个/mq中心/gi结点/gm，/w然后/c其他/rzv结点/gm都/d向/p中心/gi结点/gm单/b播“/nz加入/v树报/nz文”/nz，/w如果/c路径/gi还/d未/d在/p树/gi中/f，/w那么/c就/d直接/ad加入/v树/gi，/w如果/c路径/gi中的/v某些/rz部分/n已经/d在/p树/gi中/f，/w例如/v该/rz路径/gi是/vshib /nz-/nz a /nz-/nz f /nz-/nz c /nz-/nz g/nz，/w但是/cf/nz已经/d在/p树/gi中/f了/ule，/w那么/c就/d将/db /nz-/nz a/nz加入/v到/v树/gi中/f。/w通过/p /x这样/rzv的/ude1方法/gi创建/gi一/nz颗/q生成树/nz。/w