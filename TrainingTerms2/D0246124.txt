#设计/gi并/cc实现/gi一个/mqLRU Cache/nz
一/nz、/w什么/ry是/vshicache/gi1/nz /x概念/gicache/gi，/w即/v高速缓存/gi，/w是/vshi介于/vcpu/gi和/cc内存/gi之间/f的/ude1高速/b小/a容量/gi存储器/gi。/w在/p金字塔式/b存储体系/n中/f它/rr位于/v自/p顶向下/n的/ude1第二层/nz，/w仅次于/vcpu/gi寄存器/gi。/w其/rz容量/gi远/a小于/v内存/gi，/w但/c速度/n却/d可以/v接近/vcpu/gi的/ude1频率/n。/w当/pcpu/gi发出/v内存/gi访问/gi请求/gi时/qt，/w会/v先/d查看/gi cache /nz内/f是否/v有/vyou请求/gi数据/gi。/w如果/c存在/v（/w命中/v）/w，/w则/d直接/ad返回/v该/rz数据/gi；/w如果/c不存在/ns（/w失效/vi）/w，/w再/d去/vf访问/gi内存/gi /x―/w―/w /x先/d把/pba内存/gi中的/v相应/vi数据/gi载入/v缓存/gi，/w再/d将/d其/rz返回/v处理器/gi。/w提供/v“/w高速缓存/gi”/w的/ude1目的/gi是/vshi让/v数据/gi访问/gi的/ude1速度/n适应/vcpu/gi的/ude1处理速度/n，/w通过/p减少/v访问/gi内存/gi的/ude1次数/gi来/vf提高/v数据/gi存取/gi的/ude1速度/n。/w2/nz /x原理/gicache /nz技术/gi所/usuo依赖/v的/ude1原理/gi是/vshi”程序/nz执行/v与/cc数据/gi访问/gi的/ude1局部性原理/gi“/w，/w这种/r局部性/n表现/v在/p两/nz个/q方面/n：/w时间/gi局部性/n：/w如果/c程序/gi中的/v某/rz条/q指令/gi一旦/d执行/v，/w不久/d以后/f该/rz指令/gi可能/v再次/d执行/v，/w如果/c某/rz数据/gi被/pbei访问/gi过/uguo，/w不久/d以后/f该/rz数据/gi可能/v再次/d被/pbei访问/gi。/w空间/n局部性/n：/w一旦/d程序/gi访问/gi了/ule某个/rz存储单元/gm，/w在/p不久/d之后/f，/w其/rz附近/f的/ude1存储单元/gm也/d将/d被/pbei访问/gi，/w即/v程序/gi在/p一段时间/nz内/f所/usuo访问/gi的/ude1地址/gi，/w可能/v集中/v在/p一定/b的/ude1范围/n之内/f，/w这/rzv是因为/c指令/gi或/c数据/gi通常/d是/vshi顺序/gi存放/v的/ude1。/w时间/gi局部性/n是/vshi通过/p将/d近来/d使用/gi的/ude1指令和数据/gi保存/gi到/vcache/gi中/f实现/gi。/w空间/n局部性/n通常/d是/vshi使用/gi较大/d的/ude1高速缓存/gi，/w并/cc将/d /x预取/nz机制/gi /x集成/vn到/v高速缓存/gi控制/vn逻辑/n中/f来/vf实现/gi。/w3/nz /x替换策略/gicache/gi的/ude1容量/gi是/vshi有限/a的/ude1，/w当/pcache/gi的/ude1空间/n都/d被/pbei占满/v后/f，/w如果/c再次发生/i缓存/gi失效/vi，/w就/d必须/d选择/gi一个/mq缓存/gi块/q来/vf替换/v掉/v。/w常用/a的/ude1替换策略/gi有/vyou以下/f几/d种/q：/w随机算法/gi（/wrand/nz）/w：/w随机/b法/n是/vshi随机/b地/ude2确定/v替换/v的/ude1存储/gi块/q。/w设置/gi一个/mq随机/b数/n产生器/n，/w依据/n所/usuo产生/v的/ude1随机/b数/n，/w确定/v替换/v块/q。/w这种/r方法/gi简单/a、/w易于/vd实现/gi，/w但/c命中率/n比较/gi低/a。/w先进先出/gi算法/gi（/wfifo/gi,/nz first in first out/nz）/w：/w先进先出/gi法/n是/vshi选择/gi那个/rz最先/d调入/v的/ude1那个/rz块/q进行/vn替换/v。/w当/p最先/d调入/v并/cc被/pbei多/a次/qv命中/v的/ude1块/q，/w很可能/nz被/pbei优先/vd替换/v，/w因而/c不/d符合/v局部性/n规律/gi。/w这种/r方法/gi的/ude1命中率/n比/p随机/b法/n好/a些/q，/w但/c还/d不/d满足要求/nz。/w最久/a未/d使用/gi算法/gi（/wlru/gi,/nz least recently used/nz）/w：/wlru/gi法/n是/vshi依据/n各块/nz使用/gi的/ude1情况/n，/w /x总是/d选择/gi那个/rz最长/d时间/gi未/d被/pbei使用/gi的/ude1块/q替换/v。/w这种/r方法/gi比较/gi好/a地/ude2反映/v了/ule程序/gi局部性/n规律/gi。/w最/d不/d经常/d使用/gi算法/gi（/wlfu/nz,/nz least frequently used/nz）/w：/w将/d最近/t一段/nz时期/n内/f，/w访问/gi次数/gi最少/d的/ude1块/q替换/v出/vfcache/gi。/w4/nz /x概念/gi的/ude1扩充/v如今/t高速缓存/gi的/ude1概念/gi已/d被/pbei扩充/v，/w不仅/c在/pcpu/gi和/cc主/ag内存/gi之间/f有/vyoucache/gi，/w而且/c在/p内存/gi和/cc硬盘/gi之间/f也/d有/vyoucache/gi（/w磁盘缓存/gi）/w，/w乃至/c在/p硬盘/gi与/cc网络/gi之间/f也/d有/vyou某种意义/nz上/f的/ude1cache/gi─/nz─/nz称为/vinternet/nz临时/gi文件夹/n或/c网络/gi内容/gi缓存/gi等/udeng。/w凡是/d位于/v速度/n相差/v较大/d的/ude1两/nz种/q硬件/gi之间/f，/w用于/v协调/gi两者/rzv数据传输/gi速度差异/gi的/ude1结构/gi，/w均可/v称之为/vcache/gi。/w二/nz、/wlru cache/nz的/ude1实现/gigoogle/nz的/ude1一道/d面试题/n：/wdesign an lru cache with all the operations to be done in o/nz(/nz1/nz)/nzo/nz(/nz1/nz)/nz /x./nz1/nz /x思路/gi分析/gi对/p一个/mqcache/gi的/ude1操作/gi无非/d三种/nz：/w插入/gi(/nzinsert/gi)/nz、/w替换/v(/nzreplace/nz)/nz、/w查找/gi（/wlookup/nz）/w。/w为了/p能够/v快速/d删除/gi最久/a没有/v访问/gi的/ude1数据项/gi和/cc插入/gi最新/a的/ude1数据项/gi，/w我们/rr使用/gi /x双向/b链表/gi /x连接/gicache/gi中的/v数据项/gi，/w并且/c保证/v链表/gi维持/v数据项/gi从/p最近/t访问/gi到/v最旧/z访问/gi的/ude1顺序/gi。/w插入/gi：/w当/pcache/gi未满/nz时/qt，/w新的/a数据项/gi只需/v插到/nz双链表/gi头部/n即可/v。/w时间复杂度/gi为/po/nz(/nz1/nz)/nzo/nz(/nz1/nz)/nz./nz替换/v：/w当/pcache/gi已/d满/a时/qt，/w将/d新的/a数据项/gi插到/nz双链表/gi头部/n，/w并/cc删除/gi双链表/gi的/ude1尾结/nz点/gi即可/v。/w时间复杂度/gi为/po/nz(/nz1/nz)/nzo/nz(/nz1/nz)/nz./nz查找/gi：/w每次/r数据项/gi被/pbei查询/gi到/v时/qt，/w都/d将/d此/rzs数据项/gi移动/vn到/v链表/gi头部/n。/w经过/p分析/gi，/w我们/rr知道/v使用/gi双向/b链表/gi可以/v保证/v插入/gi和/cc替换/v的/ude1时间复杂度/gi是/vshio/nz(/nz1/nz)/nzo/nz(/nz1/nz)/nz，/w但/c查询/gi的/ude1时间复杂度/gi是/vshio/nz(/nzn/nz)/nzo/nz(/nzn/nz)/nz，/w因为/c需要/v对/p双链表/gi进行/vn遍历/gi。/w为了/p让/v查找/gi效率/gi也/d达到/vo/nz(/nz1/nz)/nzo/nz(/nz1/nz)/nz，/w很/d自然/n的/ude1会/v想到/v使用/gi hash table /nz。/w2/nz /x代码实现/gi从/p上述/b分析/gi可知/v，/w我们/rr需要/v使用/gi两/nz种/q数据结构/gi：/w双向/b链表/gi（/wdoubly linked list/nz）/w哈希表/nz（/whash table/nz）/w下面/f是/vshilru cache/nz的/ude1 c/nz+/nz+/nz /x实现/gi：/w个人/n站点/gi：/w