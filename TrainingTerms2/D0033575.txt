#Java/gi线程/gi之/uzhi线程/gi概述/gi
  /x不知/v从/p什么/ry时候/n开始/v，/w似乎/d到处/d都/d充斥/v着/uzhe高并发/gi的/ude1味道/n，/w或许/d是/vshi源于/v网络/gi购票/v曾经/d遇到/v过/uguo的/ude1种种/q困难/an，/w或许/d是/vshi由于/p各个/rz购物/vn网站/gi的/ude1各种/rz促销/vn，/w于是乎/c在/p各种/rz招聘启事/nz中都/ns明确要求/l有/vyou丰富/a的/ude1高并发/gi、/w可扩展性/gi等/udeng要求/n，/w那么/c多少/ry数量/n的/ude1并发/gi才/d可以/v称之为/v高并发/gi呢/y？/w该/rz如何/ryv评价/gi自己/rr是否/v具有/v高并发/gi服务器程序/n的/ude1技能/gi和/cc经验/gi呢/y？/w对/p这些/rz问题/gi，/w本人/rr不能/v给出/v明确/a的/ude1答案/gi，/w首先/d是因为/c没有/v开发/gi过/uguo高并发/gi的/ude1服务器程序/n（/w参与/gi过/uguo的/ude1大型项目/nz是/vshi基于/pssh/nz的/ude1web应用/gi）/w，/w其次/c在/p接触/v计算机/gi编程/gi的/ude1年代/n，/w到处/d都/d在/p鼓吹/vjava/gi面向对象/gi的/ude1各种/rz优点/gi，/w诸如/v不用/d操心/v内存/gi的/ude1分配/gi和/cc释放/gi，/w可移植性/gi（/w其实/d很/d多/a语言/gi都/d具有/v可移植性/gi）/w，/w不用/d重复/gi造/v轮子/n（/w工作/gi后/f才/d发现/v能够/v自己/rr制造/gi轮子/n是/vshi多么/d的/ude1幸福/a）/w，/wjava/gi多线程/gi非常容易/l实现/gi，/wjava/gi提供/v了/ule各种/rz数据结构/gi集合/gi等/udeng，/w于是/cc很/d多/a底层/n基础知识/nz都/d直接/ad跳过/v了/ule，/w等到/v发现/v如果/c想要/v更进一步/vl弄清楚/nz某些/rz问题/gi的/ude1根源/n时/qt，/w往往/d就/d会/v发现/v到处/d都/d是/vshi瓶颈/gi，/w甚至/d都/d不/d知道/v自己/rr需要/v百度/ntc什么/ry。/w于是/cc工作/gi后/f开始/v重新/d阅读/gi操作系统/gi、/w算法/gi等/udeng相关/vn书籍/gi，/w当/p再次/d学习/gi这些/rz基础/gi却/d非常/d重要/a的/ude1知识/gi时/qt，/w总会/nis得到/v不同/a的/ude1启示/vn，/w也许/d是因为/c上学时/n纯粹/b是/vshi为了/p应付/v考试/gi。/w  /x出自/v兴趣/gi和/cc工作/gi的/ude1需求/gi，/w接触/v到/v大数据/gi相关/vn领域/gi，/w也/d开始/v使用/gi开源/gi的/ude1大数据存储/gi、/w处理/vn和/cc分析/gi工具/gi，/w比如/vhadoop/gi、/whive/gi和/cchbase/gi，/w还/d接触/v到/v了/uleopenstack/nz云计算/gi框架/gi，/w其中/rz工作/gi用/p到/v的/ude1是/vshiswift/nz模块/gi。/w这些/rz软件/gi也好/y，/w框架/gi也罢/y，/w都/d在/p标榜/v自己/rr具有/v高/a并发性/nz、/w高可用性/n和/cc扩展性/n，/w于是/cc就/d在/p思考/gi它们/rr是/vshi如何/ryv实现/gi高并发/gi的/ude1呢/y？/w由于/p自己/rr好歹/d有点/djava/gi编程/gi知识/gi，/w自然而然/al的/ude1就/d想到/v了/ule多线程/gi，/w创建/gi了/ulejava/gi多线程/gi后/f就/d一定/b是/vshi高并发/gi了/ule吗/y？/w答案/gi显然/ad是/vshi不/d一致/a的/ude1。/w有的/rz情况/n使用/gi多线程/gi确实/ad可以/v得到/v更高/d的/ude1效率/gi，/w比如/v一个/mq件/q任务/gi可以/v被/pbei分为/v互不/d影响/gi的/ude1子/ng任务/gi，/w无论是/c在/p单/b处理器/gi还是/c多处理器/l上都/ns可以/v得到/v效率/gi的/ude1提升/gi，/w相反/vi如果/c一个/mq任务/gi是/vshi顺序/gi执行/v的/ude1，/w后面/f的/ude1代码/gi必须/d等到/v前面/f的/ude1代码执行/n完毕/vi才能/n继续执行/n，/w那么/c多线程/gi反而/d有可能/nz降低/v效率/gi。/w由此/d可以/v简单/a的/ude1得出结论/i多线程/gi的/ude1使用/gi要/v依赖于/v具体/a的/ude1场景/gi，/w这/rzv也/d是/vshi很/d多/a开源/gi软件/gi在/p介绍/gi某个/rz参数/gi时/qt非常/d喜欢/gi使用/gi的/ude1一句话/l，/w但/c对于/p我/rr来说/uls却/d非常/d不/d喜欢/gi这/rzv句话/q，/w因为/c这/rzv并/cc没有/v给/p我/rr明确/a唯一/b的/ude1答案/gi（/w中国/gi学生/gi总/b喜欢/gi明确/a唯一/b的/ude1答案/gi）/w。/w为了/p寻找/v最爱/a，/w只好/d再/d一次/nz拿起/v《/w操作系统/gi概念/gi》/w，/w并/cc准备好/nz了/ulehadoop/gi和/cchbase/gi的/ude1源代码/gi，/w方便/a随时/d参考/gi和/cc查阅/v具体/a实现/gi。/w1.1/nz线程/gi概念/gi  /x尽管/c多线程/gi编程/gi的/ude1概念/gi已经/d非常/d普及/v，/w还是/c有/vyou必要/a重申/v一/nz下线程/nz的/ude1概念/gi及其/cc与/cc进程/gi的/ude1关系/gi。/w线程/gi是/vshi运行/gi于/pcpu/gi中的/v基本/a单元/n，/w对于/p即使/c不/d支持/v多线程/gi的/ude1系统/gi来说/uls―/w―/w尽管/c这样/rzv的/ude1系统/gi少之又少/l，/w但/c确实/ad存在/v过/uguo―/w―/w这/rzv一/nz说法/n也/d是/vshi成立/vi的/ude1。/w或许/d有人/r要/v问/v运行/gi于/pcpu/gi中的/v基本/a单元/n不是/c进程/gi吗/y，/w那么/c就/d有/vyou必要/a澄清/vi一下/m进程/gi的/ude1概念/gi，/w尽管/c到处/d都/d在/p谈论/v进程/gi。/w广义/n上/f或者/c通俗/a地/ude2讲/v，/w进程/gi指/v的/ude1是/vshi运行/gi中的/v程序/gi，/w因此/c是/vshi活动/gi的/ude1实体/n，/w更/d具体/a地/ude2来说/uls，/w进程/gi包括/v程序代码/nz（/w文本/gi段/q或/c代码段/nz）/w，/w程序/gi计数器/gi的/ude1值/n和/cc寄存器/gi集合/gi中的/v内容/gi，/w数据/gi段/q，/w堆栈/n等/udeng。/w而/cc线程/gi是/vshi进程/gi代码/gi的/ude1执行/v流/gi，/w包括/v线程/giid/nz、/w程序/gi计数器/gi、/w寄存器/gi集合/gi和/cc线/n程栈/nz，/w与/cc属于/v同一/b进程/gi的/ude1其它/rz线程/gi（/w如果/c存在/v的话/udh）/w共享/gi代码段/nz、/w数据/gi段/q和/cc其它/rz操作系统/gi资源/gi，/w比如/v打开/gi文件/gi和/cc信号/gi等/udeng。/w由于/p线程/gi具有/v进程/gi的/ude1某些/rz属性/gi，/w如/v程序/gi计数器/gi、/w寄存器/gi等/udeng，/w因此/c也/d被/pbei称为/v轻量级/gi进程/gi，/w而/cc传统意义/n上/f的/ude1进程/gi则/d被/pbei称为/v重量级/b进程/gi，/w可以/v用/p下面/f的/ude1图/gi形象/n地/ude2描述/gi单线程/gi进程/gi和/cc多线程/gi进程/gi的/ude1差别/n：/w                                /x从/p图/gi中/f可以/v清晰/a地/ude2发现/v，/w在/p单线程/gi进程/gi中/f线程/gi就是/v进程/gi，/w在/p多线程/gi进程/gi中/f存在/v多/a个/q线程/gi，/w也/d就/d意味着/v可以/v同时/c做/v许多任务/nz（/w同时/c在/p单/b处理器/gi中/f并/cc不是/c真正/d意义/n上/f的/ude1在/p同一/b时刻/n，/w而是/c由于/p处理器/gi超/v快/a的/ude1处理速度/n给/p使用者/n一种/nz近乎/v真实/a同时/c的/ude1错觉/n，/w但/c在/p多处理器/l中/f却/d可以/v做到/v真正/d的/ude1同一/b时刻/n）/w。/w还/d可以/v确定/v的/ude1是/vshi线程/gi必/d属于/v某个/rz进程/gi且/c不能/v独立/a存在/v于/p进程/gi之外/f，/w而/cc进程/gi则/d至少/d拥有/v一个/mq线程/gi。/w  /x既然/c线程/gi仅/d是/vshi进程/gi中的/v执行/v序列/gi，/w而/cc多线程/gi进程/gi中/f可以/v同时/c存在/v多/a个/q执行/v序列/gi以/p完成/v多/a个/q任务/gi，/w那/rzv为什么/ryv不/d将/d多/a个/q线程/gi拆分/gi到/v多/a个/q进程/gi中/f来/vf完成/v多/a个/q任务/gi，/w或者说/c在/p某个/rz系统/gi中/f仅/d存在/v重量级/b进程/gi而/cc不存在/ns轻量级/gi进程/gi，/w反过来说/c，/w为什么/ryv不/d将/d所有/b的/ude1任务/gi都/d合并/gi到/v一/nz进程/gi中/f，/w即/v整个/b系统/gi只/d存在/v一个/mq进程/gi，/w该/rz进程/gi由/p众多/a的/ude1线程/gi组成/gi。/w答案/gi显然/ad是/vshi非常复杂/b的/ude1，/w简单/a地/ude2讲/v，/w之所以/c不/d将/d多/a个/q线程/gi创建/gi为/p多/a个/q进程/gi，/w是因为/c：/w1./nz属于/v同一/b进程/gi的/ude1所有/b线程/gi共享/gi共同/d的/ude1数据/gi，/w它们/rr之间/f的/ude1通信/gi不/d需要/v进程/gi间通信/n的/ude1额外/b开销/n。/w2./nz由于/p共享/gi相同/a的/ude1资源/gi，/w创建/gi线程/gi通常/d比/p创建/gi进程/gi更加/d快速/d（/w只/d需要/v创建/gi所/usuo使用/gi的/ude1线/n程栈/nz）/w，/w且/c线程/gi的/ude1上下文/gi切换/vn比/p进程/gi的/ude1上下文/gi切换/vn同样/d更加/d高效/b。/w3./nz对/p某些/rz服务/gi，/w比如/v打印机/n或者/cweb服务器/gi，/w多线程/gi往往/d比/p多/a进程/gi能够/v提供/v更加/d高效/b的/ude1响应速度/nz，/w因为/c同一/b进程/gi中的/v线/n程间/nz通信/gi往往/d比/p进程/gi间/f的/ude1通信/gi更加/d高效/b。/w  /x既然/c多线程/gi存在/v这么/rz多/a优点/gi，/w为什么/ryv不/d将/d所有/b的/ude1进程/gi合并/gi为/p一个/mq进程/gi，/w该/rz进程/gi中的/v线程/gi将/d完成/v之前/f所有/b进程/gi的/ude1工作/gi。/w显然/ad这样/rzv的/ude1设想/vn是/vshi不/d成立/vi的/ude1，/w因为/c操作系统/gi本身/rz就/d不仅仅/d是/vshi一个/mq单独/d的/ude1进程/gi，/w而是/c由/p若/c干/v完成/v不同/a任务/gi的/ude1进程/gi组成/gi，/w或者说/c由/p不同/a的/ude1模块/gi组成/gi。/w那/rzv退一步讲/nz，/w假设/gi操作系统/gi仅仅/d是/vshi由/p一个/mq进程/gi组成/gi，/w所有/b用户/gi的/ude1任务/gi由/p一个/mq进程/gi组成/gi，/w这/rzv势必会/n招致/v安全问题/gi，/w因为/c所有/b用户/gi的/ude1任务/gi共享/gi相同/a的/ude1内存空间/nz，/w彼此/rr可以/v访问/gi对方/n的/ude1数据/gi，/w而/cc如果/c想/v避免/v这些/rz问题/gi则/d会/v增加/v操作系统/gi在/p安全/gi方面/n的/ude1复杂性/gi。/w另外/c从/p软件工程/gi的/ude1角度/n讲/v，/w将/d不/d相干/vi的/ude1任务/gi合并/gi为/p一个/mq进程/gi违反/v了/ule松/ng耦合/vn的/ude1原则/gi，/w比如/v将/d打印机/n和/ccweb服务器/gi或者/c浏览器/gi放在/v一个/mq进程/gi中/f，/w这种/r强行/d粘合/vi的/ude1行为/n带来/v的/ude1危害性/n远远/d大于/v多线程/gi提供/v的/ude1诸/rz多/a优点/gi。/w1.2/nz上下文/gi切换/vn  /x在上文/v中几次/nz提到/v上下文/gi切换/vn这/rzv一/nz概念/gi，/w笼统/a地/ude2讲/v，/w上下文/gi切换/vn指/v的/ude1是/vshi将/dcpu/gi的/ude1使用权/n由/p一个/mq进程/gi或者/c线程/gi交由/v另一个/nz进程/gi或/c线程/gi，/w而/cc涉及/v的/ude1细节/gi往往/d与/cc特定/b操作系统/gi或硬件/n有/vyou密切/ad的/ude1关系/gi。/w进程/gi的/ude1上下文/gi切换/vn指/v的/ude1是/vshi不同/a进程/gi之间/f的/ude1轮流/vd获得/vcpu/gi的/ude1使用权/n，/w比如/v当一个/nz进程/gi等待/giio/gi的/ude1完成/v，/w则/d要/v交出/vcpu/gi的/ude1使用权/n，/w另一个/nz等待/gicpu/gi的/ude1进程/gi获得/v使用权/n进而/c可以/v执行/v。/w线程/gi的/ude1上下文/gi切换/vn指/v的/ude1是/vshi同一/b进程/gi中的/v线程/gi轮流/vd获得/vcpu/gi的/ude1使用权/n，/w不同/a进程/gi的/ude1线程/gi上下文/gi切换/vn即为/c进程/gi的/ude1上下文/gi切换/vn。/w在/p单/b处理器/gi的/ude1系统/gi中/f，/w无论是/c进程/gi内/f的/ude1线程/gi上下文/gi切换/vn还是/c进程/gi间/f的/ude1上下文/gi切换/vn都/d容易/ad理解/gi，/w因为/c仅有/nz单个/bcpu/gi，/w进程/gi内/f的/ude1线程/gi上下文/gi切换/vn仅/d需要/v保存/gi之前/f运行/gi的/ude1线程/gi的/ude1状态/gi，/w然后/c载入/v即将/d运行/gi线程/gi的/ude1状态/gi，/w而/cc进程/gi间/f的/ude1线程/gi上下文/gi切换/vn实际/n为/p进程上下文/gi切换/vn，/w不管/c这些/rz进程/gi是/vshi单线程/gi还是/c多线程/gi的/ude1。/w在/p多处理器/l的/ude1系统/gi中/f，/w进程/gi内/f的/ude1线程/gi上下文/gi切换/vn与/cc单/b处理器/gi的/ude1情况/n相同/a，/w但/c进程/gi间/f的/ude1线程/gi上下文/gi切换/vn是/vshi进程上下文/gi切换/vn还是/c等同于/vi进程/gi内/f的/ude1线程/gi上下文/gi切换/vn呢/y？/w如果/c要/v执行/v上下文/gi切换/vn的/ude1线程/gi属于/v单线程/gi进程/gi，/w那么/c显然/ad是/vshi进程上下文/gi切换/vn，/w如果/c是/vshi多线程/gi进程/gi呢/y？/w在/p此/rzs需要/v明确/a的/ude1一点时/nz，/w进程/gi内/f的/ude1线程/gi上下文/gi切换/vn不/d需要/v改变/v进程/gi的/ude1地址/gi空间/n，/w而/cc进程上下文/gi切换/vn则/d需要/v改变/v进程/gi的/ude1地址/gi空间/n，/w由于/p不同/a进程/gi的/ude1线程/gi拥有/v不同/a的/ude1地址/gi空间/n，/w进程/gi间/f的/ude1线程/gi上下文/gi也/d需要/v改变/v地址/gi空间/n，/w因此/c即使/c是/vshi多处理器/l系统/gi，/w进程/gi间/f的/ude1线程/gi上下文/gi切换/vn也/d是/vshi进程上下文/gi切换/vn。/w根据/p以上/f的/ude1论述/gi可以/v得出/v，/w在/p不/d明确指出/n进程/gi间/f线程/gi上下文/gi切换/vn的/ude1情况下/nz，/w线程/gi上下文/gi切换/vn即为/c进程/gi内/f的/ude1线程/gi上下文/gi切换/vn，/w因此/c只有/c这/rzv一种/nz情况/n线程/gi上下文/gi切换/vn比/p进程上下文/gi切换/vn高效/b，/w而/cc不论/c单/bcpu/gi还是/c多/acpu/gi系统/gi，/w进程/gi间/f的/ude1上下文/gi切换/vn都/d等/udeng价于/nz进程上下文/gi切换/vn。/w1.3/nz线程/gi类型/gi  /x根据/p线程/gi是否/v由/p操作系统/gi管理/gi和/cc调度/vn，/w可以/v将/d线程/gi分为/v两/nz类/gi：/w用户/gi线程/gi和/cc内核/gi线程/gi。/w顾名思义/vl，/w用户/gi线程/gi由/p用户/gi或者/c用户/gi创建/gi的/ude1应用程序/nz管理/gi，/w用户/gi应用程序/nz负责/v线程/gi的/ude1创建/gi、/w调度/vn、/w上下文/gi切换/vn、/w线程/gi间/f信息/gi的/ude1传递/v及/cc线程/gi的/ude1销毁/v，/w从/p操作系统/gi的/ude1角度看/v，/w用户/gi线程/gi的/ude1多线程/gi进程/gi仅/d是/vshi单线程/gi进程/gi。/w由于/p用户/gi应用程序/nz负责/v用户/gi线程/gi的/ude1各个方面/l，/w并不需要/l执行/v系统/gi调用/gi，/w因此/c用户/gi线程/gi的/ude1调度/vn、/w上下文/gi切换/vn等/udeng也/d更加/d快速/d高效/b，/w但/c由此/d导致/gi的/ude1缺点/gi也/d是/vshi非常/d明显/a的/ude1。/w首先/d，/w由于/p不是/c内核/gi负责/v用户/gi线程/gi的/ude1调度/vn，/w内核/gi只能/v调度/vn用户/gi应用程序/nz（/w单线程/gi进程/gi）/w，/w因此/c无法/v将/d多线程/gi调度/vn到/v多/a个/qcpu/gi中/f，/w因而/c无法/v利用/v多/acpu/gi的/ude1并行/vn优势/gi。/w其次/c，/w当/p某个/rz用户/gi线程/gi执行/v系统/gi调用/gi被/pbei阻塞/vn时/qt，/w即使/c存在/v可以/v执行/v的/ude1用户/gi线程/gi，/w这样/rzv的/ude1线程/gi也/d无法/v执行/v，/w因为/c内核/gi见到/v的/ude1单线程/gi进程/gi。/w最后/f，/w内核/gi分配/gi给/p用户/gi线程/gi进程/gi的/ude1时间/gi片/q需要/v由/p应用程序/nz分配/gi给/p用户/gi线程/gi，/w即/v所有/b的/ude1用户/gi线程/gi共享/gi该/rz时间/gi片/q。/w  /x内核/gi线程/gi则/d由/p操作系统/gi负责/v创建/gi、/w调度/vn、/w上下文/gi切换/vn和/cc销毁/v，/w由于/p操作系统/gi的/ude1参与/gi，/w内核线/nz程克服/nz了/ule用户/gi线程/gi的/ude1缺点/gi，/w即/v内核/gi线程/gi可以/v被/pbei分配/gi时间/gi片/q运行/gi，/w当/p同一/b进程/gi中的/v某个/rz内核/gi线程/gi阻塞/vn时/qt，/w其余/rz内核/gi线程/gi依然/d有/vyou机会/gi可以/v运行/gi（/w取决于/v操作系统/gi是否/v调度/vn其/rz运行/gi）/w，/w可以/v将/d多/a个/q内核/gi线程/gi分配/gi到/v多/a个/qcpu/gi上/f运行/gi以/p充分利用/n多/acpu/gi的/ude1优势/gi。/w凡事/n存在/v有利/a的/ude1一面/n就/d存在/v不利/a的/ude1一面/n，/w相对/d用户/gi线程/gi，/w内核/gi线程/gi的/ude1创建/gi和/cc管理/gi更加/d复杂/a和/cc低效/gi。/w用户/gi线程/gi是/vshi运行/gi在/p用户/gi空间/n的/ude1线程/gi，/w而/cc内核/gi线程/gi则/d是/vshi运行/gi在/p内核/gi空间/n的/ude1线程/gi，/w这/rzv就/d导致/gi了/ule用户/gi线程/gi和/cc内核/gi线程/gi之间/f存在/v某种/rz联系/gi，/w这种/r联系/gi建立/gi了/ule下文/n将要/d描述/gi的/ude1线程/gi模型/gi。/w1.4/nz线程/gi模型/gi /x线程/gi模型/gi定义/gi了/ule如何/ryv将/d用户线/n程映射/nz到/v内核/gi线程/gi，/w主要/b有/vyou多/a对/p一模型/nz、/w一对一/vl模型/gi和/cc多/a对/p多/a模型/gi。/w1.4.1/nz多/a对/p一模型/nz  /x多/a对/p一模型/nz是/vshi将/d多/a个/q用户线/n程映射/nz到/v一个/mq内核/gi线程/gi。/w线程/gi的/ude1管理/gi是/vshi在/p用户/gi空间/n进行/vn的/ude1，/w由于/p管理/gi不/d涉及/v系统/gi调用/gi，/w因此/c比较/gi高效/b。/w但是/c由于/p多/a个/q用户/gi线程/gi仅/d能/v映射/gi或/c关联/vn到/v一个/mq内核/gi线程/gi，/w当/p关联/vn内核/gi线程/gi的/ude1用户/gi线程/gi执行/v了/ule阻塞/vn系统/gi调用/gi时/qt，/w整个/b进程/gi都会/n被/pbei阻塞/vn，/w且/c由于/p仅有/nz一个/mq线程/gi可以/v被/pbei操作系统/gi调度/vn，/w多/a个/q用户/gi线程/gi无法/v运行/gi在/p多/a个/qcpu/gi上/f。/w早期/f版本/n的/ude1java/gi，/wsolaris green thread/nz采用/v多/a对/p一模型/nz实现/gi的/ude1。/w1.4.2/nz一对一/vl模型/gi  /x顾名思义/vl，/w在/p一对一/vl模型/gi中/f，/w每个/r用户/gi线程/gi都/d有/vyou一个/mq内核/gi线程/gi与/cc之/uzhi对应/vi，/w这样/rzv当/p某个/rz用户/gi线程/gi执行/v阻塞/vn系统/gi调用/gi，/w如/v等待/gi文件/gi读写/gi的/ude1完成/v，/w等待/gi网络/gi数据/gi的/ude1到达/v等/udeng，/w其它/rz用户/gi线程/gi不会/v因为/c阻塞/vn线程/gi而/cc失去/v执行/v的/ude1机会/gi，/w并且/c可以/v真正/d并行/vn运行/gi在/p多处理器/l上/f。/w由于/p任何事物/n都/d有/vyou两面性/n，/w一对一/vl模型/gi的/ude1缺点/gi是/vshi每/rz创建/gi一个/mq用户/gi线程/gi就要/d创建/gi一个/mq内核/gi线程/gi，/w而/cc这/rzv是/vshi比/p创建/gi用户/gi线程/gi低效/gi的/ude1，/w且/c由于/p不同/a系统/gi具有/v不同/a的/ude1配置/gi（/w内存/gi、/w硬盘/gi、/wcpu/gi数量/n及/cc速度/n）/w，/w创建/gi过多/d的/ude1用户/gi线程/gi会/v对系统/l造成/v不同/a的/ude1影响/gi，/w进而/c影响/gi应用程序/nz的/ude1性能/gi。/w众多/alinux/gi系统/gi和/ccwindows系统/gi都/d实现/gi了/ule一对一/vl模型/gi。/w1.4.3/nz多/a对/p多/a模型/gi  /x在/p多/a对/p一模型/nz中/f，/w尽管/c可以/v创建/gi任意/d多/a的/ude1用户/gi线程/gi（/w只要/c有/vyou足够/v的/ude1内存/gi）/w，/w但/c每次/r只/d能够/v调度/vn有一个/nz用户/gi线程/gi到/v内核/gi线程/gi，/w因此/c并/cc没有/v增加/v应用程序/nz的/ude1并发性/nz。/w而/cc一对一/vl模型/gi存在/v的/ude1缺点/gi是/vshi允许/v的/ude1内核/gi线程/gi数量/n存在/v上限/n，/w并且/c任意/d增加/v用户/gi线程/gi数量/n（/w也/d会/v创建/gi相应/vi的/ude1内核/gi线程/gi）/w会/v给/p系统/gi或者/c应用程序/nz带来/v性能/gi的/ude1影响/gi，/w因此/c在/p一定/b程度/n上/f需要/v限制/vn可以/v同时/c存在/v的/ude1用户/gi线程/gi数量/n。/w为了/p既/c可以/v创建/gi任意/d数量/n的/ude1用户/gi线程/gi，/w又/d能够/v以内/f核线程/nz的/ude1方式/n并发/gi运行/gi程序/gi，/w结合/v多/a对/p一/nz和/cc一对一/vl模型/gi，/w发展/gi了/ule多/a对/p多/a模型/gi。/w多/a对/p多/a模型/gi允许/v用户/gi线程/gi多路复用/nz到/v同等/b数量/n或者/c更少/d数量/n的/ude1内核/gi线程/gi上/f，/w因此/c既/c允许/v创建/gi任意/d多/a的/ude1用户/gi线程/gi，/w又/d可以/v使/v相应/vi内核/gi线程/gi并行/vn运行/gi在/p多处理器/l上/f，/w当/p一个/mq线程/gi阻塞/vn时/qt并/cc不会/v阻塞/vn其余/rz的/ude1线程/gi。/w尽管/c多/a对/p多/a模型/gi具有/v如此/rzv的/ude1优势/gi，/w但/c构建/gi和/cc同步/gi用户/gi线程/gi的/ude1调度器/nz到/v内核/gi的/ude1调度器/nz特别/d困难/an和/cc容易/ad出错/gi。/w在/plinux/gi内核/gi上/f进行/vn了/ule多/a对/p多/a和/cc一对一/vl模型/gi的/ude1比较/gi，/w结果显示/n一对一/vl模型/gi在/p性能/gi和/cc用户/gi使用/gi方面/n通常/d更具/v优势/gi，/w然而/c在/p特定/b领域/gi多/a对/p多/a模型/gi可能/v是/vshi正确/a的/ude1选择/gi。/w  /x在/psolaris /nz9/nz之前/f的/ude1版本/n，/wsolaris/nz支持/v多/a对/p多/a模型/gi，/w但/c从此/d之后/f的/ude1版本/n开始/v使用/gi一对一/vl模型/gi。/w1.5/nzjava/gi线程/gi  /x看过/v上面/f的/ude1介绍/gi，/w对于/p使用/gijava/gi的/ude1用户/gi可能/v要/v问/v的/ude1问题/gi是/vshi，/wjava/gi线程/gi是/vshi用户/gi线程/gi还是/c内核/gi线程/gi，/wjava/gi线程/gi使用/gi的/ude1哪种/ry线程/gi模型/gi。/w有/vyou过/uguojava/gi线程/gi编程/gi经验/gi的/ude1人/n都/d知道/v，/wjava/gi线程/gi是/vshi通过/p执行/vstart/nz方法/gi（/w而/cc不是/cnew/nz一个/mqthread/nz对象/gi）/w创建/gi的/ude1，/w即/v由/p应用程序/nz在/p用户/gi空间/n创建/gi的/ude1，/w因此/cjava/gi线程/gi显然/ad是/vshi用户/gi线程/gi。/w由于/pjava/gi程序运行/n在/pjvm/nz中/f，/wjvm/nz根据/p运行/gi的/ude1操作系统/gi又/d有/vyou不同/a的/ude1实现/gi，/w因此/c不同/a平台/gi上/f的/ude1jvm/nz实现/gi了/ule不同/a的/ude1多线程/gi模型/gi。/w比如/v在/pwindows/gi和/cclinux/gi中/f使用/gi的/ude1是/vshi一对一/vl模型/gi，/w而/cc在/p早期/f的/ude1solaris/nz中/f实现/gi的/ude1是/vshi多/a对/p一模型/nz，/w后来/t改为/v多/a对/p多/a模型/gi，/wsolaris /nz9/nz后/f又/d采用/v了/ule一对一/vl模型/gi。/w另外/c，/wjava/gi线程/gi与/cc宿主/n操作系统/gi的/ude1线/n程库/nz之间/f存在/v一定/b的/ude1联系/gi，/w比如/v在/pwindows/gi中/f使用/giwin/nz32/nz api/nz线/n程库/nz创建/gi线程/gi，/w而/cc在/plinux/gi中/f则/d使用/gipthread/nz创建/gi线程/gi。/w