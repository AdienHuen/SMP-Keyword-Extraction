#设计模式/nz /x业务封装/gi /x&/nz /x紧/d耦合/vn vs/nz./nz /x松/ng耦合/vn /x&/nz /x简单工厂模式/gi
业务封装/gi  /x紧/d耦合/vn vs/nz./nz /x松/ng耦合/vn  /x简单工厂模式/gi业务封装/gi  /x假如/c让/v你/rr设计/gi一个/mq控制台/gi版/n的/ude1计算器/gi，/w当/p你/rr写/v好/a后/f。/w现在/t让/v你/rr设计/gi一个/mq有/vyou界面/gi的/ude1计算器/gi，/w你/rr之前/f所写/v的/ude1代码/gi能/v直接/ad复用/gi吗/y？/w当/p我们/rr写/v控制台/gi版/n的/ude1计算器/gi时/qt就/d应该/v想到/v将/d业务逻辑/gi与/cc界面/gi逻辑/n分开/vi，/w让/v它们/rr的/ude1耦合度/gp降低/v，/w只有/c分离/vi开/v才/d容易/ad达到/v维护/gi或/c扩展/gi。/w紧耦/nz合/v vs/nz./nz /x松/ng耦合/vn  /x如果/c要/v在/p计算器/gi的/ude1业务逻辑/gi加上/v其他/rzv操作/gi符运算/nz，/w能否/v不/d影响/gi原来/d的/ude1业务逻辑/gi？/w这时/rzt可以/v用/p继承/gi、/w多态/gi的/ude1面向对象/gi思想/gi方法/gi把/pba各种/rz操作/gi符/v分开/vi不同/a的/ude1类/gi，/w如果/c要/v改动/vn或/c增加/v删除/gi某/rz一个/mq操作符/n，/w都/d不会/v影响/gi其他/rzv操作符/n，/w这/rzv就/d进一步/d降低/v了/ule耦合度/gp。/w简单工厂模式/gi  /x比如/v我们/rr设计/gi好/a不同/a操作/gi类/gi，/w如果/c让/v用户/gi来/vf创建/gi这些/rz操作/gi类/gi呢/y？/w这时/rzt我们/rr可以/v创建/gi一个/mq简单工厂/gi类/gi。/w工厂/gi类/gi是/vshi整个/b模式/gi的/ude1关键/n。/w客户/n只/d知道/v传入/gi工厂/gi类/gi的/ude1参数/gi，/w对于/p如何/ryv创建对象/n（/w逻辑/n）/w不/d关心/v。/w包含/v了/ule必要/a的/ude1逻辑/n判断/gi，/w根据/p外界/n给定/gi的/ude1信息/gi，/w决定/v究竟/d应该/v创建/gi哪个/ry具体/a类/gi的/ude1对象/gi。/w通过/p使用/gi工厂/gi类/gi，/w外界/n可以/v从/p直接/ad创建/gi具体/a产品/gi对象/gi的/ude1尴尬/a局面/n摆脱/v出来/vf,/nz仅仅/d需要/v负责/v“/w消费/vn”/w对象/gi就/d可以/v了/ule。/w而/cc不必/d管/v这些/rz对象/gi究竟/d如何/ryv创建/gi及/cc如何/ryv组织/gi的/ude1。/w明确/a了/ule各自/rr的/ude1职责/gi和/cc权利/n，/w有利于/v整个/b软件体系结构/gi的/ude1优化/gi。/w