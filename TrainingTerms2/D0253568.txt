#DTW/nz算法/gi
  /x　　/nzdtw/nz为/p(/nzdynamic time warping/nz,/nz动态/gi时间/gi归准/nz)/nz的/ude1简称/v。/w应用/gi很广/d，/w主要/b是/vshi在/p模板匹配/gi中/f，/w比如说/vl用/p在/p孤立词/nz语音识别/gi，/w计算机视觉/gi中的/v行为/n识别/gi，/w信息/gi检索/gi等/udeng中/f。/w可能/v大家/rr学/v过/uguo这些/rz类/gi的/ude1课程/gi都/d看到/v过/uguo这个/rz算法/gi，/w公式/gi也/d有/vyou几/d个/q，/w但是/c很/d抽象/gi，/w当时/t看懂/nz了/ule但/c不久/d就/d会/v忘记/v，/w因为/c没有/v具体/a的/ude1实例/gi来/vf加深/v印象/n。/w   /x这次/r主要/b是/vshi用/p语音识别/gi课程/gi老师上课/n的/ude1一个/mq题目/gi来/vf理解/gidtw算法/gi。/w　　/nz首先/d还是/c介绍/gi下/fdtw/nz的/ude1思想/gi：/w假设/gi现在/t有/vyou一个/mq标准/gi的/ude1参考/gi模板/gir/nz，/w是/vshi一个/mqm/nz维/b的/ude1向量/gi，/w即/vr/nz=/nz{/nzr/nz（/w1/nz）/w，/wr/nz（/w2/nz）/w，/w…/w…/w，/wr/nz（/wm/nz）/w，/w…/w…/w，/wr/nz（/wm/nz）/w}/nz，/w每个/r分量/n可以/v是/vshi一个/mq数/n或者/c是/vshi一个/mq更/d小/a的/ude1向量/gi。/w现在/t有/vyou一个/mq才/d测试/gi的/ude1模板/git/nz，/w是/vshi一个/mqn/nz维向量/nz，/w即/vt/nz=/nz{/nzt/nz（/w1/nz）/w，/wt/nz（/w2/nz）/w，/w…/w…/w，/wt/nz（/wn/nz）/w，/w…/w…/w，/wt/nz（/wn/nz）/w}/nz同样/d每个/r分量/n可以/v是/vshi一个/mq数/n或者/c是/vshi一个/mq更/d小/a的/ude1向量/gi，/w注意/vm/nz不一定/nz等于/vn/nz，/w但是/c每个/r分量/n的/ude1维数/nz应该/v相同/a。/w /x由于/pm/nz不一定/nz等于/vn/nz，/w现在/t要/v计算/gir/nz和/cct/nz的/ude1相度/nz，/w就/d不能/v用/p以前/f的/ude1欧式/b距离/gi等/udeng类/gi的/ude1度量/v方法/gi了/ule。/w那/rzv用/p什么/ry方法/gi呢/y？/wdtw/nz就是/v为了/p解决/v这个/rz问题/gi而/cc产生/v的/ude1。/w首先/d我们/rr应该/v知道/vr/nz中的/v一个/mq分量/nr/nz（/wm/nz）/w和/cct/nz中的/v一个/mq分量/nt/nz（/wn/nz）/w的/ude1维数/nz是/vshi相同/a的/ude1，/w它们/rr之间/f可以/v计算/gi相度/nz（/w即/v距离/gi）/w。/w在/p运用/vdtw/nz前/f，/w我们/rr要/v首先/d计算/gir/nz的/ude1每一个/nz分量/n和/cct/nz中的/v每一个/nz分量/n之间/f的/ude1距离/gi，/w形成/v一个/mqm/nz*/nzn/nz的/ude1矩阵/gi。/w（/w为了/p方便/a，/w行数/n用/p将/d标准/gi模板/gi的/ude1维/b数/nm/nz，/w列数/nz为/p待测/nz模板/gi的/ude1维/b数/nn/nz）/w。/w然后/c下面/f的/ude1步骤/gi该/rz怎么/ryv计算/gi呢/y？/w用/p个/q例子/gi来/vf看看/v。/w这个/rz例子/gi中/f假设/gi标准/gi模板/gir/nz为/p字母/giabcdef/nz(/nz6/nz个/q)/nz，/w测试/gi模板/git/nz为/p1234/nz(/nz4/nz个/q)/nz。/wr/nz和/cct/nz中/f各/rz元素/gi之间/f的/ude1距离/gi已经/d给出/v。/w如下/vi：/w /x既然/c是/vshi模板匹配/gi，/w所以/c各/rz分量/n的/ude1先后/d匹配/gi顺序/gi已经/d确定/v了/ule，/w虽然/c不是/c一一对应/gm的/ude1。/w现在/t题目/gi的/ude1目的/gi是/vshi要/v计算/gi出/vf测试/gi模板/git/nz和/cc标准/gi模板/gir/nz之间/f的/ude1距离/gi。/w因为/c2/nz个/q模板/gi的/ude1长度/gi不同/a，/w所以/c其/rz对应/vi匹配/gi的/ude1关系/gi有/vyou很/d多/a种/q，/w我们/rr需要/v找出/v其中/rz距离/gi最/d短/a的/ude1那/rzv条/q匹配/gi路径/gi。/w现/tg假设/gi题目/gi满足/v如下/vi的/ude1约束/gi：/w当/p从/p一个/mq方/q(/nz(/nzi/nz-/nz1/nz,/nzj/nz-/nz1/nz)/nz或者/c(/nzi/nz-/nz1/nz,/nzj/nz)/nz或者/c(/nzi/nz,/nzj/nz-/nz1/nz)/nz)/nz中/f到/v下一个/nz方/q(/nzi/nz,/nzj/nz)/nz，/w如果/c是/vshi横着/nz或者/c竖着/nz的话/udh其/rz距离/gi为/pd/nz(/nzi/nz,/nzj/nz)/nz，/w如果/c是/vshi斜着/v对/p角线/nz过来/vf的/ude1则/d是/vshi2/nzd/nz(/nzi/nz,/nzj/nz)/nz./nz其/rz约束条件/gi如下/vi图像/gi所示/nz：/w /x其中/rzg/nz(/nzi/nz,/nzj/nz)/nz表示/v2/nz个/q模板/gi都/d从/p起始/gi分量/n逐/v次/qv匹配/gi，/w已经/d到/v了/ulem/nz中的/vi/nz分量/n和/cct/nz中的/vj/nz分量/n，/w并且/c匹配/gi到/v此/rzs步/qv是/vshi2/nz个/q模板/gi之间/f的/ude1距离/gi。/w并且/c都/d是/vshi在/p前/f一次/nz匹配/gi的/ude1结果/n上/f加/vd/nz(/nzi/nz,/nzj/nz)/nz或者/c2/nzd/nz(/nzi/nz,/nzj/nz)/nz,/nz然后/c取/v最小/a。/w /x所以/c我们/rr将/d所有/b的/ude1匹配/gi步骤/gi标注/v后/f如下/vi：/w /x怎么/ryv得来/v的/ude1呢/y？/w比如说/vlg/nz(/nz1/nz,/nz1/nz)/nz=/nz4/nz,/nz /x当然/d前提/n都/d假设/gi是/vshig/nz(/nz0/nz,/nz0/nz)/nz=/nz0/nz,/nz就是说/cg/nz(/nz1/nz,/nz1/nz)/nz=/nzg/nz(/nz0/nz,/nz0/nz)/nz2/nzd/nz(/nz1/nz,/nz1/nz)/nz=/nz02/nz*/nz2/nz=/nz4./nz g/nz(/nz2/nz,/nz2/nz)/nz=/nz9/nz是/vshi一样/uyy的/ude1道理/n。/w首先/d如果/c从/pg/nz(/nz1/nz,/nz2/nz)/nz来/vf算/v的话/udh是/vshig/nz(/nz2/nz,/nz2/nz)/nz=/nzg/nz(/nz1/nz,/nz2/nz)/nzd/nz(/nz2/nz,/nz2/nz)/nz=/nz54/nz=/nz9/nz,/nz因为/c是/vshi竖着/nz上去/vf的/ude1。/w /x如果/c从/pg/nz(/nz2/nz,/nz1/nz)/nz来/vf算/v的话/udh是/vshig/nz(/nz2/nz,/nz2/nz)/nz=/nzg/nz(/nz2/nz,/nz1/nz)/nzd/nz(/nz2/nz,/nz2/nz)/nz=/nz74/nz=/nz11/nz,/nz因为/c是/vshi横着/nz往右/nz走/v的/ude1。/w /x如果/c从/pg/nz(/nz1/nz,/nz1/nz)/nz来/vf算/v的话/udh，/wg/nz(/nz2/nz,/nz2/nz)/nz=/nzg/nz(/nz1/nz,/nz1/nz)/nz2/nz*/nzd/nz(/nz2/nz,/nz2/nz)/nz=/nz42/nz*/nz4/nz=/nz12./nz因为/c是/vshi斜着/v过去/vf的/ude1。/w /x综上所述/c，/w取/v最小/a为/p9./nz /x所有/bg/nz(/nz2/nz,/nz2/nz)/nz=/nz9./nz /x当然/d在/p这/rzv之前/f要/v计算/gi出/vfg/nz(/nz1/nz,/nz1/nz)/nz,/nzg/nz(/nz2/nz,/nz1/nz)/nz,/nzg/nz(/nz1/nz,/nz2/nz)/nz./nz因此/c计算/gig/nz(/nzi/nz,/nzj/nz)/nz也/d是/vshi有/vyou一定/b顺序/gi的/ude1。/w其/rz基本/a顺序/gi可以/v体现/v在/p如下/vi：/w /x计算/gi了/ule第一/mq排/v，/w其中/rz每一个/nz红色/gi的/ude1箭头/n表示/v最小/a来源/gi的/ude1那个/rz方向/gi。/w当/p计算/gi了/ule第二排/nz后/f的/ude1结果/n如下/vi：/w /x最后/f都/d算/v完了/vi的/ude1结果/n如下/vi：/w /x到此为止/vl，/w我们/rr已经/d得到/v了/ule答案/gi，/w即/v2/nz个/q模板/gi直接/ad的/ude1距离/gi为/p26./nz /x我们/rr还/d可以/v通过/p回溯/gi找到/v最短距离/gi的/ude1路径/gi，/w通过/p箭头/n方向/gi反推/nz回去/v。/w如下/vi所示/nz：/w /x到/v这里/rzs，/w估计/gi大家/rr动手/gi算一下/nz就/d会/v明白/v了/ule。/w其实/d很/d简单/a，/w通过/p例子/gi的/ude1学习/gi后/f再/d回去/v看/v那些/rz枯燥/a的/ude1理论/gi公式/gi就/d发现/v很容易/nz了/ule。/w /x在/p实际/n应用/gi中/f，/w比如说/vl语音识别/gi中的/v孤立/a词/n识别/gi，/w我们/rr首先/d训练/gi好/a常见字/l的/ude1读音/n，/w提取/v特征/gi后/f作为/p一个/mq模板/gi。/w当/p需要/v识别/gi一个/mq新/a来/vf的/ude1词/n的/ude1时候/n，/w也/d同样/d提取/v特征/gi，/w然后/c和/cc训练/gi数据库/gi中的/v每一个/nz模板/gi进行/vn匹配/gi，/w计算/gi距离/gi。/w求出/v最短距离/gi的/ude1那个/rz就是/v识别/gi出来/vf的/ude1字/n了/ule。/w