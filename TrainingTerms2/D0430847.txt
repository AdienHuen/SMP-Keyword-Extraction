#与/cc状态模式/gi相似/a的/ude1设计/gi模式---职/nz责链/nz模式/gi
     /x今天/t我们/rr要/v讨论/gi的/ude1设计模式/nz与/cc前面/f提到/v的/ude1状态模式/gi非常/d相/d，/w他们/rr不能/v的/ude1地方/n：/w状态模式/gi是/vshi每个/r具体/a的/ude1状态/gi处理/vn自己/rr状态/gi的/ude1事务/gi，/w若非/c自己/rr状态/gi处理/vn的/ude1数据/gi则/d将/d状态/gi移动/vn到/v一下一个/nz具体/a状态/gi类/gi处理/vn；/w而/cc职责链/gi则/d是/vshi根据/p自己/rr的/ude1职责/gi完成/v本职工作/n，/w若/c不能/v完成/v则/d判断/gi是否/v已经/d关联/vn了/ule下一个/nz环节/gi职责/gi，/w若/c存在/v则/d调用/gi下/f一/nz环节/gi的/ude1处理/vn。/w他们/rr两/nz个/q一个/mq是/vshi在/p具体/a类/gi中/f已经/d设定/v了/ule下/f一/nz环节/gi，/w而/cc另外/c一个/mq则/d是/vshi在/p客户端/gi先/d设定/v好/a职责链/gi。/w   /x什么/ry是/vshi职责链模式/gi？/w使/v多/a个/q对象/gi（/w职责/gi对象/gi）/w都/d有/vyou机会/gi处理/vn请求/gi，/w从而/c避免/v了/ule请求/gi发送者/n与/cc接收者/gi之间/f的/ude1耦合性/nz。/w将/d这/rzv职责/gi对象/gi连成/v一条链/nz，/w使得/vi传入/gi的/ude1参数/gi（/w指/v发送者/n的/ude1数据/gi）/w并/cc沿着/p链/ng传递/v请求/gi，/w直到/v有/vyou一个/mq对象/gi处理/vn它/rr为止/u。/w咱们/rr在/p使用/gi这种/r模式/gi的/ude1时候/n一定/b要/v充分考虑/n好/a，/w否则/c会/v出现/v发出/v去/vf的/ude1请求/gi而/cc没有/v一个/mq职责/gi对象/gi处理/vn。/w抽象类/gi（/whandler/gi）/w定义/gi了/ule如何/ryv设定/v职责链/gi下/f一/nz环节/gi对象/gi，/w抽象/gi处理方法/gi：/wabstract class handler/nz{/nzprotected handler handler/nz;/nz  /x//nz//nz此/rzs方法/gi的/ude1目的/gi是/vshi设定/v后续/vn的/ude1职责/gi对象/gipublic void setsuccessor/nz(/nzhandler handler/nz)/nz{/nzthis/nz./nzhandler/gi=/nzhandler/gi;/nz}/nz//nz//nz处理/vn请求/gi的/ude1抽象/gi方法/gi：/w后续/vn继承/gi类/gi中/f具体/a实现/gi处理/vn，/w如/v处理/vn不了/v则/d转到/v后续/vn职责/gihandler/gi对象/gi处理/vnpublic abstract void handlerrequest/nz(/nzint request/nz)/nz;/nz}/nz具体/a的/ude1职责类/gi就/d简单/a了/ule，/w只需/v重写/gi自己/rr的/ude1处理方式/n，/w如果/c处理/vn不了/v则/d转到/v下一个/nz职责链/gi对象/gi处理/vn（/w已经/d设定/v的/ude1handler/gi对象/gi）/w：/w客户端/gi代码/gi，/w首先/d我们/rr需要/v创建/gi个/q职责链/gi对象/gi，/w并/cc把/pba所有/b的/ude1职责链/gi对象/gi串/q起来/vf；/w每个/r处理/vn请求/gi的/ude1时候/n都/d从/p第一个/gi职责/gi对象/gi开始/v就/dok/nz了/ule：/w  /x这个/rz设计模式/nz的/ude1好处/gi：/w减少/v我们/rr各/rz职责/gi之间/f的/ude1耦合性/nz，/w仅/d需/v设定/v处理/vn不了/v时/qt下/f一/nz职责/gi对象/gi就/d好/a了/ule。/w如果/c我们/rr还/d需要/v进行/vn添加/gi职责/gi，/w只需/v在/p重新/d继承/gi基类/nz重写/gi一个/mq具体/a职责类/gi；/w易/ad操作/gi、/w不/d修改/gi原来/d已/d写/v好/a的/ude1代码/gi，/w实现/gi了/ule开放--闭合/nz的/ude1设计原则/gi。/w