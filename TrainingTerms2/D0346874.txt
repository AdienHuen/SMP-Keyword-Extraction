#算法三/nz：/w树/gi和/cc堆排序/gi
1/nz、/w树/gi（/w不/d包含/v回路/n的/ude1，/w即/vn/nz个/q结点/gm恰好/d有/vyoun/nz-/nz1/nz条/q边/k）/w任意/d两/nz个/q结点/gm有/vyou且/c仅有/nz唯一/b的/ude1一条路径/nz连通/gi。/w根/n//nz祖先/n//nz根/n节点/gi(/nz没有/v父亲/n)/nz节点/gi//nz结点/gm夫/ng节点/gi//nz父亲/n子/ng节点/gi//nz儿子/n叶结点/nz（/w没有/v儿子/n）/w深度/gi：/w根/n到/v这个/rz结点/gm的/ude1层数/n。/w2/nz、/w二叉树/gi：/w每个/r结点/gm最多/ad有/vyou两/nz个/q儿子/n（/w左/f儿子/n，/w右/f儿子/n）/w满/a二叉树/gi:/w每个/r结点/gm都/d有/vyou两/nz个/q儿子/n//nz所有/b的/ude1叶/ng结点/gm都/d有/vyou相同/a的/ude1深度/gi。/w深度/gi为/ph/nz且/c有/vyou2/nz^/nzh/nz-/nz1/nz个/q结点/gm的/ude1二叉树/gi。/w完全/ad二叉树/gi：/w满/a二叉树/gi最/d右边/f位置/gi上/f拿掉/nz一个/mq或者/c几/d个/q叶结点/nz深度/gi为/ph/nz，/w除/ph/nz层/gi外/f，/w其他/rzv各/rz层/gi（/w1/nz /x-/nz h/nz-/nz1/nz)/nz的/ude1结点/gm数/n都/d达到/v最大/gm个数/n。/w完全/ad二叉树/gi存储/gi：/w一维/n数组/gi，/w从/p左/f到/v右一层一层/nz放/v。/w有/vyoun/nz个/q结点/gm，/w那么/c这个/rz完全/ad二叉树/gi的/ude1高度/d为/plog/gi2/nz n/nz。/w最/d典型/n的/ude1应用/gi就是/v堆/gi。/w3/nz、/w最小/a堆/gi：/w所有/b父结/nz点/gi都/d比子/nz结点/gm要/v小/a随便/adn/nz元素/gi的/ude1数/n，/w按照/p完全/ad二叉树/gi方式/n放入/v一个/mq数组/gi，/w生成/v最小/a堆/gi：/w1/nz、/w从/p最后/f一个/mq非叶/nz结点/gm（/w结点/gm数组/gi编号/gi为/pn/nz//nz2/nz)/nz开始/v，/w对/p该/rz结点/gm和/cc下面/f的/ude1左右/f叶结点/nz进行/vn比较/gi，/w使/v最小/a的/ude1数/n放在/v非/b叶结/nz点/gi上/f。/w2/nz、/w扫描/gi完/vi这/rzv层/gi后/f，/w开始/v扫描/gi上/f一层/nz，/w该/rz结点/gm如果/c要/v移位/gi，/w就/d需要/v对/p下面/f及/cc下面/f的/ude1叶/ng结点/gm进行/vn比较/gi，/w使/v其/rz符合/v最小堆/nz要求/n，/w不/d移位/gi不/d比较/gi。/w3/nz、/w重复/gi，/w直到/v扫描/gi到/v根/n节点/gi（/w结点/gm编号/gi为/p1/nz）/w为止/u。/w时间复杂度/gio/nz(/nzn/nz)/nz5/nz、/w堆排序/gi时间复杂度/gi和/cc快速排序/gi一样/uyyo/nz(/nznlogn/gi)/nz。/w以/p从小到大/nz排序/gi为/p例/n。/w1/nz、/w生成/v最大/gm堆/gi /x2/nz、/w把/pba数组/gi中/f最后/fh/nz[/nzn/nz]/nz的/ude1数/n和/cch/nz[/nz1/nz]/nz的/ude1数/n进行/vn交换/gi，/wn/nz--/nz3/nz、/w补上来/v的/ude1数/nh/nz[/nz1/nz]/nz和/cc子/ng节点/gi一层一层/nz对比/gi，/w把/pba小/a的/ude1数/n往/p上移/v，/w直到/v不能/v移动/vn时/qt，/w再/d跳到/vf2/nz反复/d。/wcreate/gi(/nz)/nz;/nzwhile/nz(/nzn/nz1/nz)/nz{/nz  swap/nz(/nz1/nz,/nzn/nz)/nz;/nz  n/nz--;/nz  siftdown/nz(/nz1/nz)/nz;/nz}/nzsiftdown/nz(/nzint i/nz)/nz{/nz  while/nz(/nz！/w到底/d或/c已经/d没有/v小/a的/ude1）/w  /x{/nz    n/nz[/nzi/nz]/nz和/cc左/f儿子/n比/p，/w和/cc右/f儿子/n比/p，/w如果/c有/vyou小/a的/ude1交换/gi并/cc记录/gi在/pt/nz中/f。/w更新/gi到/v交换/gi后/f的/ude1结点/gmi/nz=/nzt/nz。/w  /x}/nz}/nz6/nz、/w堆/gi的/ude1应用/gi优先队列/gi：/w普通/a的/ude1队列/gi是/vshi一种/nz先进先出/gi的/ude1数据结构/gi，/w元素/gi在/p队列/gi尾/ng追加/v，/w而/cc从/p队列/gi头/n删除/gi。/w二叉堆/gi就是/v优先队列/gi（/w父/ng节点/gi大于子/nz节点/gi）/w求/v一个/mq数列/gi中第/nzk/nz大/a//nz小/a的/ude1数/n。/w取出/vk/nz个数/n建/v一个/mq大小/n为/pk/nz的/ude1最小/a//nz大堆/nz，/w再/d从/pk/nz1/nz个数/n开始/v，/w依次/d拿/v去/vf和/cc堆顶/nz比较/gi，/w如果/c要/v小/a//nz大/a，/w就/d舍弃/v，/w如果/c大/a//nz小/a就/d一层一层/nz往/p下/f比/p和/cc移/v。/w时间复杂度/gio/nz(/nznlogn/gi)/nz并/cc查集/nz//nz不/d相/d交集/gi数据结构/gi的/ude1算法/gi：/w通过/p一个/mq数组/gi来/vf实现/gi，/w其本质/n是/vshi维护/gi一个/mq森林/gi，/w刚开始/nz的/ude1时候/n，/w森林/gi的/ude1每个/r点/gi都/d是/vshi孤立/a的/ude1，/w可/v理解/gi成/v一个/mq结点/gm的/ude1树/gi，/w之后/f通过/p一/nz些/q条件/n，/w逐步/d将/d这些/rz树/gi合并/gi成/v一/nz棵/q大树/n。/w判断/gi两/nz个/q节点/gi是否/v已经/d在/p同一/b棵树/q（/w数/n其实/d是/vshi个/q集合/gi）/w中的/v时候/n，/w也/d要/v注意/v必须/d求/v其/rz根源/n，/w中间/f父亲/n节点/gi是/vshi不能/v说明/v问题/gi的/ude1，/w必须/d找到/v其/rz祖宗/n判断/gi两/nz个/q结点/gm的/ude1祖宗/n是否是/l同一个/b根结/nz点/gi才/d行/ng。/w