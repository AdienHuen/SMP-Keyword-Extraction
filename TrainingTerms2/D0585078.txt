#设计模式/nz /x单一职责原则/gi
单一职责原则/gi  /x　　/nz定义/gi：/w不要/d存在/v多于一个/nz导致/gi类/gi变更/gi的/ude1原因/n。/w通俗/a的/ude1说/v，/w即/v一个/mq类/gi只/d负责/v一项/nz职责/gi。/w   /x　　/nz /x单一职责原则/gi告诉/v我们/rr：/w一个/mq类/gi不能/v太/d“/w累”/nz！/w在/p软件系统/gi中/f，/w一个/mq类/gi（/w大/a到/v模块/gi，/w小/a到/v方法/gi）/w承担/v的/ude1职责/gi越多/ad，/w它/rr被/pbei复用/gi的/ude1可能性/gi就越/d小/a，/w而且/c一个/mq类/gi承担/v的/ude1职责/gi过多/d，/w就/d相当于/v将/d这些/rz职责/gi耦合/vn在/p一起/s，/w当/p其中/rz一个/mq职责/gi变化/gi时/qt，/w可能会/nz影响/gi其他/rzv职责/gi的/ude1运作/gi，/w因此/c要/v将/d这些/rz职责/gi进行/vn分离/vi，/w将/d不同/a的/ude1职责/gi封装/gi在/p不同/a的/ude1类/gi中/f，/w即将/d不同/a的/ude1变化/gi原因/n封装/gi在/p不同/a的/ude1类/gi中/f，/w如果/c多/a个/q职责/gi总是/d同时/c发生/v改变/v则/d可/v将/d它们/rr封装/gi在/p同/p一类/b中/f。/w   /x　　/nz比如/v你/rr要用/vwinform/nz开发设计/i一个/mq游戏/gi。/w如果/c各种/rz事件/gi代码/gi都/d写/v在/p同一个/b类/gi，/w以后/f想/v将/d这个/rz游戏/gi改用/v其他/rzv框架/gi开发/gi就/d非常/d的/ude1难/a。/w我们/rr可以/v将/d界面/gi和/cc逻辑/n分开/vi不同/a的/ude1类/gi，/w来/vf实现/gi各自/rr单一/gi职责/gi，/w来/vf降低/v耦合度/gp。/w   /x　　/nz软件设计/nz真正/d要/v做/v的/ude1许多/m内容/gi，/w就是/v发现/v职责/gi并/cc把/pba那些/rz职责/gi互相/d分离/vi。/w通过/p判断/gi能否/v想到/v多于一个/nz的/ude1动机/gi去/vf改变/v一个/mq类/gi，/w那么/c这个/rz类/gi就/d具有/v多于一个/nz的/ude1职责/gi，/w就/d应该/v考虑/v类/gi的/ude1职责/gi分离/vi。/w