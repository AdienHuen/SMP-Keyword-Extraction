#五种/nz常见/a的/ude1 PHP /nz设计模式/nz
设计模式/nz只是/d为/p java/nz?/nz /x架构师/gi准备/v的/ude1 /x―/w―/w /x至少/d您/rr可能/v一直/d这样/rzv认为/v。/w实际上/d，/w设计模式/nz对于/p每个/r人/n都/d非常/d有/vyou用/p。/w如果/c这些/rz工具/gi不是/c /x“/w架构/gi太空/s人/n”/w /x的/ude1专利/gi，/w那么/c它们/rr又是/c什么/ry？/w为什么/ryv说/v它们/rr在/p php /nz应用程序/nz中/f非常/d有/vyou用/p？/w本文/r解释/gi了/ule这些/rz问题/gi。/w设计模式/nz /x一/nz书/gi将/d设计模式/nz引入/v软件社区/ns，/w该书/r的/ude1作者/nnt是/vshi erich gamma/nz、/wrichard helm/nz、/wralph johnson /nz和/cc john vlissides design/nz（/w俗称/v /x“/w四人帮/n”/w）/w。/w所/usuo介绍/gi的/ude1设计模式/nz背后/f的/ude1核心/n概念/gi非常简单/nz。/w经过/p多年/mq的/ude1软件开发/nz实践/gi，/wgamma /nz等/udeng人/n发现/v了/ule某些/rz具有/v固定/a设计/gi的/ude1模式/gi，/w就/d像/v建筑师/nnt设计/gi房子/n和/cc建筑物/n一样/uyy，/w可以/v为/p浴室/n的/ude1位置/gi或/c厨房/n的/ude1构造/n方式/n开发/gi模板/gi。/w使用/gi这些/rz模板/gi或者说/c设计模式/nz /x意味着/v可以/v更快/d地/ude2设计/gi更好/d的/ude1建筑物/n。/w同样/d的/ude1概念/gi也/d适用/vi于/p软件/gi。/w设计模式/nz不仅/c代表/nnt着/uzhe更快/d开发/gi健壮/a软件/gi的/ude1有/vyou用/p方法/gi，/w而且/c还/d提供/v了/ule以/p友好/a的/ude1术语/gi封装/gi大型/b理念/gi的/ude1方法/gi。/w例如/v，/w您/rr可以/v说/v您/rr正在/d编写/gi一个/mq提供/v松散/a耦合/vn的/ude1消息传递/l系统/gi，/w也/d可以/v说/v你/rr正在/d编写/gi名称/n为/p观察者/nz /x的/ude1模式/gi。/w用/p较小/d的/ude1示例/gi展示/gi模式/gi的/ude1价/n是/vshi非常/d困难/an的/ude1。/w这/rzv往往/d有些/rz大材小用/nz的/ude1意味/n，/w因为/c模式/gi实际上/d是/vshi在/p大型/b代码/gi库/n中/f发挥作用/n的/ude1。/w本文/r不/d展示/gi大型/b应用程序/nz，/w所以/c您/rr需要/v思索/v的/ude1是/vshi在/p您/rr自己/rr的/ude1大型/b应用程序/nz中/f应用/gi示例/gi原理/gi的/ude1方法/gi /x―/w―/w /x而/cc不是/c本文/r演示/gi的/ude1代码/gi本身/rz。/w这/rzv不是/c说/v您/rr不/d应该/v在/p小/a应用程序/nz中/f使用/gi模式/gi。/w很/d多/a良好/a的/ude1应用程序/nz都/d以/p小/a应用程序/nz为/p起点/gi，/w逐渐/d发展/gi到/v大型/b应用程序/nz，/w所以/c没有/v理由/n不以/c此类/r扎实/a的/ude1编码/gi实践/gi为基础/nz。/w既然/c您/rr已经/d了解/v了/ule设计模式/nz以及/cc它们/rr的/ude1有/vyou用/p之处/r，/w现在/t我们/rr来/vf看看/v php v/nz5/nz /x的/ude1五种/nz常用模式/gi。/w工厂模式/gi最初/d在/p设计模式/nz /x一/nz书/gi中/f，/w许多设计/nz模式/gi都/d鼓励/gi使用/gi松散/a耦合/vn。/w要/v理解/gi这个/rz概念/gi，/w让/v我们/rr最好/d谈一下/nz许多/m开发人员/n从事/vi大型/b系统/gi的/ude1艰苦/a历程/gi。/w在/p更改/gi一个/mq代码/gi片段/n时/qt，/w就/d会/v发生/v问题/gi，/w系统/gi其他/rzv部分/n /x―/w―/w /x您/rr曾/d认为/v完全/ad不/d相关/vn的/ude1部分/n中/f也/d有可能/nz出现/v级联/n破坏/v。/w该/rz问题/gi在于/v紧密/ad耦合/vn /x。/w系统/gi某个/rz部分/n中的/v函数/gi和/cc类/gi严重/a依赖于/v系统/gi的/ude1其他/rzv部分/n中函数/nz和/cc类/gi的/ude1行为/n和/cc结构/gi。/w您/rr需要/v一/nz组/n模式/gi，/w使/v这些/rz类/gi能够/v相互/d通信/gi，/w但/c不/d希望/v将/d它们/rr紧密/ad绑定/gi在/p一起/s，/w以/p避免出现/v联锁/nz。/w在/p大型/b系统/gi中/f，/w许多代码/nz依赖于/v少数/mq几/d个/q关键/n类/gi。/w需要/v更改/gi这些/rz类/gi时/qt，/w可能会/nz出现/v困难/an。/w例如/v，/w假设/gi您/rr有/vyou一个/mq从文件/l读取/gi的/ude1  /x类/gi。/w您/rr希望/v将/d其/rz更改/gi为/p从/p数据库/gi读取/gi的/ude1其他/rzv类/gi，/w但是/c，/w所有/b的/ude1代码/gi都/d引用/gi从文件/l读取/gi的/ude1原始/a类/gi。/w这时候/rzt，/w使用/gi工厂模式/gi会/v很/d方便/a。/w工厂模式/gi /x是/vshi一/nz种类/n，/w它/rr具有/v为/p您/rr创建对象/n的/ude1某些/rz方法/gi。/w您/rr可以/v使用/gi工厂/gi类/gi创建对象/n，/w而/cc不/d直接/ad使用/gi /x。/w这样/rzv，/w如果/c您/rr想要/v更改/gi所/usuo创建/gi的/ude1对象/gi类型/gi，/w只需/v更改/gi该/rz工厂/gi即可/v。/w使用/gi该/rz工厂/gi的/ude1所有/b代码/gi会/v自动/d更改/gi。/w清单/n /x1/nz /x显示/gi工厂/gi类/gi的/ude1一个/mq示列/nz。/w等/udeng式/k的/ude1服务器端/gi包括/v两/nz个/q部分/n：/w数据库/gi和/cc一/nz组/n php /nz页面/gi，/w这些/rz页面/gi允许/v您/rr添加/gi反馈/gi、/w请求/gi反馈/gi列表/vi并/cc获取/gi与/cc特定/b反馈/gi相关/vn的/ude1文章/gi。/w清单/n /x1./nz factory/nz1./nzphp /nz接口定义/l用户/gi对象/gi应/v执行/v什么/ry操作/gi。/w /x的/ude1实现/gi称为/v /x，/w /x工厂/gi类/gi则/d创建/gi /x对象/gi。/w此/rzs关系/gi可以/v用/p图/gi /x1/nz /x中的/v uml /nz表示/v。/w图/gi /x1./nz /x工厂/gi类/gi及其/cc相关/vn iuser /nz接口/gi和/cc用户/gi类/gi如果/c您/rr使用/gi  /x解释器/gi在/p命令行/n上/f运行/gi此/rzs代码/gi，/w将/d得到/v如下/vi结果/n：/w测试代码/n会/v向/p工厂/gi请求/gi  /x对象/gi，/w并/cc输出/gi  /x方法/gi的/ude1结果/n。/w有/vyou一种/nz工厂模式/gi的/ude1变体/nz使用/gi工厂方法/gi。/w类/gi中的/v这些/rz公共/b静态方法/gi构造/n该/rz类型/gi的/ude1对象/gi。/w如果/c创建/gi此/rzs类型/gi的/ude1对象/gi非常/d重要/a，/w此/rzs方法/gi非常/d有/vyou用/p。/w例如/v，/w假设/gi您/rr需要/v先/d创建对象/n，/w然后/c设置/gi许多属/nz性/ng。/w此/rzs版本/n的/ude1工厂模式/gi会/v将/d该/rz进程/gi封装/gi在/p单个/b位置/gi中/f，/w这样/rzv，/w不用/d复制/gi复杂/a的/ude1初始化/v代码/gi，/w也/d不必/d将/d复制/gi好/a的/ude1代码/gi在在/d代码/gi库/n中/f到处/d粘贴/v。/w清单/n /x2/nz /x显示/gi使用/gi工厂方法/gi的/ude1一个/mq示例/gi。/w清单/n /x2./nz factory/nz2./nzphp/gi这段/r代码/gi要/v简单/a得/ude3多/a。/w它/rr仅有/nz一个/mq接口/gi  /x和/cc一个/mq实现/gi此/rzs接口/gi的/ude1  /x类/gi。/w /x类/gi有/vyou两/nz个/q创建对象/n的/ude1静态方法/gi。/w此/rzs关系/gi可用/v图/gi /x2/nz /x中的/v uml /nz表示/v。/w图/gi /x2./nz iuser /nz接口/gi和/cc带有/v工厂方法/gi的/ude1 user /nz类/gi在/p命令行/n中/f运行/gi脚本/gi产生/v的/ude1结果/n与/cc清单/n /x1/nz /x的/ude1结果/n相同/a，/w如下/vi所示/nz：/w如上所述/c，/w有时/d此类/r模式/gi在/p规模/gi较小/d的/ude1环境/n中/f乎/y有些/rz大材小用/nz。/w不过/c，/w最好/d还是/c学习/gi这种/r扎实/a的/ude1编码/gi形式/gi，/w以便/d应用于/v任意/d规模/gi的/ude1项目/gi中/f。/w单元素/nz模式/gi某些/rz应用程序/nz资源/gi是/vshi独占/v的/ude1，/w因为/c有/vyou且/c只有/c一个/mq此类型/nz的/ude1资源/gi。/w例如/v，/w通过/p数据库/gi句柄/gi到/v数据库/gi的/ude1连接/gi是/vshi独占/v的/ude1。/w您/rr希望/v在/p应用程序/nz中共享/nz数据库/gi句柄/gi，/w因为/c在/p保持/v连接/gi打开/gi或/c关闭/gi时/qt，/w它/rr是/vshi一种/nz开销/n，/w在/p获取/gi单个/b页面/gi的/ude1过程/gi中/f更是如此/l。/w单元素/nz模式/gi可以/v满足/v此/rzs要求/n。/w如果/c应用程序/nz每次/r包含/v且/c仅/d包含/v一个/mq对象/gi，/w那么/c这个/rz对象/gi就是/v一个/mq单元素/nz（/wsingleton/gi）/w。/w清单/n /x3/nz /x中的/v代码/gi显示/gi了/ule php v/nz5/nz /x中的/v一个/mq数据库/gi连接/gi单元素/nz。/w清单/n /x3./nz singleton/nz./nzphp/gi此/rzs代码/gi显示/gi名为/v  /x的/ude1单个/b类/gi。/w您/rr不能/v创建/gi自已/n的/ude1 /x，/w因为/c构造函数/gi是/vshi专用/gi的/ude1。/w但/c使用/gi静态/gi /x方法/gi，/w您/rr可以/v获得/v且/c仅/d获得/v一个/mq  /x对象/gi。/w此/rzs代码/gi的/ude1 uml /nz如/v图/gi /x3/nz /x所示/nz。/w图/gi /x3./nz /x数据库/gi连接/gi单元素/nz在/p两次/nz调用/gi间/f，/w /x方法/gi返回/v的/ude1数据库/gi句柄/gi是/vshi相同/a的/ude1，/w这/rzv就是/v最好/d的/ude1证明/v。/w您/rr可以/v在/p命令行/n中/f运行/gi代码/gi来/vf观察/gi这一点/nz。/w返回/v的/ude1两/nz个/q句柄/gi是/vshi同一/b对象/gi。/w如果/c您/rr在/p整个/b应用程序/nz中/f使用/gi数据库/gi连接/gi单元素/nz，/w那么/c就/d可以/v在/p任何/rz地方/n重用/gi同一/b句柄/gi。/w您/rr可以/v使用/gi全局变量/gi存储/gi数据库/gi句柄/gi，/w但是/c，/w该/rz方法/gi仅/d适用/vi于/p较小/d的/ude1应用程序/nz。/w在/p较大/d的/ude1应用程序/nz中/f，/w应/v避免/v使用/gi全局变量/gi，/w并/cc使用/gi对象/gi和/cc方法/gi访问/gi资源/gi。/w观察者模式/gi观察者模式/gi为/p您/rr提供/v了/ule避免/v组件/gi之间/f紧密/ad耦合/vn的/ude1另一种/nz方法/gi。/w该/rz模式/gi非常简单/nz：/w一个/mq对象/gi通过/p添加/gi一个/mq方法/gi（/w该/rz方法/gi允许/v另一个/nz对象/gi，/w即/v观察者/nz /x注册/gi自己/rr）/w使/v本身/rz变得/vi可/v观察/gi。/w当/p可/v观察/gi的/ude1对象/gi更改/gi时/qt，/w它/rr会/v将/d消息/n发送到/l已/d注册/gi的/ude1观察者/nz。/w这些/rz观察者/nz使用/gi该/rz信息/gi执行/v的/ude1操作/gi与/cc可/v观察/gi的/ude1对象/gi无关/v。/w结果/n是/vshi对象/gi可以/v相互/d对话/vn，/w而/cc不必/d了解/v原因/n。/w一个/mq简单/a示例/gi是/vshi系统/gi中的/v用户/gi列表/vi。/w清单/n /x4/nz /x中的/v代码/gi显示/gi一个/mq用户/gi列表/vi，/w添加/gi用户/gi时/qt，/w它/rr将/d发送/gi出/vf一条/nz消息/n。/w添加/gi用户/gi时/qt，/w通过/p发送/gi消息/n的/ude1日志/gi观察者/nz可以/v观察/gi此/rzs列表/vi。/w清单/n /x4./nz observer/nz./nzphp/gi此/rzs代码/gi定义/gi四个/nz元素/gi：/w两/nz个/q接口/gi和/cc两/nz个/q类/gi。/w /x接口定义/l可以/v被/pbei观察/gi的/ude1对象/gi，/w /x实现/gi该/rz接口/gi，/w以便/d将/d本身/rz注册/gi为/p可/v观察/gi。/w /x列表/vi定义/gi要/v通过/p怎样/ryv的/ude1方法/gi才能/n成为/v观察者/nz，/w /x实现/gi /x接口/gi。/w图/gi /x4/nz /x的/ude1 uml /nz中/f展示/gi了/ule这些/rz元素/gi。/w图/gi /x4./nz /x可/v观察/gi的/ude1用户/gi列表/vi和/cc用户/gi列表/vi事件/gi日志/gi程序/gi如果/c在/p命令行/n中/f运行/gi它/rr，/w您/rr将/d看到/v以下/f输出/gi：/w测试代码/n创建/gi /x，/w并/cc将/d  /x观察者/nz添加/gi到/v其中/rz。/w然后/c添加/gi一个/mq消费者/n，/w并/cc将/d这/rzv一/nz更改/gi通知/gi。/w认识到/v  /x不/d知道/v日志/gi程序/gi将/d执行/v什么/ry操作/gi很/d关键/n。/w可能/v存在/v一个/mq或/c多/a个/q执行/v其他/rzv操作/gi的/ude1侦听/nz程序/gi。/w例如/v，/w您/rr可能/v有/vyou一个/mq向/p新/a用户/gi发送/gi消息/n的/ude1观察者/nz，/w欢迎新/nz用户/gi使用/gi该/rz系统/gi。/w这种/r方法/gi的/ude1价/n在于/v /x忽略/v所有/b依赖/v它/rr的/ude1对象/gi，/w它/rr主要/b关注/v在/p列表/vi更改/gi时/qt维护/gi用户/gi列表/vi并/cc发送/gi消息/n这/rzv一/nz工作/gi。/w此/rzs模式/gi不限/v于/p内存/gi中的/v对象/gi。/w它/rr是/vshi在/p较大/d的/ude1应用程序/nz中/f使用/gi的/ude1数据库/gi驱动/gi的/ude1消息/n查询/gi系统/gi的/ude1基础/gi。/w命令/gi链/ng模式/gi命令/gi链/ng /x模式/gi以/p松散/a耦合/vn主题/n为基础/nz，/w发送/gi消息/n、/w命令/gi和/cc请求/gi，/w或/c通过/p一/nz组/n处理程序/n发送/gi任意/d内容/gi。/w每个/r处理程序/n都会/n自行/d判断/gi自己/rr能否/v处理/vn请求/gi。/w如果/c可以/v，/w该/rz请求/gi被/pbei处理/vn，/w进程/gi停止/gi。/w您/rr可以/v为/p系统/gi添加/gi或/c移除/v处理程序/n，/w而/cc不/d影响/gi其他/rzv处理程序/n。/w清单/n /x5/nz /x显示/gi了/ule此/rzs模式/gi的/ude1一个/mq示例/gi。/w清单/n /x5./nz chain/nz./nzphp/gi此/rzs代码/gi定义/gi维护/gi  /x对象/gi列表/vi的/ude1  /x类/gi。/w两/nz个/q类/gi都/d可以/v实现/gi  /x接口/gi /x―/w―/w /x一个/mq对/p邮件/n的/ude1请求/gi作出/v响应/v，/w另一个/nz对/p添加/gi用户/gi作出/v响应/v。/w /x图/gi /x5/nz /x给出/v了/ule uml/nz。/w图/gi /x5./nz /x命令/gi链/ng及其/cc相关/vn命令/gi如果/c您/rr运行/gi包含/v某些/rz测试代码/n的/ude1脚本/gi，/w则/d会/v得到/v以下/f输出/gi：/w代码/gi首先/d创建/gi  /x对象/gi，/w并为/c它/rr添加/gi两/nz个/q命令/gi对象/gi的/ude1实例/gi。/w然后/c运行/gi两/nz个/q命令/gi以/p查看/gi谁/ry对/p这些/rz命令/gi作出/v了/ule响应/v。/w如果/c命令/gi的/ude1名称/n匹配/gi /x或/c /x，/w则/d代码/gi失败/vi，/w不/d发生/v任何/rz操作/gi。/w为/p处理/vn请求/gi而/cc创建/gi可扩展/nz的/ude1架构/gi时/qt，/w命令/gi链/ng模式/gi很/d有/vyou价/n，/w使用/gi它/rr可以/v解决/v许/v多/a问题/gi。/w策略模式/gi我们/rr讲述/v的/ude1最后/f一个/mq设计模式/nz是/vshi策略/gi /x模式/gi。/w在/p此/rzs模式/gi中/f，/w算法/gi是从/v复杂/a类/gi提取/v的/ude1，/w因而/c可以/v方便/a地/ude2替换/v。/w例如/v，/w如果/c要/v更改/gi搜索引擎/gi中/f排列/gi页/q的/ude1方法/gi，/w则/d策略模式/gi是/vshi一个/mq不错/a的/ude1选择/gi。/w思考/gi一/nz下/f搜索引擎/gi的/ude1几个/nz部分/n /x―/w―/w /x一/nz部分/n遍历/gi页面/gi，/w一/nz部分/n对/p每页/nz排列/gi，/w另/rz一/nz部分/n基于/p排列/gi的/ude1结果/n排序/gi。/w在/p复杂/a的/ude1示例/gi中/f，/w这些/rz部分/n都/d在/p同一个/b类/gi中/f。/w通过/p使用/gi策略模式/gi，/w您/rr可/v将/d排列/gi部分/n放入/v另一个/nz类/gi中/f，/w以便/d更改/gi页/q排列/gi的/ude1方式/n，/w而/cc不/d影响/gi搜索引擎/gi的/ude1其余/rz代码/gi。/w作为/p一个/mq较/d简单/a的/ude1示例/gi，/w清单/n /x6/nz /x显示/gi了/ule一个/mq用户/gi列表/vi类/gi，/w它/rr提供/v了/ule一个/mq根据/p一/nz组/n即插即用/gi的/ude1策略/gi查找/gi一/nz组/n用户/gi的/ude1方法/gi。/w /x清单/n /x6./nz strategy/nz./nzphp/gi此/rzs代码/gi的/ude1 uml /nz如/v图/gi /x6/nz /x所示/nz。/w图/gi /x6./nz /x用户/gi列表/vi和/cc用于/v选择/gi用户/gi的/ude1策略/gi /x类/gi是/vshi打包/vi名称/n数组/gi的/ude1一个/mq包装器/nz。/w它/rr实现/gi  /x方法/gi，/w该/rz方法/gi利用/v几/d个/q策略/gi之一/rz来/vf选择/gi这些/rz名称/n的/ude1子集/gi。/w这些/rz策略/gi由/p /x接口定义/l，/w该/rz接口/gi有/vyou两/nz个/q实现/gi：/w一个/mq随机/b选择/gi用户/gi，/w另一个/nz根据/p指定/v名称/n选择/gi其后/f的/ude1所有/b名称/n。/w运行/gi测试代码/n时/qt，/w将/d得到/v以下/f输出/gi：/w测试代码/n为/p两/nz个/q策略/gi运行/gi同一/b用户/gi列表/vi，/w并/cc显示/gi结果/n。/w在/p第一/mq种/q情况/n中/f，/w策略/gi查找/gi排列/gi在/p  /x后/f的/ude1任何/rz名称/n，/w所以/c您/rr将/d得到/v jack/nz、/wlori /nz和/cc megan/nz。/w第二个/nz策略/gi随机/b选取/gi名称/n，/w每次/r会/v产生/v不同/a的/ude1结果/n。/w在/p这种/r情况下/nz，/w结果/n为/p andy /nz和/cc megan/nz。/w策略模式/gi非常适合/i复杂/a数据/gi管理系统/gi或/c数据处理/gi系统/gi，/w二者/rzv在/p数据/gi筛选/v、/w搜索/gi或/c处理/vn的/ude1方式/n方面/n需要/v较高/ad的/ude1灵活性/gi。/w结束语/n本文/r介绍/gi的/ude1仅仅/d是/vshi php /nz应用程序/nz中/f使用/gi的/ude1几/d种/q最/d常见/a的/ude1设计模式/nz。/w在/p设计模式/nz /x一/nz书/gi中/f演示/gi了/ule更多/ad的/ude1设计模式/nz。/w不要/d因/p架构/gi的/ude1神秘性/nz而/cc放弃/gi。/w模式/gi是/vshi一/nz种/q绝妙/b的/ude1理念/gi，/w适用/vi于/p任何/rz编程语言/gi、/w任何/rz技能/gi水平/n。/w参考资料/nz /x学习/gi /x是/vshi面向/v php /nz开发人员/n的/ude1资源/gi。/wwikipedia /nz中/f有/vyou关于/p设计模式/nz的/ude1 /x。/wc/nz2/nz wiki /nz查找/gi有关/vn设计模式/nz（/w如/v /x、/w /x等/udeng）/w信息/gi的/ude1另一个/nz好去处/nz。/w任何/rz工程师/gi都/d应该/v阅读/gi  /x原/b书/gi。/wo/nz'/nzreilly /nz的/ude1  /x是/vshi学习/gi设计模式/nz的/ude1轻量级/gi方法/gi。/w /x一/nz书/gi中/f介绍/gi了/ule针对/gi模式/gi设计/gi的/ude1几/d种/q黑客技术/nz，/w可扩展/nz本文/r介绍/gi的/ude1示例/gi。/w浏览/gi ibm developerworks /nz的/ude1 /x，/w了解/v关于/p php /nz的/ude1详细/gi内容/gi。/w关注/v最新/a的/ude1 /x。/w了解/v全球/gi范围内/nz即将/d开展/v的/ude1研讨会/n、/w内部/f预映/nz、/w网络/gi广播/gi和/cc其他/rzv /x，/w这些/rz都/d是/vshi ibm /nz开放源码/gi开发人员/n感兴趣/a的/ude1内容/gi。/w访问/gi developerworks /nz，/w获得/v广泛/a的/ude1 how/nz-/nzto /nz信息/gi、/w工具/gi和/cc项目/gi更新/gi，/w帮助/v您/rr使用/gi开放源码/gi技术/gi进行/vn开发/gi，/w并/cc与/cc ibm /nz产品/gi结合/v使用/gi。/w收听/v针对/gi软件开发/nz人员/gi的/ude1有趣/a的/ude1访谈/vn和/cc讨论/gi，/w务必/d浏览/gi /x。/w获得/v产品/gi和/cc技术/gi使用/gi  /x构建/gi下一个/nz开发/gi项目/gi，/w这些/rz软件/gi可以/v直接/ad从/p developerworks /nz下载/gi获得/v。/w讨论/gi通过/p参与/gi  /x加入/v developerworks /nz社区/gi。/w