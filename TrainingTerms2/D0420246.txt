#设计模式/nz学习/gi002/nz―/w―/w装饰者模式/gi
设计模式/nz中/f有/vyou一个/mq黄金/n法则/gi：/w慎用/v继承/gi，/w多用/b组合/gi。/w如果/c使用/gi继承/gi，/w一旦/d需求/gi改变/v，/w这个/rz时候/n一般/ad都/d需要/v去/vf改/v代码/gi。/w这样/rzv就/d会/v造成/v耦合性/nz太高/d，/w维护/gi成本/n加大/v。/w但是/c使用/gi组合/gi，/w则/d可以/v很好/ad的/ude1来/vf解决/v一/nz些/q问题/gi。/w关于/p装饰者/gi有/vyou五条/nz规则/gi：/w第一/mq：/w装饰者/gi和/cc被/pbei装饰者/gi对象/gi要/v有/vyou相同/a的/ude1超类型/nz。/w这样/rzv把/pba被/pbei装饰者/gi包装者/n的/ude1被/pbei装饰者/gi给/p别人/rr看/v的/ude1时候/n，/w才/d不会/v引起/v类型/gi混乱/a。/w第二/mq：/w一个/mq被/pbei装饰者/gi可以/v被/pbei多/a个/q装饰者/gi进行/vn多/a次/qv包装/n。/w第三/nz：/w既然/c装饰者/gi和/cc被/pbei装饰者/gi有/vyou相同/a的/ude1超类型/nz，/w所以/c任何/rz需要/v原始/a对象/gi的/ude1场合/n，/w可以/v用/p装饰/gi过/uguo的/ude1对象/gi代替/v他/rr。/w第四/nz：/w装饰者/gi可以/v再/d所/usuo委托/vn被/pbei装饰者/gi的/ude1行为/n之前/f//nz后/f加上/v自己/rr的/ude1行为/n，/w以/p达到/v特定/b的/ude1目的/gi。/w第五/nz：/w对象/gi可以/v在/p任何/rz时候/n被/pbei装饰/gi，/w也/d可以/v在/p任何/rz时候/n动态/gi的/ude1不/d限量/n的/ude1用/p你/rr喜欢/gi的/ude1装饰者/gi来/vf装饰/gi被/pbei装饰/gi的/ude1对象/gi。/w比如/v：/w我们/rr熟悉/v的/ude1io/gi包/v中的/v大量/m类/gi的/ude1设计/gi就是/v遵循/gi这个/rz原则/gi。/w我们/rr常常/d会/v使用/gi inputstream in /nz=/nz new bufferinputstream/nz(/nznew fileinputstream/nz(/nzxxx/nz./nzxx/nz)/nz)/nz;/nz来/vf取得/v一个/mq输入流/nz对象/gi。/w这/rzv就是/v用/p到/v了/ule包装器/nz模式/gi，/w一般/ad包装/n在/p被/pbei包装/n对象/gi外面/f的/ude1那/rzv层/gi包装器/nz会/v提供/v一/nz些/q额外/b的/ude1功能/gi，/w比如/v功能/gi增强/v等/udeng。/w最后/f，/w提/v一个/mq关于/p这个/rz设计模式/nz的/ude1两/nz个/q弊端/n，/w一个/mq弊端/n就是/v：/w由于/p包装/n器类/nz的/ude1产生/v，/w会/v产生/v更多/ad的/ude1小类/nz，/w类/gi的/ude1数量/n增多/v了/ule，/w理解/gi就/d麻烦/an了/ule。/w第二个/nz弊端/n就是/v如果/c包装器/nz中的/v被/pbei包装/n对象/gi的/ude1引用/gi如果/c是/vshi针对/gi具体/a类型/gi，/w就/d会/v出/vf问题/gi。/w那/rzv会/v出/vf什么/ry问题/gi呢/y？/w /x想/v一下/m，/w如果/c包装器/nza/nz中的/v引用/gi的/ude1被/pbei包装/n类型/gi如果/c不是/c超类型/nz（/winputstream/nz)/nz，/w而是/c一个/mq具体/a的/ude1子类/gm（/w比如/vfileinputstream/nz)/nz。/w这个/rz时候/n，/w说/v先/d如果/c我/rr传给/v包装器/nza/nz的/ude1是/vshi一个/mqstringbufferinputstream/nz的/ude1就/d不行/a。/w而且/c，/w如果/c在/p包装器/nza/nz中/f给/p被/pbei引用/gi的/ude1被/pbei包装/n对象/gi赋/ng的/ude1set/nz方法/gi中/f设置/gi的/ude1是/vshi接受/gi一个/mqinputstream/nz超/v类型/gi的/ude1变量/gi，/w还/d不/d可以/v直接/ad付给/vfileinputstream/nz类型/gi的/ude1实例/gi变量/gi，/w必须/d进行/vn类型/gi装换/nz，/w不然/c报错/nz。/w但是/c如果/c进行/vn了/ule类型/gi装换/nz，/w有/vyou让/v包装器/nz对象/gi失去/v了/ule一般性/n。/w得不偿失/vl。/w