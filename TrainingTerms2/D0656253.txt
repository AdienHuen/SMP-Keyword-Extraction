#Top k/nz问题/gi的/ude1一个/mq应用/gi
需求/gi：/w实时/n统计/gi一个/mq函数/gi运行/gin/nz多/a次/qv所花/n时间/gi最大/gm的/ude1k/nz个/q。/w方法/gi：/w利用/v堆/gi（/w小顶堆/gi）/w排序/gi方法/gi进行/vn。/w比如说/vl，/w要/v统计/gi的/ude1最大/gm个数/n为/p10/nz个/q。/w由于/p函数/gi运行时间/gi是/vshi实时/n统计/gi出来/vf的/ude1，/w新/a统计/gi的/ude1时间/gi跟/p小顶堆/gi的/ude1最小/a比较/gi，/w若/c大于/v或/c等于/v小顶堆/gi的/ude1最小/a，/w则/d更新/gi，/w并/cc调整/vn堆/gi使/v之/uzhi成为/v新的/a小顶堆/gi。/w开始/v时/qt不用/d建立/gi堆/gi，/w可以/v认为/v数组/gi中的/v10/nz个/q全/a为/p0/nz的/ude1也/d是/vshi一/nz种/q小顶堆/gi结构/gi。/w这里/rzs用/p随机/b数/n来/vf代表/nnt某个/rz函数/gi的/ude1运行时间/gi。/w代码/gi如下/vi：/w下面/f给出/v了/ule另一种/nz实现/gi方法/gi，/w并/cc与/cc堆/gi比较/gi排序/gi结果/n。/w比较/gi结果/n。/w下图/n是/vshi500001/nz个数/n，/w查询/gi结果/n一致/a。/w统计/gi时间/gi可能/v有误/vn，/w但/c对/p算法/gi在/p数据/gi较多/d时/qt应该/v是/vshi好/a于/p方法/gi2。/nz这/rzv两/nz种/q算法/gi的/ude1复杂度/gi分析/gi可/v参考/gi中的/v第一/mq节/q、/w各种/rz思路/gi，/w各种/rz选择/gi /x2/nz,/nz3./nz若/c每次/r统计/gi的/ude1数据/gi有/vyou相同/a的/ude1，/w方法/gi2/nz可以/v给出/v最新/a最大/gm的/ude1，/w本文/r中的/v堆/gi算法程序/gi给出/v的/ude1时间/gi顺序/gi上/f是/vshi乱/d的/ude1。/w下图/n中/f所有/b都/d是/vshi1/nz，/w堆/gi算法/gi给出/v的/ude1时间/gi上/f是/vshi乱/d的/ude1，/w方法/gi2/nz可以/v给出/v最新/a的/ude1大/a。/w