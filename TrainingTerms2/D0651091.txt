#快速排序/gi算法/gi
快速排序/gi是/vshi由/p东・霍尔/nz所/usuo发展/gi的/ude1一种/nz排序算法/gi。/w在/p平均/a状况/n下/f，/w排序/gin/nz个/q项目/gi要/vο/nz(/nznlogn/gi)/nz次/qv比较/gi。/w在/p最坏/gi状况/n下/f则/d需要/vο/nz(/nzn/nz2/nz)/nz次/qv比较/gi，/w但/c这种/r状况/n并不/d常见/a。/w事实上/bl，/w快速排序/gi通常/d明显/a比/p其他/rzvο/nz(/nznlogn/gi)/nz算法/gi更快/d，/w因为/c它/rr的/ude1内部/f循环/gi（/winnerloop/nz）/w可以/v在/p大部分/n的/ude1架构/gi上/f很/d有效率/n地被/n实现/gi出来/vf。/w快速排序/gi使用/gi分治法/gi（/wdivideandconquer/nz）/w策略/gi来/vf把/pba一个/mq串行/b（/wlist/gi）/w分为/v两个子/nz串行/b（/wsub/nz-/nzlists/nz）/w。/w算法步骤/gi：/w1/nz从/p数列/gi中/f挑出/vf一个/mq元素/gi，/w称为/v“/w基准”/nz（/wpivot/nz）/w，/w2/nz重新/d排序/gi数列/gi，/w所有/b元素/gi比/p基准/gi小/a的/ude1摆放在/v基准/gi前面/f，/w所有/b元素/gi比/p基准/gi大/a的/ude1摆在/v基准/gi的/ude1后面/f（/w相同/a的/ude1数/n可以/v到/v任/v一边/d）/w。/w在/p这个/rz分区/gi退出/gi之后/f，/w该/rz基准/gi就/d处于/v数列/gi的/ude1中间/f位置/gi。/w这个/rz称为/v分区/gi（/wpartition/nz）/w操作/gi。/w3/nz递归/gi地/ude2（/wrecursive/nz）/w把/pba小于/v基准/gi元素/gi的/ude1子数列/nz和/cc大于/v基准/gi元素/gi的/ude1子数/nz列/v排序/gi。/w递归/gi的/ude1最/d底部/f情形/n，/w是/vshi数列/gi的/ude1大小/n是/vshi零/nz或/c一/nz，/w也/d就是/v永远/d都/d已经/d被/pbei排序/gi好/a了/ule。/w虽然/c一直/d递归/gi下去/vf，/w但是/c这个/rz算法/gi总会/nis退出/gi，/w因为/c在/p每次/r的/ude1迭代/gi（/witeration/nz）/w中/f，/w它/rr至少/d会/v把/pba一个/mq元素/gi摆到/v它/rr最后/f的/ude1位置/gi去/vf。/w