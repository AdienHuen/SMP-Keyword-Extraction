#Bitmap/nz算法/gi
在/p所有/b具有/v性能优化/gi的/ude1数据结构/gi中/f，/w我/rr想/v大家/rr使用/gi最多/ad的/ude1就是/vhash/gi表/n，/w是/vshi的/ude1，/w在/p具有/v定位/gi查找/gi上/f具有/vo/nz(/nz1/nz)/nz的/ude1常量/gi时间/gi，/w多么/d的/ude1简洁/gi优美/a，/w但是/c在/p特定/b的/ude1场合/n下/f：/w①/nz：/w对/p10/nz亿个/nz不/d重复/gi的/ude1整数/gi进行/vn排序/gi。/w②/nz：/w找出/v10/nz亿个/nz数字/gi中/f重复/gi的/ude1数字/gi。/w当然/d我/rr只有/c普通/a的/ude1服务器/gi，/w就算/d2/nzg/nz的/ude1内存/gi吧/y，/w在/p这种/r场景/gi下/f，/w我们/rr该/rz如何/ryv更好/d的/ude1挑选/v数据结构/gi和/cc算法/gi呢/y？/w一/nz：/w问题/gi分析/gi  /x这年头/l，/w大牛/nz们/k写/v的/ude1排序算法/gi也/d就/d那么/c几个/nz，/w首先/d我们/rr算/v下放/v在/p内存/gi中/f要/v多少/ryg/nz:/w /x(/nz10/nz亿/nz /x*/nz /x32/nz)/nz//nz(/nz1024/nz*/nz1024/nz*/nz1024/nz*/nz8/nz)/nz=/nz3.6/nzg/nz，/w可怜/v的/ude12/nzg/nz内存/gi直接/ad爆掉/nz，/w所以/c各种/rz神马/nz的/ude1数据结构/gi都/d玩/v不/d起来/vf了/ule，/w当然/d使用/gi外/f排序/gi还是/c可以/v解决问题/v的/ude1，/w由于/p要/v走/vio/gi所以/c暂时/d剔除/v，/w因为/c我们/rr要玩/nz高性能/gi，/w无望/vi后/f我们/rr想想/v可不可以/v在/p二进制位/n上/f做/v些/q手脚/n？/w /x比如/v我/rr要/v对/p{/nz1/nz,/nz5/nz,/nz7/nz,/nz2/nz}/nz这/rzv四个/nzbyte/nz类型/gi的/ude1数字/gi做/v排序/gi，/w该/rz怎么做/nz呢/y？/w我们/rr知道/vbyte/nz是/vshi占/v8/nz个/qbit/nz位/q，/w其实/d我们/rr可以/v将/d数组/gi中的/v作为/pbit/nz位/q的/ude1key/gi，/wvalue/nz用/p”/w0/nz，/w1/nz“/w来/vf标识/n该/rzkey/gi是否/v出现/v过/uguo？/w下面/f看图/v：/w从/p图/gi中/f我们/rr精彩/a的/ude1看到/v，/w我们/rr的/ude1数组/gi都/d已经/d作为/pbyte/nz中的/vkey/gi了/ule，/w最后/f我/rr只要/c遍历/gi对应/vi的/ude1bit/nz位/q是否/v为/p1/nz就/d可以/v了/ule，/w那么/c自然/n就/d成/v有序/gi数组/gi了/ule。/w可能/v有人/r说/v，/w我/rr增加/v一个/mq13/nz怎么办/ryv？/w很/d简单/a，/w一个字/nz节/q可以/v存放/v8/nz个数/n，/w那/rzv我/rr只要/c两/nz个/qbyte/nz就/d可以/v解决问题/v了/ule。/w可以/v看出/v我/rr将/d一个/mq线性/gi的/ude1数组/gi变成/v了/ule一个/mqbit/nz位/q的/ude1二维矩阵/nz，/w最终/d我们/rr需要/v的/ude1空间/n仅仅/d是/vshi:/w3.6/nzg/nz//nz32/nz=/nz0.1/nzg/nz即可/v，/w要/v注意/v的/ude1是/vshibitmap/gi排序/gi不是/cn/nz的/ude1，/w而是/c取决于/v待/vi排序/gi数组/gi中的/v最大/gm，/w在/p实际/n应用/gi上/f关系/gi也/d不大/d，/w比如/v我/rr开/v10/nz个/q线程/gi去/vf读/vbyte/nz数组/gi，/w那么/c复杂度/gi为/p:/wo/nz(/nzmax/nz//nz10/nz)/nz。/w二/nz：/w代码/gi /x我/rr想/vbitmap/gi的/ude1思想/gi大家/rr都/d清楚/a了/ule，/w这/rzv一次/nz又/d让/v我们/rr见证/n了/ule二进制/gi的/ude1魅力/n，/w当然/d这些/rz移位/gi都/d是/vshi位运算/gi的/ude1工作/gi了/ule，/w熟悉/v了/ule你/rr就/d玩转/vi了/ule。/w1/nz:/wclear/nz方法/gi（/w将/d数组/gi的/ude1所有/bbit/nz位置/gi0/nz）/w /x比如/v要/v将/d当前/t4/nz对应/vi的/ude1bit/nz位置/gi0/nz的话/udh，/w只/d需要/v1/nz左移/gi4/nz位/q取反/v与/ccb/nz[/nz0/nz]/nz  /x即可/v。/w2/nz:/wadd/nz方法/gi（/w将/dbit/nz置/v1/nz操作/gi）/w /x同样/d也/d很/d简单/a，/w要/v将/d当前/t4/nz对应/vi的/ude1bit/nz位置/gi1/nz的话/udh，/w只/d需要/v1/nz左移/gi4/nz位与/vb/nz[/nz0/nz]/nz /x|/nz /x即可/v。/w2/nz:/wcontain/nz方法/gi（/w判断/gi当前/tbit/nz位/q是否是/l1/nz）/w  /x如果/c看懂/nz了/uleclear/nz和/ccadd/nz，/w我/rr相信/v最后/f一个/mq方法/gi已经/d不成问题/l了/ule。/w最后/f上/f总的/b代码/gi：/wview code/nz