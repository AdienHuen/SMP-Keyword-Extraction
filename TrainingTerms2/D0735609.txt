#泛型/gi类/gi获取/gi泛型/gi类型/gi
1./nz再/d使用/gijdbctemplate/nz时有/d个/qquery/nz(/nzsql/gi,/nz new rowmapperuser/nz(/nz)/nz{/nz}/nz /x）/w方法/gi，/w返回/v实体/n对象/gi列表/vi;/nz想到/v这样/rzv会/v有/vyou很/d多/a重复/gi代码/gi，/w看到/vspring/gi提供/v了/ule但/c其/rz要求/n数据库/gi字段/gi和/cc实体类/nz字段/gi要/v完全一致/i;/nz想要/v数据库/gi字段/gi和/cc实体类/nz字段/gi不同/a的话/udh，/w可以/v用/p注解/n去/vf注释/gi数据库/gi字段/gi，/w通过/p反射/gi获取/gi所有/b注解/n。/w自己/rr写泛/nz型/k的/ude1rowmapper/nz借口/n实现/gi类/gi，/w获得/v泛型/gi方法/gi的/ude1泛型/gi是/vshi关键步骤/nz，/w得到/v泛型/gi类型/gi才/d可以/v通过/p反射/gi得到/v想要/v的/ude1实体类/nz小/a例子/gi：/w实现/gi类/gi：/w测试/gi类/gi：/w再/d测试过程/gi中/f，/w不能/v从/p当前/t类/gi中/f直接/ad或/c得当/a前类/nz的/ude1泛型/gi，/w而是/c获得/v了/ule父类/nz的/ude1泛型/gi,/nz从而/c通过/p继承/gi来/vf获得/v自己/rr的/ude1泛型/gi类/gi，/w因为/c继承/gi的/ude1父类/nz已经/d确定/v了/ule泛型/gi类型/gi了/ule，/w从/p当前/t类/gi中/f获取/gi泛型/gi类型/gi的/ude1方法/gi没有/v找到/v，/w不/d知道/v跟/pjava/gi泛型/gi擦除/gi有/vyou没/d有关/vn，/w有/vyou知道/v的/ude1请/v告知/v