#数据结构/gi与/cc算法/gi（/w冒泡排序/gi算法/gi）/w
  /x冒泡排序/gi是/vshi常见/a的/ude1排序算法/gi之一/rz，/w经典/gi，/w难度/n不大/d，/w最坏/gi的/ude1时间复杂度/gi为/pt/nz(/nzn/nz?/nz)/nz，/w最好/d的/ude1时间复杂度/gi为/pt/nz(/nzn/nz)/nz。/w  /x两/nz层/gi循环/gi，/w要/v处理/vn的/ude1数据/gi有/vyoun/nz个/q，/w就要/d判断/gin/nz-/nz1/nz次/qv，/w外层/n循环/gi就是/v整个/b数组/gi的/ude1判断/gi次数/gi。/w内层/nz循环/gi实现/gi每次/r将/d最大/gm的/ude1放到/v最后/f的/ude1位置/gi，/w冒泡/vi冒泡/vi，/w说白了/l就是/v最重/a的/ude1放/v最后/f，/w轻/a的/ude1浮/v到/v最/d前面/f。/w  /x用/pc/nz实现/gi：/w  /x除非/c是/vshi大神/nz，/w否则/c谁/ry也/d不/d可能/v没/d见过/v冒泡/vi算法/gi就/d写出/v冒泡/vi算法/gi出来/vf，/w自行/d单步/nz调试/gi跟踪/vn，/w每次/r记录/gi下/fi/nz与/ccj/nz两/nz个/q循环/gi变量/gi的/ude1，/w自然/n就/d明白/v了/ule。/w冒泡/vi算法/gi的/ude1精髓/n在于/v第二层/nz的/ude1判断/gi条件/n，/wjasize/nz-/nzi/nz-/nz1/nz，/w有/vyou了/ule这个/rz条件/n，/w当/p完成/v第一次/nz排序/gi的/ude1时候/n，/w最大/gm的/ude1已经/d找到/v并且/c放到/v了/ule最后/f的/ude1位置/gi，/w已经/d不/d需要/v再/d跟/p这个/rz数/n进行/vn比较/gi，/w所以/c就/d忽略/v了/ule这个/rz下标/gi。/w  /x用/pjava实现/gi：/w /x