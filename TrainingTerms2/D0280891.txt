#三种/nz工厂模式/gi区别/gi总结/gi
工厂模式/gi分为/v三种/nz：/w简单工厂/gi、/w工厂模式/gi和/cc抽象工厂模式/gi。/w三者/r之间/f存在/v哪些/ry异同/gi呢/y？/w先/d分别/d看看/v各个/rz模式/gi的/ude1特点一/nz、/w简单工厂模式/gi：/w实现/gi了/ule算法/gi和/cc界面/gi的/ude1分离/vi，/w也/d就是/v将/d业务逻辑/gi和/cc界面/gi逻辑/n分开/vi了/ule，/w降低/v了/ule耦合度/gp。/w算法/gi的/ude1封装/gi：/w定义/gi一个/mq抽象/gi的/ude1算法/gi接口/gi，/w提供/v不同/a算法/gi的/ude1公共/b接口/gi方法/gi。/w其他/rzv具体/a算法/gi继承/gi这个/rz抽象类/gi，/w并/cc实现/gi具体/a的/ude1算法/gi。/w简单工厂/gi类/gi：/w作为/p一个/mq独立/a的/ude1类/gi，/w实现/gi了/ule针对/gi不同/a的/ude1算法/gi进行/vn实例化/gi。/w简单工厂/gi的/ude1uml/gi图/gi：/w二/nz、/w工厂模式/gi：/w定义/gi一个/mq用于/v创建对象/n的/ude1接口/gi，/w让子/nz类/gi决定/v实例化/gi哪/ry一个/mq类/gi。/w遵循/gi了/ule开放/gi―/w封闭/gi原则/gi。/w工厂模式/gi的/ude1uml/gi图/gi：/w简单工厂/gi与/cc工厂模式/gi的/ude1共同/d优点/gi：/w都/d集中/v封装/gi了/ule对象/gi的/ude1创建/gi，/w使得/vi要/v更换/v对象/gi时/qt不/d需要/v做/v大/a的/ude1改动/vn就/d可实现/nz，/w降低/v了/ule客户端程序/n与/cc产品/gi对象/gi的/ude1耦合/vn。/w工厂模式/gipk/nz简单工厂模式/gi：/w1/nz、/w工厂模式/gi的/ude1优点/gi：/w工厂模式/gi是/vshi简单工厂模式/gi的/ude1进一步/d抽象/gi和/cc推广/gi。/w它/rr遵循/gi了/ule“/w开放/gi―/w封闭/gi”/w原则/gi。/w2/nz、/w简单工厂模式/gi的/ude1优点/gi：/w简单工厂模式/gi最大/gm的/ude1优点/gi在于/v工厂/gi类/gi中/f包含/v了/ule必要/a的/ude1逻辑/n判断/gi，/w根据/p客户端/gi的/ude1选择/gi条件/n动态/gi实例化/gi相关/vn的/ude1类/gi，/w对于/p客户端/gi来说/uls，/w去除/v了/ule与/cc具体/a产品/gi的/ude1依赖/v。/w3/nz、/w工厂模式/gi的/ude1缺点/gi：/w工厂方法/gi把/pba简单工厂/gi的/ude1内部/f逻辑/n判断/gi转移/v到/v了/ule客户端/gi代码/gi来/vf执行/v；/w每/rz增加/v一产品/nz就要/d增加/v一个/mq产品/gi工厂/gi的/ude1类/gi，/w增加/v了/ule额外/b的/ude1开发量/n。/w4/nz、/w简单工厂/gi的/ude1缺点/gi：/w是/vshi没有/v遵守/v开放/gi―/w封闭/gi原则/gi。/w所谓/v的/ude1“/w开放-封闭/nz”/w原则/gi就是/v开放/gi接口/gi，/w封闭/gi修改/gi。/w如果/c将来/t需要/v添加/gi一个/mq开方/vi的/ude1算法/gi，/w那么/c，/w在/p简单工厂模式/gi中/f，/w就/d必须/d在/p简单工厂/gi类/gi中/f添加/gi相应/vi的/ude1判断/gi语句/gi！/w另外/c，/w在/p简单工厂/gi类/gi中/f利用/v了/uleswitch/nz语句/gi，/w这/rzv对/p程序/gi的/ude1扩展/gi本身/rz就/d不/d不利。三/nz、/w抽象工厂模式/gi：/w提供/v一个/mq创建/gi一系列/b相关/vn或/c相互依赖/nz对象/gi的/ude1接口/gi，/w而/cc无需/v指定/v它们/rr具体/a的/ude1类/gi。/wuml结构图/gi：/w工厂模式/gi和/cc抽象工厂/gi的/ude1区别/gi：/w只有/c一个/mquser/gi类/gi和/ccuser/gi操作/gi类/gi的/ude1时候/n，/w只/d需要/v工厂方法模式/gi；/w但/c数据库/gi中/f有/vyou很/d多/a的/ude1表/n，/w而/ccsql/gi和/ccaccess/nz又是/c两/nz大/a不同/a的/ude1分类/gi，/w所以/c就/d延伸/v到/v了/ule抽象工厂模式/gi抽象工厂模式/gi的/ude1优点/gi：/w1/nz、/w易于/vd交换/gi产品/gi系列/n，/w由于/p具体/a工厂/gi类/gi，/w在/p一个/mq应用程序/nz中/f只/d需要/v在/p初始化/v的/ude1时候/n出现/v一次/nz，/w这/rzv就/d使得/vi改变/v一个/mq应用/gi的/ude1具体/a工厂/gi变得/vi非常容易/l，/w它/rr只需/v改变/v具体/a工厂/gi即可/v使用/gi不同/a的/ude1产品/gi配置/gi。/w2/nz、/w它/rr让/v具体/a的/ude1创建/gi实例/gi过程/gi与/cc客户端/gi分离/vi，/w客户端/gi是/vshi通过/p他们/rr的/ude1抽象/gi接口/gi操纵/gi实例/gi，/w产品/gi的/ude1具体/a类名/n也/d被/pbei具体/a工厂/gi的/ude1实现/gi分离/vi，/w不会/v出现/v在/p客户端/gi代码/gi中/f。/w抽象/gi模式/gi的/ude1缺点/gi：/w1/nz、/w抽象/gi模式/gi虽然/c便于/v两/nz数据库/gi之间/f的/ude1切换/vn，/w但是/c不/d便于/v增加/v需求/gi功能/gi。/w2/nz、/w如果/c有/vyou100/nz个/q调用/gi数据库/gi访问/gi的/ude1类/gi，/w就/d需要/v多/a次/qv实例化/gi100/nz此/rzs具体/a工厂/gi类/gi。/w抽象工厂模式/gi、/w反射/gi以及/cc配置文件/gi：/w反射/gi方法/gi的/ude1实质/gi是/vshi在/p对象/gi实例化/gi的/ude1时候/n传/v引用/gi，/w将/d程序/gi由/p编译/gi时/qt转为/gi运行/gi时/qt，/w通过/p字符串/gi变量/gi来/vf处理/vn，/w去除/v了/ule、/wswitch/nz判断/gi的/ude1麻烦/an。/w但是/c如果/c数据库/gi在/p更换/v时/qt，/w还/d需要/v去/vf修改/gi程序/gi（/w字符串/gi的/ude1）/w重/a编译/gi。/w通过/p添加/gi配置文件/gi可以/v解决/v更改/gidataaccess/nz的/ude1问题/gi。/w