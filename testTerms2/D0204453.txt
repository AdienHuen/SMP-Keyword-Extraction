#树/gi查找/gi（/w一/nz）/w二叉/b查找/gi树/gi
转/v自/p：/w /x感谢/v作者/nnt /x一直/d很/d想/v写/v一个/mq关于/p树/gi结构/gi的/ude1专题/n，/w再/d一个/mq就是/v很/d多/a初级/b点/gi的/ude1码/v农会/n认为/v树/gi结构/gi无用论/l，/w其实/d归根到底/dl还是/c不/d清楚/a树/gi的/ude1实际/n用途/n。/w一/nz：/w场景/gi：/w1/nz：/w现状/gi  /x前/f几天/nz我/rr的/ude1一个/mq大学/gi同学/n负责/v的/ude1网站/gi出现/v了/ule严重/a的/ude1性能/gi瓶颈/gi，/w由于/p业务/gi是/vshi写入/gi和/cc读取/gi都/d是/vshi密集型/gi，/w如果/c做/v缓存/gi，/w时间/gi间隔/n也/d只能/v在/p30/nzs/nz左右/f，/w否则/c就/d会/v引起/v客户/n纠纷/n，/w所以/c同学/n也/d就/d没有/v做/v缓存/gi，/w通过/p测试/gi发现/v慢/a就/d慢/a在/p数据读取/gi上面/f，/w总共/d需要/v10/nzs/nz，/w天啊/nz.../w原来/d首页/gi的/ude1加载/gi关联/vn到/v了/ule4/nz张/q表/n，/w而且/c表/n数据/gi中/f最多/ad的/ude1在/p10/nzw/nz条/q以上/f，/w可以/v想象/v4/nz张/q巨大/a表/n的/ude1关联/vn，/w然后/c就是/v排序/gi范围/n查找/gi等等/udeng相关/vn的/ude1条件/n，/w让/v同学/n抓狂/nz。/w2/nz：/w我/rr个人/n的/ude1提供/v解决方案/gi①/nz /x读取/gi问题/gi  /x既然/c不能/v做/v缓存/gi，/w那/rzv没/d办法/gi，/w我们/rr需要/v自己/rr维护/gi一套/nz”/w内存数据库/gi“/w，/w数据/gi如何/ryv组织/gi就/d靠/v我们/rr的/ude1算法/gi功底/n了/ule，/w比如/v哈希/nrf适合/v等于/v性/ng的/ude1查找/gi，/w树/gi结构/gi适合/v”/w范围/n查找/gi“/w，/wlucene/nz适合/v字符串/gi的/ude1查找/gi，/w我们/rr在/p添加/gi和/cc更新/gi的/ude1时候/n同时/c维护/gi自己/rr的/ude1内存数据库/gi，/w最终/d杜绝/v表/n关联/vn，/w老同学/nz，/w还是/c先/d应急/gi，/w把/pba常用/a的/ude1表/n灌倒/nz内存/gi，/w如果/c真/a想/v项目/gi好/a的话/udh，/w改/v架构/gi吧/y.../w②/nz /x添加/gi问题/gi /x或许/d你/rr的/ude1add/nz操作/gi还/d没有/v达到/v瓶颈/gi这一步/nz，/w如果/c真的/d达到/v了/ule那/rzv就/d看/v情况/n来/vf进行/vn”/w表切/nz分“/nz，/w”/w数据库/gi切分/v“/w吧/y，/w让/v用户/gi的/ude1add/nz或者/cupdate/gi操作/gi分流/gi，/w虽然/c做/v起来/vf很复杂/nz，/w但是/c没/d办法/gi，/w总比/j用户/gi纠纷/n强/a吧/y，/w可/v对/p.../w二/nz：/w二叉/b查找/gi树/gi  /x正式/ad切入/v主题/n，/w从/p上面/f的/ude1说明/v我们/rr知道/v了/ule二叉树/gi非常/d适合于/v范围/n查找/gi，/w关于/p树/gi的/ude1基本/a定义/gi，/w这里/rzs我/rr就/d默认/v大家/rr都/d知道/v，/w我/rr就/d直接/ad从/p查找/gi树/gi说起/v了/ule。/w1/nz：/w定义/gi /x查找/gi树/gi的/ude1定义/gi非常简单/nz，/w一句话/l就是/v左孩子/gi比/p父/ng节点/gi小/a，/w右/f孩子/gi比/p父/ng节点/gi大/a，/w还有/v一个/mq特性/gi就是/v”/w中/f序/n遍/qv历“/nz可以/v让/v结点/gm有序/gi。/w2/nz：/w树/gi节点/gi为了/p具有/v通用性/n，/w我们/rr定义/gi成/v泛型/gi模板/gi，/w在/p每个/r结点/gm中/f增加/v一个/mq”/w数据/gi附加/vn域”/nz。/w3/nz：/w添加/gi /x根据/p查找/gi树/gi的/ude1性质/n我们/rr可以/v很/d简单/a的/ude1写出/vadd/nz的/ude1代码/gi，/w一个一个/nz的/ude1比/p呗/y，/w最终/d形成/v的/ude1效果图/nz如下/vi这里/rzs存在/v一个/mq“/w重复/gi节点/gi”/w的/ude1问题/gi，/w比如说/vl我/rr在/p最后/f的/ude1树/gi中/f再/d插入/gi一个/mq元素/gi为/p15/nz的/ude1结点/gm，/w那么/c此时/r该/rz怎么办/ryv，/w一般/ad情况下/nz，/w我们/rr最好/d不要/d在/p树/gi中/f再/d追加/v一个/mq重复/gi结点/gm，/w而是/c在/p“/w重复/gi节点/gi的/ude1附加/vn域/ng中/f进行/vn”/w1/nz“/w操作/gi。/w4/nz:/w范围/n查找/gi  /x这个/rz才/d是/vshi我们/rr使用/gi二叉树/gi的/ude1最终/d目的/gi，/w既然/c是/vshi范围/n查找/gi，/w我们/rr就/d知道/v了/ule一个/mq”/wmin/nz“/w和/cc”/wmax/nz“/w，/w其实/d实现/gi起来/vf也/d很/d简单/a，/w第一步/nz：/w我们/rr要/v在/p树/gi中/f找到/vmin/nz元素/gi，/w当然/dmin/nz元素/gi可能/v不存在/ns，/w但是/c我们/rr可以/v找到/vmin/nz的/ude1上界/n，/w耗费/v时间/gi为/po/nz(/nzlogn/nz)/nz。/w第二步/nz：/w从/pmin/nz开始/v我们/rr中/f序/n遍历/gi寻找/vmax/nz的/ude1下界/n。/w耗费/v时间/gi为/pm/nz。/wm/nz也/d就是/v匹配/gi到/v的/ude1个数/n。/w最后/f时间复杂度/gi为/pmlogn/nz，/w要/v知道/v普通/a的/ude1查找/gi需要/vo/nz(/nzn/nz)/nz的/ude1时间/gi，/w比如/v在/p21/nz亿/nz的/ude1数据/gi规模/gi下/f，/w匹配/gi的/ude1元素/gi可能/v有/vyou30/nz个/q，/w那么/c最后/f的/ude1结果/n也/d就是/v秒杀/v和/cc几/d个/q小时/n甚至/d几天/nz的/ude1巨大/a差异/n，/w后面/f我会/r做/v实验/gi说明/v。/w5/nz：/w删除/gi /x对于/p树/gi来说/uls，/w删除/gi是/vshi最/d复杂/a的/ude1，/w主要/b考虑/v两/nz种/q情况/n。/w1/nz单/b孩子/gi的/ude1情况/n  /x这个/rz比较简单/l，/w如果/c删除/gi的/ude1节点/gi有/vyou左孩子/gi那/rzv就/d把/pba左孩子/gi顶上去/v，/w如果/c有/vyou右/f孩子/gi就/d把/pba右/f孩子/gi顶上去/v，/w然后/c打完/v收工/vi。/w2/nz左右/f都/d有/vyou孩子/gi的/ude1情况/n。/w  /x首先/d可以/v这么/rz想象/v，/w如果/c我们/rr要/v删除/gi一个/mq数组/gi的/ude1元素/gi，/w那么/c我们/rr在/p删除/gi后会/n将/d其/rz后面/f的/ude1一个/mq元素/gi顶/v到/v被删除/gi的/ude1位置/gi，/w如/v图/gi   /x那么/c二叉树/gi操作/gi同样/d也/d是/vshi一样/uyy，/w我们/rr根据/p”/w中/f序/n遍/qv历“/nz找到/v要/v删除/gi结点/gm的/ude1后/f一个/mq结点/gm，/w然后/c顶上去/v就行了/l，/w原理/gi跟/p数组/gi”/w一样/uyy一样/uyy的/ude1。/w同样/d这里/rzs也/d有/vyou一个/mq注意/v的/ude1地方/n，/w在/padd/nz操作/gi时/qt，/w我们/rr将/d重复/gi元素/gi的/ude1追加/v到/v了/ule“/w附加/vn域”/nz，/w那么/c在/p删除/gi的/ude1时候/n，/w就/d可以/v先/d判断/gi是不是/v要/v“-/nz1/nz”/w操作/gi而/cc不是/c真正/d的/ude1删除/gi节点/gi，/w其实/d这里/rzs也/d就是/v“懒/nz删除/gi”/w，/w很/d有意思/al。/w三/nz：/w测试/gi /x假如/c现在/t我们/rr有/vyou一/nz张/quser/gi表/n，/w我/rr要/v查询/gi2012/nz//nz7/nz//nz30/nz /x4/nz:/w30/nz:/w00/nz到/v2012/nz//nz7/nz//nz30/nz /x4/nz:/w40/nz:/w00/nz这个/rz时间段/gi登陆/vi的/ude1用户/gi，/w我/rr在/ptxt/gi中/f生成/v一个/mq33/nzw/nz的/ude1userid/nz和/cctime/nz的/ude1数据/gi，/w看看/v在/p33/nzw/nz的/ude1情况下/nz读取/gi效率/gi如何/ryv.../wview code/nz比/p普通/a的/ude1dictionary/nz效率/gi还/d仅仅/d是/vshi快/a11/nz倍/q，/w从/p数量级/n来说/uls还/d不是/c非常/d明显/a，/w为什么/ryv说/v不是/c非常/d明显/a，/w这/rzv是因为/c普通/a的/ude1查找/gi树/gi的/ude1时间复杂度/gi不是/c严/a的/ude1log/gi(/nzn/nz)/nz，/w在/p最坏/gi的/ude1情况下/nz会/v出现/v“链/nz表”/nz的/ude1形式/gi，/w复杂度/gi退化/vi到/vo/nz(/nzn/nz)/nz，/w比如/v下图/n。/w  /x不过/c总会/nis有/vyou解决办法/n的/ude1，/w下/f一篇/nz我们/rr继续/v聊/v如何/ryv旋转/gi，/w保持/v最坏/gi复杂度/gi在/po/nz(/nzlogn/nz)/nz。/w