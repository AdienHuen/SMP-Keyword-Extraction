#Memcache and Mongodb/nz
原文/n作者/nnt：/w博客/gi园/ng原文/n地址/gi：/w的/ude1优势/gi我/rr觉得/v总结/gi下来/vf主要/b体现/v在/p：/w1/nz）/w /x分布式/gi。/w可以/v由/p10/nz台/q拥有/v4g/gi内存/gi的/ude1机器/gi，/w构成/v一个/mq40/nzg/nz的/ude1内存/gi池/ng，/w如果/c觉得/v还/d不/d够大/nz可以/v增加/v机器/gi，/w这样/rzv一个/mq大/a的/ude1内存/gi池/ng，/w完全/ad可以/v把/pba大部分/n热点/gi业务/gi数据保存/gi进去/vf，/w由/p内存/gi来/vf阻挡/v大部分/n对/p数据库/gi读/v的/ude1请求/gi，/w对/p数据库/gi释放/gi可观/a的/ude1压力/n。/w2/nz）/w /x单点/n。/w如果/cweb服务器/gi或/capp/gi服务器/gi做/v负载均衡/gi的话/udh，/w在/p各自/rr内存/gi中/f保存/gi的/ude1缓存/gi可能/v各不相同/l，/w如果/c数据/gi需要/v同步/gi的话/udh，/w比较/gi麻烦/an（/w各自/rr自己/rr过期/gi，/w还是/c分发/v数据/gi同步/gi？/w）/w，/w即使/c数据/gi并不需要/l同步/gi，/w用户/gi也/d可能/v因为/c数据/gi的/ude1不/d一致/a而/cc产生/v用户/gi体验/v上/f的/ude1不/d友好/a。/w3/nz）/w /x性能/gi强/a。/w不用/d怀疑/v和/cc数据库/gi相比/vi确实/ad是/vshi，/w根源/n上/f还是/c内存/gi的/ude1读写/gi和/cc磁盘/gi读写/gi效率/gi上/f几个/nz数量级/n的/ude1差距/n。/w有的/rz时候/n我们/rr在/p抱怨/v数据库/gi读写/gi太差/d的/ude1情况下/nz可以/v看看/v磁盘/gi的/ude1io/gi，/w如果/c确实/ad是/vshi瓶颈/gi的话/udh装/v啥/ry强劲/a的/ude1数据库/gi估计/gi也/d档/ng不了/v，/w强/a不强/v无非/d是/vshi这个/rz数据库/gi多少/ry充分/ad的/ude1利用/v了/ule内存/gi。/w但是/c也/d不/d太/d建议/gi在/p任何/rz情况下/nz使用/gimemcache/gi替代/v任何/rz缓存/gi：/w1/nz）/w /x如果/cvalue/nz特别/d大/a，/w不/d太/d适合/v。/w因为/c在/p默认/v编译/gi下/fmemcache/gi只/d支持/v1/nzm/nz的/ude1value/nz（/wkey/gi的/ude1限制/vn到/v不是/c最大/gm的/ude1问题/gi）/w。/w其实/d从/p实践/gi的/ude1角度/n来说/uls也/d不/d建议/gi把/pba非常/d大/a的/ude1数据保存/gi在/pmemcache/gi中/f，/w因为/c有序/gi列化/nz反序/nz列化/nz的/ude1过程/gi，/w别/d小看/v它/rr消耗/gi的/ude1cpu/gi。/w说/v到/v这个/rz就要/d提/v一/nz下/f，/w我/rr一直/d觉得/vmemcache/gi适合/v面向/v输出/gi的/ude1内容/gi缓存/gi，/w而/cc不是/c面向/v处理/vn的/ude1数据/gi缓存/gi，/w也/d就是/v不/d太/d适合/v把/pba大块/n数据/gi放进去/v拿出/v来/vf处理/vn之后/f再放/nz进去/vf，/w而是/c适合/v拿出/v来/vf就/d直接/ad给/p输出/gi了/ule，/w或/c是/vshi拿出/v来/vf不/d需要/v处理/vn直接/ad用/p。/w2/nz）/w /x如果/c不/d允许/v过期/gi，/w不/d太/d适合/v。/wmemcache/gi在/p默认/v情况下/nz最大/gm30/nz天/qt过期/gi，/w而且/c在/p内存/gi达到/v使用/gi限制/vn后/f它/rr也/d会/v回收/vn最少/d使用/gi的/ude1数据/gi。/w因此/c，/w如果/c我们/rr要/v把/pba它/rr当作/vstatic/gi变量/gi的话/udh就要/d考虑到/v这个/rz问题/gi，/w必须/d有/vyou重新/d初始化/v数据/gi的/ude1过程/gi。/w其实/d应该/v这么/rz想/v，/w既然/c是/vshi缓存/gi就是/v拿到/v了/ule存/v起来/vf，/w如果/c没有/v必定/d有/vyou一个/mq重新/d获取/gi重新/d缓存/gi的/ude1过程/gi，/w而/cc不是/c想着/v它/rr永远/d存在/v。/w在/p使用/gimemcache/gi的/ude1过程/gi中/f当然/d也/d会/v有/vyou一/nz些/q问题/gi或者说/c最佳/z实践/gi：/w1/nz）/w /x清除/v部分/n数据/gi的/ude1问题/gi。/wmemcache/gi只是/d一个/mqkey/gi//nzvalue/nz的/ude1池/ng，/w一个/mq公共汽车/nz谁/ry都/d可以/v上/f。/w我/rr觉得/v对于/p类/gi的/ude1公共资源/gi，/w如果/c用/p的/ude1人/n都/d按照/p自己/rr的/ude1规则/gi来/vf的话/udh很容易/nz出现/v问题/gi。/w因此/c，/w最好/d在/pkey/gi的/ude1规范/gi上/f上/f使用/gi类/gi命名/v空间/n的/ude1概念/gi，/w /x每/rz一个/mq用户/gi都/d能/v很/d明确/a的/ude1知道/v某/rz一块/s功能/gi的/ude1key/gi的/ude1范围/n，/w或者说/c前缀/n。/w带来/v的/ude1好处/gi是/vshi我们/rr如果/c需要/v清空/nz的话/udh可以/v根据/p这个/rz规范/gi找到/v我们/rr自己/rr的/ude1一/nz批/qkey/gi然后/c再/d去/vf清空/nz，/w而/cc不是/c清空/nz所有/b的/ude1。/w当然/d有人/r是/vshi采用/v版本升级/gi的/ude1概念/gi，/w老/a的/ude1key/gi就让/v它/rr过去/vf吧/y，/w到时候/l自然/n会/v清空/nz，/w这/rzv也/d是/vshi一种/nz办法/gi。/w不过/ckey/gi有/vyou规范/gi总是/d有/vyou好处/gi的/ude1，/w在/p统计/gi上/f也/d方便/a一点/m。/w2/nz）/w value/nz的/ude1组织/gi问题/gi。/w也/d就是说/c我们/rr存/v的/ude1数据/gi的/ude1粒度/gi，/w比如/v要/v保存/gi一个/mq列表/vi，/w是/vshi一个/mq保存/gi在/p一个键/nz还是/c统一/vn保存/gi为/p一个键/nz，/w这/rzv取决于/v业务/gi。/w如果/c粒度/gi很小/a的话/udh最好/d是/vshi在/p获取/gi的/ude1时候/n能/v批量/d获取/gi，/w在/p保存/gi的/ude1时候/n也/d能/v批量/d保存/gi。/w对于/p跨/v网络/gi的/ude1调用/gi次数/gi越少/nz越好/d，/w可以/v想一下/nz，/w如果/c一个/mq页面/gi需要/v输出/gi100/nz行/ng数据/gi，/w每/rz一个/mq数据/gi都/d需要/v获取/gi一次/nz，/w一个/mq页面/gi进行/vn上/f百次/nz连接/gi这个/rz性能/gi会/v不会/v成/v问题/gi。/w那么/cmemcache/gi主要/b用/p在/p哪些/ry功能/gi上/f呢/y？/w其实/d我/rr觉得/v平时/t能/v想到/v在/p内存/gi中/f做/v缓存/gi的/ude1地方/n我们/rr都/d可以/v考虑/v下/f是不是/v可以/v去/vf适用/vi分布式/gi缓存/gi，/w但是/c主要/b的/ude1用途/n还是/c用来/v在/p前端/gi或/c中部/f挡/v一/nz下/f读/v的/ude1需求/gi来/vf释放/giweb服务器/giapp/gi服务器/gi以及/ccdb/nz的/ude1压力/n。/wmongodbmongodb/nz是/vshi一/nz款/q比较/gi优良/z的/ude1非关系型数据库/gi的/ude1文档/gi型/k的/ude1数据库/gi。/w它/rr的/ude1优势/gi主要/b体现/v在/p：/w1/nz）/w /x开源/gi。/w意味着/v即使/c我们/rr不/d去/vf改/v也/d可以/v充分/ad挖掘/gi它/rr，/wms sql/nz除了/p看/v那些/rz文档/gi，/w谁/ry又/d知道/v它/rr内部/f如何/ryv实现/gi。/w2/nz）/w /x免费/vd。/w意味着/v我们/rr可以/v在/p大量/m垃圾/n服务器/gi上/f装大量/nz的/ude1实例/gi，/w即使/c它/rr性能/gi不怎么/vl高/a，/w也/d架不住/v非常/d多/a的/ude1点/gi啊/y。/w3/nz）/w /x性能/gi高/a。/w其它/rz没/d比较/gi过/uguo，/w和/ccms sql/nz相比/vi，/w同样/d的/ude1应用/gi（/w主要/b是/vshi写/v操作/gi）/w一个/mq撑/v500/nz用户/gi就/d挂/v了/ule，/w一个/mq可以/v撑到/v2000。/nz在/p数据量/n上到/v百万之后/nz，/w即使/c没/d索引/gi，/wms sql/nz的/ude1插入/gi性能/gi下降/vi的/ude1也/d一塌糊涂/gi。/w其实/d任何事物/n都/d有/vyou相对性/n的/ude1，/w在/p变得复杂/nz变得/vi完善/v了/ule之后/f会/v牺牲/v一/nz部分/n的/ude1性能/gi，/wms sql/nz体现/v的/ude1是/vshi非常/d强/a的/ude1安全性/gi数据完整性/gi，/w这/rzv点/gi是/vshimongodb/gi办不到/v的/ude1。/w4/nz）/w /x配置/gi简单/a并且/c灵活/a。/w在/p生产/gi环境/n中/f对/p数据库/gi配置/gi故障/gi转移/v群集/n和/cc读写/gi分离/vi的/ude1数据库/gi复制/gi是/vshi很/d常见/a的/ude1需求/gi，/wms sql/nz的/ude1配置/gi繁琐/a的/ude1步骤/gi还是/c很/d恐怖/a的/ude1，/w而/ccmongodb/gi可以/v在/p五分钟/nz之内/f配置/gi自己/rr所/usuo需要/v的/ude1故障/gi转移/v组/n，/w读写/gi分离/vi更是/d只/d需要/v一分钟/nz。/w灵活性/gi体现/v在/p，/w我们/rr可以/v配置/gi一个/mqm/nz一个/mqs/nz，/w两/nz个/qm/nz一个/mqs/nz（/w两/nz个/qm/nz写入/gi的/ude1数据/gi会/v合并/gi到/vs/nz上供/v读取/gi）/w，/w一个/mqm/nz两/nz个/qs/nz（/w一个/mqm/nz写入/gi的/ude1数据/gi在/p两/nz个/qs/nz上有/v镜像/gi）/w，/w甚至/d是/vshi多/a个/qm/nz多/a个/qs/nz（/w理论上/nz可以/v创建/gi10/nz个/qm/nz，/w10/nz个/qs/nz，/w我们/rr只/d需要/v通过/p轮询/nz方式/n随便/ad往/p哪个/rym/nz上/f写/v，/w需要/v读/v的/ude1时候/n也/d可以/v轮训/vi任意/d一个/mqs/nz，/w当然/d我们/rr要/v知道/v不/d可能/v保证/v在/p同一时间/nz所有/b的/ude1s/nz都/d有/vyou一致/a的/ude1数据/gi）/w。/w那么/c也/d可以/v配置/gi两/nz个/qm/nz的/ude1对/p作为/p一套/nz故障/gi转移/v群集/n，/w然后/c这样/rzv的/ude1群集/n配置/gi两/nz套/q，/w再/d对应/vi两/nz个/qs/nz，/w也/d就是/v4/nz个/qm/nz对应/vi2/nz个/qs/nz，/w保证/vm/nz点/gi具有/v故障/gi转移/v。/w5/nz）/w /x使用/gi灵活/a。/w在/p之前/f的/ude1文章/gi中/f我/rr提到/v甚至/d可以/v通过/psql/gi到/vjs/gi表达式/gi的/ude1转换/gi让/vmongodb/gi支持/vsql语句/gi的/ude1查询/gi，/w不管/c怎么说/nzmongodb/gi在/p查询/gi上/f还是/c很/d方便/a的/ude1。/w之前/f也/d说/v过/uguo了/ule，/w并/cc不是/c所有/b数据库/gi应用/gi都/d使用/gi采用/vmongodb/gi来/vf替代/v的/ude1，/w它/rr的/ude1主要/b缺点/gi是/vshi：/w1/nz）/w /x开源/gi软件/gi的/ude1特点/n：/w更新快/l，/w应用/gi工具/gi不/d完善/v。/w由于/p更新快/l，/w我们/rr的/ude1客户端/gi需要/v随着/p它/rr的/ude1更新/gi来/vf升级/vi才能/n享受/v到/v一/nz些/q新功能/nz，/w更新快/l也/d意味着/v很可能/nz在/p某/rz一/nz阶段/gi会/v缺乏/v某个/rz重要/a功能/gi。/w另外/c我们/rr知道/vms sql/nz在/pdev/nz//nzdba/gi//nzadm/nz多/a个/q维度/gi都/d提供/v了/ule非常/d好/a的/ude1gui/nz工具/gi对/p数据库/gi进行/vn维护/gi。/w而/ccmongodb/gi虽然/c提供/v了/ule一/nz些/q程序/gi，/w但是/c并/cc不是/c非常/d友好/a。/w我们/rr的/ude1dba/gi可能会/nz很/d郁闷/a，/w去/vf优化/gimongodb/gi的/ude1查询/gi。/w2/nz）/w /x操作/gi事务/gi。/wmongodb/gi不/d支持/v内建/ns的/ude1事务/gi（/w没有/v内建/ns事务/gi不/d意味着/v完全/ad不能/v有/vyou事务/gi的/ude1功能/gi）/w，/w对于/p某些/rz应用/gi也/d就/d不/d适合/v。/w不过/c对于/p大部分/n的/ude1互联网/gi应用/gi来说/uls并不/d存在/v这个/rz问题/gi。/w在/p使用/gimongodb/gi的/ude1过程/gi中/f主要/b遇到/v下面/f的/ude1问题/gi：/w1/nz）/w /x真正/d的/ude1横向/n扩展/gi？/w在/p使用/gimemcache/gi的/ude1过程/gi中/f我们/rr已经/d体会/gi到/v这种/r爽/ag了/ule，/w基本/a可以/v无限/b的/ude1增加/v机器/gi来/vf横向/n扩展/gi，/w因/p为什么/ryv，/w因为/c我们/rr是/vshi通过/p客户端/gi来/vf决定/v键/n保存/gi在/p那个/rz实例/gi上/f，/w在/p获取/gi的/ude1时候/n也/d很/d明确/a它/rr在/p哪个/ry实例/gi上/f，/w即使/c是/vshi一次性/d获取/gi多/a个/q键/n，/w也/d是/vshi同样/d。/w而/cc对于/p数据库/gi来说/uls，/w我们/rr通过/p各种各样/bl的/ude1方式/n进行/vn了/ulesharding/nz，/w不说/c其它/rz的/ude1，/w在/p查询/gi的/ude1时候/n我们/rr根据/p一定/b的/ude1条件/n获取/gi批量/d的/ude1数据/gi，/w怎么样/ryv去/vf处理/vn？/w比如/v我们/rr按照/p用户/giid/nz去/vf分片/gi，/w而/cc查询/gi根本/a不在乎/v用户/giid/nz，/w在乎/v的/ude1是/vshi用户/gi的/ude1年龄/n和/cc教育/vn程度/n，/w最后/f按照/p姓名/gi排序/gi，/w到/v哪里/rys去取/v这些/rz数据/gi？/w不管/c是/vshi基于/p客户端/gi还是/c基于/p服务端/nz的/ude1sharding/nz都/d是/vshi非常/d难做/v的/ude1，/w并且/c即使/c有/vyou了/ule自动化/gi的/ude1sharding/nz性能/gi不一定/nz能/v有/vyou保障/vn。/w最简单/nz的/ude1是/vshi尽量/d按照/p功能/gi来/vf分/qt，/w再/d下去/vf就是/v历史数据/gi的/ude1概念/gi，/w真正/d要/v做到/v实时/n数据/gi分散/a在/p各个/rz节点/gi，/w还是/c很/d困难/an。/w2/nz）/w /x多线程/gi，/w多/a进程/gi。/w在/p写入/gi速度/n达/v不到/v预期/gi的/ude1情况下/nz我们/rr多/a开/v几/d个/q线程/gi同时/c写/v，/w或者/c多/a开/v几/d个/qmongodb/gi进程/gi（/w同一/b机器/gi）/w，/w也/d就是/v多/a个/q数据库/gi实例/gi，/w然后/c向/p不同/a的/ude1实例/gi去/vf写/v。/w这样/rzv是否/v能/v提高/v性能/gi？/w很/d遗憾/gi，/w非常/d有限/a，/w甚至/d可以/v说/v根本/a不能/v提高/v。/w为什么/ryv使用/gimemcache/gi的/ude1时候/n多/a开/v线程/gi可以/v提高/v写入/gi速度/n？/w那/rzv是因为/c内存/gi数据交换/nz的/ude1瓶颈/gi我们/rr没/d达到/v，/w而/cc对于/p磁盘/gi来说/uls，/wio/gi的/ude1瓶颈/gi每秒/d那么/c几/d十兆/nz的/ude1是/vshi很容易/nz达到/v的/ude1，/w一旦/d达到/v这个/rz瓶颈/gi了/ule，/w无论是/c开/v多少/ry个/q进程/gi都/d无法/v提高/v性能/gi了/ule。/w还好/vmongodb/gi使用/gi内存/gi映射/gi，/w看到/v内存/gi使用/gi的/ude1多/a了/ule，/w其实/d我/rr对/p它/rr的/ude1信心/n又/d多/a了/ule一点/m（/w内存/gi占用/v多/a了/ule我/rr觉得/vcpu/gi更容易/nz让/v它/rr不/d闲着/v）/w，/w怕/v就/d怕/v某个/rzdb/nz不/d使用/gi什么/ry内存/gi，/w看着/vio/gi瓶颈/gi到/v了/ule，/w内存/gi和/cccpu/gi还是/c吃不饱/l。/wmemcache/gi和/ccmongodb/gi的/ude1配合/v其实/d有/vyou了/ulememcache/gi和/ccmongodb/gi我们/rr甚至/d可以/v让/v80%/nz以上/f的/ude1应用/gi摆脱/v传统/n关系型数据库/gi。/w我/rr能/v想到/v它们/rr其实/d可以/v互相配合/i弥补/v对方/n的/ude1不足/an：/wmemcache/gi适合/v根据/pkey/gi保存/givalue/nz，/w那么/c有的/rz时候/n我们/rr并不知道/l需要/v读取/gi哪些/rykey/gi怎么办/ryv呢/y？/w我/rr在/p想/v是不是/v可以/v把/pbamongodb/gi或/c说/v数据库/gi当作/v一个/mq原始数据/gi，/w这份/r原始数据/gi中/f分为/v需要/v查询/gi的/ude1字段/gi（/w索引/gi字段/gi）/w和/cc普通/a的/ude1数据/gi字段/gi两/nz部分/n，/w把/pba大量/m的/ude1非/b查询/gi字段/gi保存/gi在/pmemcache/gi中/f，/w小粒/nz度/qv保存/gi，/w在/p查询/gi的/ude1时候/n我们/rr查询数据库/n知道/v要/v获取/gi哪些/ry数据/gi，/w一般/ad查询/gi页面/gi也/d就/d显示/gi20/nz-/nz100/nz条/q吧/y，/w然后/c一次性/d从/pmemcache/gi中/f获取/gi这些/rz数据/gi。/w也/d就是说/c，/wmongodb/gi的/ude1读/v的/ude1压力/n主要/b是/vshi索引/gi字段/gi，/w而/cc数据/gi字段/gi只是/d在/p缓存/gi失效/vi的/ude1时候/n才/d有/vyou用/p，/w使用/gimemcache/gi挡住/v大部分/n实质/gi数据/gi的/ude1查询/gi。/w反过来说/c，/w如果/c我们/rr要/v清空/nzmemcache/gi中的/v数据/gi也/d知道/v要/v清空/nz哪些/rykey/gi。--------------------------------以上/nz为/p引用------------------------说/nz点/gi自己/rr的/ude1应用/gi吧/y：/wlucene/nz不/d清楚/a，/w还/d没/d来得及/v看/v。/wmongo/gi我们/rr一般/ad是从/vmysql/gi读取数据/n，/w然后/c根据/p业务/gi使用/gi最/d频繁/a的/ude1需求/gi，/w做成/v一个/mq数组/gi，/w然后/c定时/d写入/gi到/vmongo/gi里面/f去/vf。/w在/p网站/gi负载/gi最低/a的/ude1时间/gi，/w一般/ad是/vshi凌晨/t2/nz点/gi以后/f，/w设置/gi自动/d运行/gi去/vf跑/v缓存/gi。/w根据/p业务/gi的/ude1不同/a，/w跑/v缓存/gi的/ude1间隔/n也/d不/d一样/uyy。/w例如/v报价/vn一般/ad是/vshi1/nz小时/n一次/nz更新/gi，/w产品/gi参数/gi每天/r更新/gi1/nz次等/b。/w此外/c因为/c还有/vredis/gi的/ude1存在/v，/w大大/d减轻/v了/ule最后/fmysql/gi的/ude1压力/n。/w