#Android/gi图片/gi加载/gi优化--图片/nz缓存/gi
转载/v请/v注明/v出处/n：/w为什么/ryv要/v使用/gi内存/gi缓存/gi内存/gi缓存/gi：/w  /x内存/gi缓存/gi是/vshi指/v将/d已经/d赋值/v的/ude1对象/gi保存/gi在/p内存/gi中/f，/w当/p再次/d使用/gi的/ude1时候/n直接/ad去/vf内存/gi读取/gi，/w不再/d做/v重复/gi的/ude1创建/gi操作/gi。/w内存/gi缓存/gi的/ude1优势/gi：/w /x对象/gi的/ude1重复使用/l，/w不再/d去/vf创建对象/n，/w减少/v内存/gi消耗/gi，/w便于/v内存/gi的/ude1集中管理/nz。/w同时/c在/p需要/v读取/gi数据库/gi或者/c外存/n的/ude1时候/n，/w使用/gi内存/gi缓存/gi将/d大大减少/i时间/gi，/w提供/v程序/gi的/ude1整体/n性能/gi。/w内存/gi缓存/gi的/ude1原理/gijvm/nz垃圾/n回收/vn机制/gijvm/nz采用/v的/ude1是/vshi引用/gi计数/vi的/ude1机制/gi，/w处理/vn数据/gi回收/vn的/ude1问题/gi。/w引用/gi计数/vi：/w即/v类/gi被/pbei加载/gi到/v内存/gi以后/f，/w会/v在/p方法/gi区/n，/w堆栈/n，/w以及/cc程序/gi计数器/gi的/ude1地方/n分配/gi相应/vi的/ude1空间/n，/w同时/c对应/vi产生/v一个/mq引用/gi计数器/gi，/w专门/d计数/vi对象/gi被/pbei使用/gi的/ude1情况/n。/w如果/c新的/a地方/n引用/gi了/ule对象/gi，/w计数器/gi就/d+/nz1/nz，/w引用/gi销毁/v的/ude1时候/n计数器-/nz1/nz，/w当/p计数器/gi为/p0/nz的/ude1时候/n，/w对象/gi被/pbei标记/gi为/p可/v被/pbei回收/vn。/w由于/p该/rz机制/gi不能/v处理/vn互相/d引用/gi的/ude1情况/n，/w加入/v了/ule根/n搜索算法/gi，/w解决/v互相/d引用/gi时/qt计数器/gi始终/d=/nz1/nz的/ude1情况/n。/w /x*/nz /x引用/gi的/ude1类型/gi /x*/nz /x*/nz /x强/a引用/gi：/w只要/c引用/gi存在/v，/w垃圾/n回收器/nz就/d不会/v回收/vn。/w /x如/v：/w这时候/rztb/nz属于/va/nz的/ude1强/a引用/gi，/w只有/ca/nz被/pbei回收/vn后/fb/nz才能/n被/pbei回收/vn。/w软/a引用/gi：/w软/a引用/gi是非/n必须/d的/ude1引用/gi，/w当/p内存不足/i时/qt可/v被/pbei回收/vn的/ude1 /x。/w /x如/v：/w如果/c一个/mq对象/gi只/d具有/v软/a引用/gi，/w则/d内存空间/nz足够/v，/w垃圾/n回收器/nz就/d不会/v回收/vn它/rr；/w如果/c内存空间/nz不足/an了/ule，/w就/d会/v回收/vn这些/rz对象/gi的/ude1内存/gi。/w只要/c垃圾/n回收器/nz没有/v回收/vn它/rr，/w该/rz对象/gi就/d可以/v被/pbei程序/gi使用/gi。/w软/a引用/gi可/v用来/v实现/gi内存/gi敏感/gi的/ude1高速缓存/gi。/w弱/a引用/gi：/w第二次/nz垃圾/n回收/vn时/qt回收/vn软/a引用/gi第一次/nz垃圾/n回收器/nz扫描/gi到/v的/ude1时候/n不会/v马上/d回收/vn，/w会/v把/pba它/rr标记/gi为/p可回收/nz资源/gi，/w第二次/nzjvm/nz回收/vn内存/gi的/ude1时候/n如果/ca/nz还/d未/d被/pbei引用/gi过/uguo，/w内存/gi将/d被/pbei回收/vn，/w这时/rztsofta/nz./nzget/gi(/nz)/nz返回值/nz是/vshinull/gi。/w这样/rzv的/ude1好处/gi是/vshia/nz对象/gi可以/v短暂/a被/pbei保存/gi，/w但是/c每次/r用/pget/gi方法/gi取值/v时/qt都/d需要/v判断/gi对象/gi是否/v为/p空/ng！/w虚/a引用/gi：/w每次/rjvm/nz回收/vn垃圾/n的/ude1时候/n都会/n被/pbei回收/vn。/w虚/a引用/gi是/vshi每次/r垃圾/n回收/vn的/ude1时候/n都会/n被/pbei回收/vn，/w通过/p虚/a引用/gi的/ude1get/gi方法/gi永远/d获取/gi到/v的/ude1数据/gi为/pnull/gi，/w因此/c也/d被/pbei成为/v幽灵/n引用/gi。/w内存/gi缓存/gi的/ude1实现/gi策略/gi这个/rz缓存/gi是/vshi基于/plru/gi算法/gi的/ude1缓存机制/gi，/wlru/gi即/v最久/a未/d使用/gi算法/gi，/w当/p内存不足/i时/qt将/d最久/a未/d使用/gi的/ude1对象/gi放入/v软/a引用/gi区/n，/w当/p内存不足/i时/qt可以/v及时/ad释放/gi。/w