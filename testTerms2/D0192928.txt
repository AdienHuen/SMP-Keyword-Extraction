#Cocoa/nz中的/v设计模式/nz(/nzMVC/gi模式/gi\/nz委托/vn模式/gi\/nz键值/n观察/gi模式/gi)/nz
cocoa/nz是/vshi围绕/v着/uzhe一系列/b设计模式/nz所/usuo创建/gi的/ude1，/w其/rz目的/gi是/vshi让/v开发者/gi的/ude1工作/gi更加/d协调/gi和/cc更加/d高效/b。/wcocoa/nz中/f三个/nz关键/n的/ude1模式/gi   /x1./nz模型-视图-控制器/nz（/wmvc/gi:/wmodel/gi-/nzview/gi-/nzcontroller/gi）/w模式/gi：/w      cocoa/nz和/cccocoa touch /nz很大/d部分/n都/d是/vshi根据/p它/rr构建/gi的/ude1；/w   /x2./nz委托/vn（/wdelegate/nz）/w模式/gi：/w      /x它/rr允许/v你/rr的/ude1代码/gi和/cccocoa/nz可以/v在/p“/w决定/v什么/ry代码/gi被/pbei谁/ry运行/gi”/w上/f高度/d灵活/a；/w   /x3./nz键/n观察/gi（/wkey/gi-/nzvalue observing/nz）/w模式/gi：/w      /x它/rr允许/v你/rr的/ude1代码/gi可以/v在/p不/d对/p其他/rzv对象/gi进行/vn检查/gi的/ude1情况下/nz观察/gi到/v其他/rzv对象/gi的/ude1变更/gi。/wmvc/gi模式/gi   /x模型-视图-控制器/nz设计模式/nz是/vshicocoa/nz中的/v基础/gi设计模式/nz之一/rz。/w它/rr将/d所有/b的/ude1对象/gi都/d归结为/v三类/b：/w模型/gi、/w视图/gi、/w控制器/n（/w并/cc因此/c得名/v）/w。/w   /x-模型/nz（/wmodel/gi）/w是/vshi那些/rz包含/v数据/gi或者/c协助/v存储/gi、/w管理/gi，/w以及/cc给/p其他/rzv对象/gi传递数据/n的/ude1对象/gi。/w模型/gi可以/v简单/a到/v只是/d一个/mqnsstring/nz，/w也/d可以/v复杂/a到/v是/vshi整个/b数据库/gi。/w它们/rr的/ude1目的/gi是/vshi存储/gi数据/gi并/cc提供数据/n给/p其他/rzv对象/gi。/w一旦/d它们/rr将/d数据/gi给/p了/ule其它/rz对象/gi后/f，/w便/d不再/d关心/v数据/gi的/ude1变化/gi，/w唯一/b关心/v的/ude1是/vshi管理/gi数据/gi如何/ryv存储/gi。/w   /x-视图/nz（/wview/gi）/w是/vshi直接/ad与/cc用户/gi交互/gi、/w给/p用户/gi提供/v信息/gi和/cc接收/gi输入/v信息/gi的/ude1对象/gi。/w视图/gi并不/d管理/gi它们/rr所/usuo显示/gi的/ude1数据/gi，/w它们/rr只是/d将/d数据/gi展示/gi给/p用户/gi。/w同时/c，/w视图/gi在/p用户/gi与/cc对象/gi交互/gi时/qt还/d负责/v发送/gi通知/gi给/p对象/gi。/w如同/v模型/gi与/cc数据/gi间/f一样/uyy，/w视图/gi同样/d不/d关心/v接下来/vl数据/gi会/v发生/v什么/ry，/w在/p通知/gi完/vi应用程序/nz中/f其余部分/l后/f，/w其/rz职责/gi应/v终结/vi。/w   /x-控制器/nz（/wcontroller/gi）/w是/vshi作为/p模型/gi与/cc视图/gi间/f媒介/n的/ude1对象/gi，/w包含/v了/ule应用程序/nz中/f大量/m的/ude1称为/v“/w业务/gi逻辑”/nz的/ude1东西/n。/w实际/n逻辑/n定义/gi了/ule应用程序/nz是/vshi什么/ry以及/cc它/rr如何/ryv响应/v用户/gi输入/v。/w最/d基本/a的/ude1，/w控制器/n负责/v从/p模型/gi中/f获取信息/l然后/c提供/v给/p视图/gi，/w它/rr同样/d负责/v在/p得到/v视图/gi通知/gi用户/gi与/cc视图/gi有/vyou交互/gi时/qt将/d信息/gi提供/v给/p模型/gi。/w   /x为了/p给/p模型-视图-控制器/nz模式/gi一个/mq实际/n例证/n，/w设想/vn一个/mq简单/a的/ude1文本/gi编辑器/gi。/w在/p本示/nz例/n中/f，/w应用程序/nz从/p磁盘/gi中/f加载/gi一个/mq文本/gi文件/gi，/w然后/c在/p一个/mq文本/gi框/ng中/f向/p用户/gi呈现/v其/rz内容/gi。/w用户/gi在/p文本/gi框/ng中/f进行/vn修改/gi，/w然后/c保存/gi这些/rz修改/gi回到/v磁盘/gi。/w   /x我们/rr将/d此/rzs应用程序/nz分解/gi为/pmvc/gi对象/gi：/w   /x-/nz其/rz模型/gi是/vshi一个/mq负责/v从/p磁盘/gi加载/gi文本/gi文件/gi及/cc将/d其/rz写/v回/v磁盘/gi的/ude1对象/gi。/w它/rr同样/d负责/v以/pnsstring/nz形式/gi提供/v文本/gi给/p任何/rz请求/gi它/rr的/ude1对象/gi。/w   /x-/nz其/rz视图/gi是/vshi文本/gi框/ng，/w它/rr向/p另一个/nz对象/gi请求/gi要/v显示/gi的/ude1nsstring/nz，/w然后/c显示/gi其/rz文本/gi。/w它/rr同样/d接收/gi来自/v用户/gi的/ude1键盘输入/n，/w无论/c何时/ryt用户/gi用/p键盘输入/n，/w它/rr都会/n通知/gi其他/rzv对象/gi：/w文本/gi已经/d被/pbei修改/gi。/w当/p用户/gi告诉/v它/rr要/v保存/gi修改/gi时/qt，/w它/rr同样/d能/v再/d告诉/v其他/rzv对象/gi。/w   /x-/nz其/rz控制器/n是/vshi负责/v指示/gi模型/gi对象/gi从/p磁盘/gi加载/gi文件/gi，/w以及/cc传递/v文本/gi给/p视图/gi的/ude1对象/gi。/w当/p文本/gi被/pbei更改/gi时/qt它/rr接收/gi来自/v视图/gi的/ude1更新/gi，/w然后/c将/d这些/rz改变/v传递/v给/p模型/gi。/w最后/f，/w它/rr能够/v被/pbei视图/gi告知/v用户/gi已经/d请求/gi保存/gi修改/gi；/w那时/rzt，/w它/rr只是/d指示/gi模型/gi去/vf完成/v将/d文件/gi写入/gi磁盘/gi的/ude1实际操作/n。/w   /x将/d应用程序/nz分解成/n这些/rz职责/gi领域/gi，/w使得/vi修改/gi应用程序/nz更加/d容易/ad。/w   /x比如/v，/w如果/c开发者/gi决定/v在/p应用/gi的/ude1下一个/nz版本/n添加/gi在/p文本/gi被/pbei修改/gi时/qt上传/v该/rz文本/gi文件/gi到/v互联网/gi的/ude1功能/gi，/w必须/d修改/gi的/ude1仅仅/d是/vshi模型/gi类/gi，/w控制器/n可以/v保持/v原有/v的/ude1内容/gi，/w而/cc试图/v则/d不/d需要/v更改/gi。/w   /x同样/d的/ude1，/w清晰/a地/ude2定义/gi哪些/ry对象/gi负责/v哪些/ry特定/b的/ude1功能/gi，/w使得/vi在/p保持/v项目/gi中/f清晰/a的/ude1架构/gi同时/c修改/gi应用/gi更加/d容易/ad。/w如果/c开发者/gi决定/v添加/gi一个/mq拼写/v检查/gi的/ude1功能/gi到/v应用程序/nz，/w相应/vi的/ude1代码/gi显然/ad要/v添加/gi到/v控制器/n中/f，/w因为/c并不/d涉及/v文本/gi如何/ryv呈现/v给/p用户/gi或/c在/p磁盘/gi中的/v存储/gi（/w当然/d你/rr可以/v添加/gi一/nz些/q功能/gi到/v视图/gi，/w使得/vi它/rr可以/v指示/gi哪些/ry词/n拼写错误/nz，/w但/c大部分/n代码/gi将/d需要/v添加/gi到/v控制器/n中/f）/w。/w委托/vn   /x…/w…/w待/vi补充/vn…/w…/w键-观察/nz   mvc/nz模式/gi很大/d地/ude2依赖/v控制器/n在/p模型/gi和/cc视图/gi相互间/nz提供/v及时/ad更新/gi。/w要/v达到/v此/rzs目的/gi的/ude1一种/nz方式/n是/vshi定期/d地/ude2检查/gi模型/gi并/cc询问/v它/rr是否/v有/vyou任何/rz更改/gi，/w如果/c确实/ad有的/rz话/n，/w便/d向/p视图/gi提供/v信息/gi更新/gi，/w此/rzs方式/n一般/ad称为/v轮询/nz。/w然而/c，/w这种/r轮询/nz的/ude1方式/n，/w在/p模型/gi不/d经常/d变更/gi时效率/nz低下/a，/w资源/gi浪费/gi，/w而/cc恰恰/d在/pos x/nz和/ccios/gi应用程序/nz中的/v大/a多数/a情况/n，/w模型/gi通常/d是/vshi不/d经常/d变更/gi的/ude1。/w为了/p能/v更高/d效地/nz响应/v更改/gi，/wcocoa/nz实现/gi了/ule一种/nz称为/v键-观察/nz（/wkey/gi-/nzvalue observing/nz）/w的/ude1设计模式/nz。/w   /x在/p此/rzs模式/gi中/f，/w对象/gi可以/v注册/gi为/p关于/p其他/rzv对象/gi其/rz属性/gi的/ude1观察者/nz。/w当/p那些/rz其他/rzv对象/gi更改/gi了/ule所/usuo被/pbei观察/gi的/ude1属性/gi时/qt，/w那些/rz观察者/nz会/v得到/v通知/gi。/w   /x设计/gi程序/gi，/w当/p希望/v分离/vi视图/gi和/cc对象/gi模型/gi时/qt，/w键-观察/nz会/v变得/vi很/d重要/a。/w   /x…/w…/w更/d详细/gi的/ude1介绍/gi有待/v补充/vn…/w…/w