#【/w设计模式/nz学习笔记/gi二十四/nz】/w【/w行为模式/gi】/w【/w模板方法/gi(/nzTemplate Method/nz)/nz】/w
本文/r是/vshi学习/gi刘伟/nr技术/gi博客/gi和/cc《/w设计/gi模式-可复/nz用/p面向对象/gi软件/gi的/ude1基础/gi》/w笔记/gi，/w博客/gi链接/gi：/w主要/b是/vshi对/p博客/gi和/cc书本/n做/v提炼/v和/cc记录/gi，/w更多/ad是/vshi对/p设计模式/nz的/ude1基础/gi框架/gi学习/gi，/w细节/gi将略/n去/vf，/w侧重/gi对/p每个/r设计模式/nz框架/gi的/ude1理解/gi。/w我/rr应该/v理解/gi和/cc掌握/v的/ude1：/w1/nz）/w能够/v画/v出/vf这个/rz设计模式/nz的/ude1架构/gi框图/gi；/w2/nz）/w能够/v根据/p架构/gi框图/gi写出/v对应/vi的/ude1伪代码/nz；/w3/nz）/w这个/rz模式/gi的/ude1应用场景/gi，/w主要/b优缺点/gi。/w1./nz模板方法/gi对于/p一个/mq执行/v过程/gi有/vyou固定/a的/ude1步骤/gi，/w比如/v第一步/nz执行/v什么/ry，/w第二步/nz做/v什么/ry，/w第三步/nz干什么/vi，/w这些/rz都/d是/vshi设计/gi好/a的/ude1。/w在/p模板方法/gi中/f，/w将/d实现/gi功能/gi的/ude1每一个/nz步骤/gi所/usuo对应/vi的/ude1方法/gi称为/v基本/a方法/gi，/w而/cc调用/gi这些/rz基本/a方法/gi的/ude1同时/c定义/gi基本/a方法/gi的/ude1执行/v次序/gi的/ude1方法/gi称为/v模板方法/gi。/w模板方法/gi中/f，/w将/d相同/a的/ude1代码/gi放在/v父类/nz。/w把/pba不/d需要/v改变/v的/ude1步骤/gi可以/v放在/v父类/nz实现/gi，/w把/pba需要/v改变/v的/ude1步骤/gi交给/v子类/gm实现/gi。/w他/rr是/vshi一种/nz基于/p继承/gi的/ude1代码/gi复用技术/nz。/w（/w1/nz）/w定义/gi模板方法/gi：/w定义/gi一个/mq操作/gi中的/v算法/gi骨架/n，/w而/cc将/d一/nz些/q步骤/gi延迟/v到/v子类/gm中/f。/w模板方法/gi使得/vi子类/gm可以/v不/d改变/v一个/mq算法/gi的/ude1结构/gi即可/v重定义/nz该/rz算法/gi的/ude1某些/rz特定/b步骤/gi。/w1/nz)/nz /x模板方法/gi结构图/gi2/nz)/nz /x参与者/gia/nz)/nzabstractclass/nz(/nz抽象类/gi)/nz：/w定义/gi一系列/b的/ude1基本操作/n，/w可以/v是/vshi具体/a的/ude1，/w也/d可以/v是/vshi抽象/gi的/ude1。/w每/rz一个/mq基本操作/n应该/v对应/vi一个/mq步骤/gi，/w其子/r类/gi可以/v重/a定义/gi或/c实现/gi这些/rz步骤/gi。/w实现/gi一个/mq模板方法/gi，/w用于/v定义/gi一个/mq算法/gi的/ude1骨架/n，/w模板方法/gi不仅/c可以/v调用/gi在/p抽象类/gi中/f实现/gi的/ude1基本/a方法/gi，/w也/d可以/v调用/gi子类/gm中/f实现/gi的/ude1基本/a方法/gi。/wb/nz)/nzconcreteclass/nz(/nz具体/a子类/gm)/nz：/w实现/gi父类/nz中/f声明/gi的/ude1抽象/gi基本操作/n以/p完成/v子类/gm特定/b算法步骤/gi。/w3/nz)/nz /x看图/v写/v代码/gi（/w2/nz）/w总结/gi1/nz)/nz /x优点/gia/nz)/nz在/p父类/nz定义/gi一个/mq算法/gi，/w由/p他/rr的/ude1子类/gm实现/gi细节/gi的/ude1处理/vn，/w子类/gm实现/gi详细/gi的/ude1处理/vn并/cc不会/v改变/v算法/gi中/f步骤/gi的/ude1执行/v次序/gi。/wb/nz)/nz模板方法/gi是/vshi一种/nz代码复用/gi的/ude1基本/a技术/gi；/w在/p类库/gi中/f尤为/d重要/a，/w他们/rr提取/v了/ule类库/gi中的/v公共/b行为/n。/w将/d公共/b行为/n放在/v父类/nz中/f，/w而/cc通过/p子类/gm来/vf实现/gi不同/a的/ude1行为/n，/w他/rr鼓励/gi我们/rr通过/p恰当/a使用/gi继承/gi来/vf实现代码/gi复用/gi。/wc/nz)/nz可实现/nz一种/nz反向/gi控制结构/n，/w通过/p子类/gm覆盖/gi父类/nz的/ude1钩子/n方法/gi来/vf决定/v某/rz一/nz步骤/gi是否/v需要/v执行/v。/w2/nz)/nz /x缺点/gia/nz)/nz /x需要/v为/p每/rz一个/mq基本/a方法/gi的/ude1不同/a实现/gi提供/v一个子/nz类/gi，/w如果/c父类/nz可变/vn的/ude1基本/a方法/gi太多/ad，/w将/d会/v导致/gi类/gi的/ude1个数/n增加/v，/w系统/gi更加/d庞大/a，/w设计/gi也/d更加/d抽象/gi。/w（/w3/nz）/w适用/vi场景/gi1/nz)/nz /x各子/nz类/gi中/f公共/b的/ude1行为/n应/v被/pbei提取/v出来/vf并/cc集中/v到/v一个/mq公共/b父类/nz中/f以/p避免/v代码/gi重复/gi。/w2/nz)/nz /x需要/v通过/p子类/gm来/vf决定/v父类/nz算法/gi中/f某个/rz步骤/gi是否/v执行/v，/w实现/gi子类/gm对/p父类/nz的/ude1方向/gi控制/vn。/w3/nz)/nz /x对/p一/nz些/q复杂/a的/ude1算法/gi进行/vn分割/gi，/w将/d其/rz算法/gi中/f固定/a不变/nz的/ude1部分/n设计/gi为/p模板方法/gi和/cc父类/nz具体方法/l，/w而/cc一/nz些/q可以/v改变/v的/ude1细节/gi由/p其子/r类/gi来/vf实现/gi。/w即/v：/w一次性/d实现/gi一个/mq算法/gi的/ude1不变/nz部分/n，/w并/cc将/d可变/vn的/ude1行为/n留给/v子类/gm来/vf实现/gi。/w