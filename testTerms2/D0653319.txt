#最优/ad编码/gi问题/gi（/w哈夫曼编码/gi）/w（/w贪心/gi）/w
问题/gi描述/gi：/w给出/vn/nz个字符/n的/ude1频率/nci/gi，/w给/p每个/r字符/gi赋予/v一个/mq01/nz编码/gi串/q，/w使得/vi任意/d一个/mq字符/gi的/ude1编码/gi不是/c另一个/nz字符/gi编码/gi的/ude1前缀/n，/w而且/c编码/gi后/f总长度/n（/w每个/r字符/gi的/ude1频率/n与/cc编码/gi长度/gi乘积/n的/ude1总和/n）/w尽量/d小/a。/w分析/gi：/w此处/s策略/gi为/p设置/gi变长/v编码/gi，/w给/p低频/b的/ude1编码/gi设置/gi较长/d，/w高频/b的/ude1编码/gi设置/gi较短/d。/w任何/rz一个/mq前缀/n编码/gi都/d可以/v表示/v为/p每个/r非叶节点/nz恰好/d有/vyou两/nz个/q子结/nz点/gi的/ude1完全/ad二叉树/gi。/w左结/nz点/gi为/p1/nz，/w右结/nz点/gi为/p0。/nz叶/ng节点/gi就/d代表/nnt编码/gi，/w那么/c最深处/d的/ude1叶/ng节点/gi的/ude1频率/n应该/v是/vshi最低/a的/ude1，/w而/cc上/f一个/mq节点/gi的/ude1等于/v两/nz个/q叶节点/nz的/ude1权/n的/ude1和/cc，/w逐步/d递推/nz之后/f的/ude1总和/n就是/v要求/n的/ude1结果/n。/w程序实现/i：/w先/d按照/p频率/n吧/y字符/gi排序/gi成/v表/n，/w创建/gi队列/giq/nz，/w每次/r合并/gi两/nz个/q结点/gm吧/y结点/gm放到/v队列/giq/nz中/f，/w后/f合并/gi的/ude1频率/n一定/b是/vshi比/p先/d合并/gi的/ude1频率/n大/a，/w故而/c只要/c找到/v首/q个/q字母/gi就/d可以/v找到/v频率/n最小/a的/ude1元素/gi了/ule。/w代码/gi后续/vn补上/v！/w