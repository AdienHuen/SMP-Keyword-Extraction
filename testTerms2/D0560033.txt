#排序/gi算法三/nz：/w插入排序/gi
插入排序/gi插入排序/gi（/winsert sort/nz）/w即/v从前/t向/p后/f，/w每/rz取/v一个/mq元素/gi，/w将/d其/rz放入/v到/v已经/d排列/gi好/a的/ude1前面/f的/ude1队列/gi之中/f，/w并/cc保证/v加入/v该/rz元素/gi的/ude1队列/gi仍然/d为/p有序/gi的/ude1队列/gi，/w直到/v取到/v最后/f一个/mq元素/gi并/cc完整/a排序/gi为止/u。/w下面/f给出/vjava/gi代码/gi，/w实际上/d，/w我们/rr还有/v另外/c一种/nz实现/gi方式/n，/w它/rr的/ude1每/rz一/nz轮/qv外层/n循环/gi的/ude1结果/n与/cc插入排序/gi的/ude1结果/n是/vshi一致/a的/ude1，/w但是/c其/rz内部/f实现/gi方式/n却是/d不/d一样/uyy的/ude1。/w我/rr这里/rzs称/v其/rz为/p伪/ag插入排序/gi，/w实际上/d它/rr仍然/d是/vshi一种/nz选择排序/gi。/w其/rz代码/gi如下/vi，/w选择排序/gi始终保证第/nzk/nz轮/qv外层/n循环/gi的/ude1第/mqk/nz个/q位置/gi上/f一定/b是/vshi后面/flength/nz-/nzk/nz1/nz个/q元素/gi的/ude1最优/ad，/w而/cc这里/rzs则/d始终保证第/nzk/nz轮/qv外层/n循环/gi的/ude1第/mqk/nz个/q位置/gi上/f一定/b是/vshi前/fk/nz个/q元素/gi的/ude1最优/ad，/w二者/rzv恰好/d相对/d称/v。/w因为/c该/rz实现/gi方式/n没有/v“/w插入/gi”/w的/ude1特点/n，/w因此/c我/rr不/d认为/v它/rr是/vshi一种/nz插入/gi算法/gi，/w而/cc应该/v算作/v选择排序/gi的/ude1一种/nz。/w同样/d的/ude1，/w我们/rr也/d可以/v给出/v冒泡/vi形式/gi的/ude1伪/ag插入排序/gi，/w代码/gi如下/vi，/w折半/v插入排序/gi因为/c我们/rr的/ude1插入排序/gi算法/gi始终保证/nz插入/gi某/rz一/nz数据/gi元素/gi之前/f，/w该/rz元素/gi之前/f的/ude1数据/gi是/vshi有序/gi的/ude1，/w因此/c，/w可以/v通过/p折半/v查找/gi的/ude1方式/n获得/v插入/gi元素/gi的/ude1终点/gi。/w折半/v插入排序/gi的/ude1java/gi代码/gi如下/vi：/w折半/v插入排序/gi相对于/nz插入排序/gi减少/v了/ule插入/gi判断/gi的/ude1次数/gi，/w但是/c数据交换/nz次数/gi并/cc没有/v减少/v。/w