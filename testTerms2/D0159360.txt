#简单工厂模式/gi
目录/gi考虑/v一个/mq简单/a的/ude1软件应用/l场景/gi，/w一个/mq软件系统/gi可以/v提供/v多/a个/q外观/gi不同/a的/ude1按钮/n（/w如/v圆形/gi按钮/n、/w矩形/gi按钮/n、/w菱形/n按钮/n等/udeng）/w，/w /x这些/rz按钮/n都/d源自/v同一个/b基类/nz，/w不过/c在/p继承/gi基类/nz后/f不同/a的/ude1子类/gm修改/gi了/ule部分/n属性/gi从而/c使得/vi它们/rr可以/v呈现/v不同/a的/ude1外观/gi，/w如果/c我们/rr希望/v在/p使用/gi这些/rz按钮/n时/qt，/w不/d需要/v知道/v这些/rz具体/a按钮/n类/gi的/ude1名字/n，/w只/d需要/v知道/v表示/v该/rz按钮/n类/gi的/ude1一个/mq参数/gi，/w并/cc提供/v一个/mq调用/gi方便/a的/ude1方法/gi，/w把/pba该/rz参数/gi传入/gi方法/gi即可/v返回/v一个/mq相应/vi的/ude1按钮/n对象/gi，/w此时/r，/w就/d可以/v使用/gi简单工厂模式/gi。/w简单工厂模式/gi(/nzsimple factory pattern/nz)/nz：/w又/d称为/v静态/gi工厂方法/gi(/nzstatic factory method/nz)/nz模式/gi，/w它/rr属于/v类/gi创建型模式/gi。/w在/p简单工厂模式/gi中/f，/w可以/v根据/p参数/gi的/ude1不同/a返回/v不同/a类/gi的/ude1实例/gi。/w简单工厂模式/gi专门/d定义/gi一个/mq类/gi来/vf负责/v创建/gi其他/rzv类/gi的/ude1实例/gi，/w被/pbei创建/gi的/ude1实例/gi通常/d都/d具有/v共同/d的/ude1父类/nz。/w简单工厂模式/gi包含/v如下/vi角色/gi：/wfactory/gi：/w工厂/gi角色/gi工厂/gi角色/gi负责/v实现/gi创建/gi所有/b实例/gi的/ude1内部/f逻辑/nproduct/nz：/w抽象/gi产品/gi角色/gi抽象/gi产品/gi角色/gi是/vshi所/usuo创建/gi的/ude1所有/b对象/gi的/ude1父类/nz，/w负责/v描述/gi所有/b实例/gi所/usuo共有/v的/ude1公共/b接口/giconcreteproduct/nz：/w具体/a产品/gi角色/gi具体/a产品/gi角色/gi是/vshi创建/gi目标/gi，/w所有/b创建/gi的/ude1对象/gi都/d充当/v这个/rz角色/gi的/ude1某个/rz具体/a类/gi的/ude1实例/gi。/w将/d对象/gi的/ude1创建/gi和/cc对象/gi本身/rz业务/gi处理/vn分离/vi可以/v降低/v系统/gi的/ude1耦合度/gp，/w使得/vi两者/rzv修改/gi起来/vf都/d相对/d容易/ad。/w在/p调用/gi工厂/gi类/gi的/ude1工厂方法/gi时/qt，/w由于/p工厂方法/gi是/vshi静态方法/gi，/w使用/gi起来/vf很/d方便/a，/w可/v通过/p类名/n直接/ad调用/gi，/w而且/c只/d需要/v传入/gi一个/mq简单/a的/ude1参数/gi即可/v，/w在/p实际/n开发/gi中/f，/w还/d可以/v在/p调用/gi时/qt将/d所/usuo传入/gi的/ude1参数/gi保存/gi在/pxml/nz等/udeng式/k的/ude1配置文件/gi中/f，/w修改/gi参数/gi时/qt无须/d修改/gi任何/rz源代码/gi。/w简单工厂模式/gi最大/gm的/ude1问题/gi在于/v工厂/gi类/gi的/ude1职责/gi相对/d过重/v，/w增加/v新的/a产品/gi需要/v修改/gi工厂/gi类/gi的/ude1判断/gi逻辑/n，/w这一点/nz与/cc开闭/nz原则/gi是/vshi相/d违背/v的/ude1。/w简单工厂模式/gi的/ude1要点/n在于/v：/w当/p你/rr需要/v什么/ry，/w只/d需要/v传入/gi一个/mq正确/a的/ude1参数/gi，/w就/d可以/v获取/gi你/rr所/usuo需要/v的/ude1对象/gi，/w而无须/i知道/v其/rz创建/gi细节/gi。/w /x参见/v《/w大话/n设计模式/nz》/w第/mq1/nz章/q /x--/nz /x计算器/gi工厂/gi类/gi含有/v必要/a的/ude1判断/gi逻辑/n，/w可以/v决定/v在/p什么/ry时候/n创建/gi哪/ry一个/mq产品/gi类/gi的/ude1实例/gi，/w客户端/gi可以/v免除/v直接/ad创建/gi产品/gi对象/gi的/ude1责任/n，/w而/cc仅仅/d“/w消费/vn”/w产品/gi；/w简单工厂模式/gi通过/p这种/r做法/n实现/gi了/ule对/p责任/n的/ude1分割/gi，/w它/rr提供/v了/ule专门/d的/ude1工厂/gi类/gi用于/v创建对象/n。/w客户端/gi无须/d知道/v所/usuo创建/gi的/ude1具体/a产品/gi类/gi的/ude1类名/n，/w只/d需要/v知道/v具体/a产品/gi类/gi所/usuo对应/vi的/ude1参数/gi即可/v，/w对于/p一/nz些/q复杂/a的/ude1类名/n，/w通过/p简单工厂模式/gi可以/v减少/v使用者/n的/ude1记忆量/n。/w通过/p引入/v配置文件/gi，/w可以/v在/p不/d修改/gi任何/rz客户端/gi代码/gi的/ude1情况下/nz更换/v和/cc增加/v新的/a具体/a产品/gi类/gi，/w在/p一定/b程度/n上/f提高/v了/ule系统/gi的/ude1灵活性/gi。/w由于/p工厂/gi类/gi集中/v了/ule所有/b产品/gi创建/gi逻辑/n，/w一旦/d不能/v正常/a工作/gi，/w整个/b系统/gi都/d要/v受到影响/v。/w使用/gi简单工厂模式/gi将/d会/v增加/v系统/gi中/f类/gi的/ude1个数/n，/w在/p一定/b程序/gi上/f增加/v了/ule系统/gi的/ude1复杂度/gi和/cc理解/gi难度/n。/w系统/gi扩展/gi困难/an，/w一旦/d添加/gi新产品/nz就/d不得不/d修改/gi工厂/gi逻辑/n，/w在/p产品/gi类型/gi较多/d时/qt，/w有可能/nz造成/v工厂/gi逻辑/n过于/d复杂/a，/w不利于/v系统/gi的/ude1扩展/gi和/cc维护/gi。/w简单工厂模式/gi由于/p使用/gi了/ule静态/gi工厂方法/gi，/w造成/v工厂/gi角色/gi无法/v形成/v基于/p继承/gi的/ude1等级/n结构/gi。/w在/p以下/f情况下/nz可以/v使用/gi简单工厂模式/gi：/w工厂/gi类/gi负责/v创建/gi的/ude1对象/gi比较/gi少/a：/w由于/p创建/gi的/ude1对象/gi较少/ad，/w不会/v造成/v工厂方法/gi中的/v业务逻辑/gi太/d过/uguo复杂/a。/w客户端/gi只/d知道/v传入/gi工厂/gi类/gi的/ude1参数/gi，/w对于/p如何/ryv创建对象/n不/d关心/v：/w客户端/gi既/c不/d需要/v关心/v创建/gi细节/gi，/w甚至/d连类/v名都/n不/d需要/v记住/v，/w只/d需要/v知道/v类型/gi所/usuo对应/vi的/ude1参数/gi。/wjdk/gi类库/gi中/f广泛/a使用/gi了/ule简单工厂模式/gi，/w如/v工具/gi类/gijava/gi./nztext/nz./nzdateformat/nz，/w它/rr用于/v式/k化/v一个/mq本地/gi日期/gi或者/c时间/gi。/wjava/gi加密技术/nz获取/gi不同/a加密/gi算法/gi的/ude1密钥/gi生成器/n:/w创建/gi密码器/nz:/w创建型模式/gi对/p类/gi的/ude1实例化/gi过程/gi进行/vn了/ule抽象/gi，/w能够/v将/d对象/gi的/ude1创建/gi与/cc对象/gi的/ude1使用/gi过程/gi分离/vi。/w简单工厂模式/gi又/d称为/v静态/gi工厂方法模式/gi，/w它/rr属于/v类/gi创建型模式/gi。/w在/p简单工厂模式/gi中/f，/w可以/v根据/p参数/gi的/ude1不同/a返回/v不同/a类/gi的/ude1实例/gi。/w简单工厂模式/gi专门/d定义/gi一个/mq类/gi来/vf负责/v创建/gi其他/rzv类/gi的/ude1实例/gi，/w被/pbei创建/gi的/ude1实例/gi通常/d都/d具有/v共同/d的/ude1父类/nz。/w简单工厂模式/gi包含/v三个/nz角色/gi：/w工厂/gi角色/gi负责/v实现/gi创建/gi所有/b实例/gi的/ude1内部/f逻辑/n；/w抽象/gi产品/gi角色/gi是/vshi所/usuo创建/gi的/ude1所有/b对象/gi的/ude1父类/nz，/w负责/v描述/gi所有/b实例/gi所/usuo共有/v的/ude1公共/b接口/gi；/w具体/a产品/gi角色/gi是/vshi创建/gi目标/gi，/w所有/b创建/gi的/ude1对象/gi都/d充当/v这个/rz角色/gi的/ude1某个/rz具体/a类/gi的/ude1实例/gi。/w简单工厂模式/gi的/ude1要点/n在于/v：/w当/p你/rr需要/v什么/ry，/w只/d需要/v传入/gi一个/mq正确/a的/ude1参数/gi，/w就/d可以/v获取/gi你/rr所/usuo需要/v的/ude1对象/gi，/w而无须/i知道/v其/rz创建/gi细节/gi。/w简单工厂模式/gi最大/gm的/ude1优点/gi在于/v实现/gi对象/gi的/ude1创建/gi和/cc对象/gi的/ude1使用/gi分离/vi，/w将/d对象/gi的/ude1创建/gi交给/v专门/d的/ude1工厂/gi类/gi负责/v，/w但是/c其/rz最大/gm的/ude1缺点/gi在于/v工厂/gi类/gi不够/a灵活/a，/w增加/v新的/a具体/a产品/gi需要/v修改/gi工厂/gi类/gi的/ude1判断/gi逻辑/n代码/gi，/w而且/c产品/gi较多/d时/qt，/w工厂方法/gi代码/gi将/d会/v非常复杂/b。/w简单工厂模式/gi适用/vi情况/n包括/v：/w工厂/gi类/gi负责/v创建/gi的/ude1对象/gi比较/gi少/a；/w客户端/gi只/d知道/v传入/gi工厂/gi类/gi的/ude1参数/gi，/w对于/p如何/ryv创建对象/n不/d关心/v。/w示例/gi来源/gi：/w