#Java/gi设计模式/nz(/nz三/nz)/nz /x之/uzhi /x适配器模式/gi
源码/gi均/d以/pjdk/gi1.8/nz作为/p参考/gi1./nz定义/gi：/w     /x将/d一个/mq类/gi的/ude1接口/gi变换/gi成/v客户端/gi所/usuo期待/v的/ude1另一种/nz接口/gi，/w从而/c使/v原本/d因/p接口/gi不/d匹配/gi而/cc无法/v在/p一起/s工作/gi的/ude1两/nz个/q类/gi能够/v在/p一起/s工作/gi。/w /x2./nz解析/gi：/w     adapter pattern/nz又/d称为/vwrapper pattern/nz，/w提到/vadapter pattern/nz，/w最先/d会/v想到/v的/ude1可能/v就是/v电源适配器/nz，/w例如/v一/nz台/q12/nzv/nz的/ude1电脑/gi需要/v改到/v家用/b220/nzv/nz交流电源/nz上/f使用/gi，/w就/d需要/v使用/gi交流/gi电/n适配器/n，/w对/p电源/gi进行/vn转换/gi。/w     /x在/pjava/gi语言/gi中/f，/w就是/v为了/p将/d现有/v类/gi进行/vn包装/n或/c适配/nz来/vf完成/v既有/v功能/gi。/w     /x通用/gi类图/gi：/w          /x类图/gi解析/gi：/w     /x2.1./nzclient/nz角色/gi     /x具体/a应用/gi的/ude1角色/gi，/w是/vshi经过/p适配器/n包装/n之后/f的/ude1使用者/n。/w     /x2.2./nztarget/gi目标/gi角色/gi     /x该/rz角色/gi定义/gi了/ule把/pba其他/rzv类/gi转换/gi为/p何种/r接口/gi，/w即/v我们/rr期望/vn的/ude1接口/gi。/w     /x2.3./nzadaptee/nz源/ng角色/gi     /x通常/d是/vshi已经/d存在/v、/w运行/gi良好/a、/w经过/p严格/ad测试/gi的/ude1类/gi，/w经过/p适配器/n角色/gi的/ude1包装/n后/f，/w会/v成为/v一个/mq新的/a类/gi，/w附加/vn一/nz些/q新的/a功能/gi。/w     /x2.4./nzadapter/gi适配器/n角色/gi     /x适配器模式/gi的/ude1核心/n角色/gi，/w其他/rzv两/nz个/q角色/gi都/d是/vshi已经/d存在/v的/ude1角色/gi，/w而/cc适配器/n角色/gi是/vshi需要/v新建/v的/ude1，/w它/rr的/ude1职责/gi非常简单/nz：/w把/pba源/ng角色/gi转换/gi为/p目标/gi角色/gi。/w     /x适配器模式/gi的/ude1实现/gi方式/n：/w     /x1/nz)/nz /x面向/v类/gi的/ude1适配器模式/gi     /x适配器/n角色/gi以/p继承/gi的/ude1方式/n增加/v源/ng角色/gi具有/v目标/gi角色/gi约定/v的/ude1功能/gi     /x2/nz)/nz /x面向对象/gi的/ude1适配器模式/gi     /x适配器/n以/p持有/v对象/gi引用/gi的/ude1方式/n，/w使得/vi目标/gi角色/gi具有/v源/ng角色/gi的/ude1同时/c具有/v其他/rzv功能/gi     /x这/rzv两/nz种/q方式/n都/d可以/v完成/v对/p源/ng角色/gi的/ude1封装/gi，/w但是/c面向/v类/gi的/ude1实现/gi方式/n有/vyou一定/b的/ude1局限性/n，/w因为/cjava/gi中/f是/vshi不/d允许/v多/a继承/gi的/ude1，/w所以/c此/rzs适配器/n角色/gi只/d可以/v完成/v对于/p一种源/nz角色/gi的/ude1包装/n。/w     /x但是/c面向对象/gi的/ude1实现/gi方式/n，/w由于/p适配器/n角色/gi持有/v的/ude1是/vshi源/ng角色/gi引用/gi，/w所以/c适配器/n角色/gi可以/v对/p多/a个/q源/ng角色/gi进行/vn包装/n，/w以/p达到目标/nz角色/gi要求/n的/ude1目的/gi。/w /x3./nz具体/a应用/gi：/w     /x3.1./nzclient/nz角色/gi3.2./nztarget/gi目标/gi角色/gi3.3./nzadaptee/nz源/ng角色/gi     /x此处/s的/ude1源/ng角色/gi可以/v已经/d在/p运行/gi状态/gi，/w所以/c修改/gi源/ng角色/gi以/p达到目标/nz角色/gi的/ude1目的/gi，/w是/vshi不明智/i的/ude1。/w4./nzadapter/gi适配器/n角色/gi     /x面向/v类/gi适配/nz模式/gi面向对象/gi适配/nz模式/gi可以/v看到/v通过/padapter/gi类/gi可以/v实现/gi由/padaptee/nz到/vtarget/gi的/ude1转换/gi，/w同时/c如果/ctarget/gi要求/n新的/a实现/gi时/qt，/w也/d可以/v在/padapter/gi中/f增加/v具体/a的/ude1实现/gi。/w而/cc面向/v类/gi和/cc面向对象/gi的/ude1两/nz种/q适配/nz模式/gi，/w使得/vi适配器模式/gi在/p使用/gi时/qt更加/d灵活/a，/w如果/c需要/v复杂/a的/ude1适配/nz，/w则/d需要/v像/v面向对象/gi的/ude1实现/gi方式/n一样/uyy，/w可以/v完成/v对/p多/a个/q源/ng目标/gi的/ude1适配/nz。/w /x4./nz应用场景/gi：/w     /x适配器模式/gi，/w一般/ad情况下/nz，/w是/vshi不会/v在/p设计/gi初期/f被/pbei考虑/v的/ude1，/w其/rz存在/v的/ude1目的/gi就是/v为了/p在/p系统/gi运行/gi后期/f，/w由于/p设计/gi缺陷/gi或者/c需求/gi更新/gi导致/gi的/ude1问题/gi，/w通过/p适配器/n达到/v兼容/vi之前/f版本/n，/w并且/c能/v使/v当前/t版本/n能/v正常/a运转/vi的/ude1手段/n。/w     /x适配器模式/gi可以/v让/v两/nz个/q没有/v任何/rz关系/gi的/ude1类/gi在/p一起/s运行/gi，/w同时/c由于/p未/d对/p原有/v的/ude1实现/gi做出/v更改/gi，/w在/p设计/gi时/qt提高/v了/ule类/gi的/ude1复用/gi度/qv，/w同时/c使/v类/gi与/cc类/gi之间/f松散/a耦合/vn，/w降低/v类/gi与/cc类/gi之间/f的/ude1依赖度/n。/w当/p系统/gi不/d需要/v新增/v的/ude1功能/gi时/qt，/w只需/v删除/gi此/rzs适配器/n，/w并/cc不会/v对/p原有/v的/ude1设计/gi造成/v任何/rz影响/gi。/w注/v：/w本人/rr是/vshi参照/v《/w设计模式/nz之/uzhi禅/ng》/w和/cc《/w设计模式/nz》/w两本书/nz学习/gi所得/n，/w其中/rz加入/v了/ule自己/rr对于/piterator/nz设计模式/nz的/ude1理解/gi，/w以及/cc对于/pjdk/gi中/f源码/gi的/ude1理解/gi。/w