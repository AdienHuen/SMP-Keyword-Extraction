#Coco/nz2/nzdx /nz使用/gisqlite/gi数据库/gi存储/gi以及/cc加密/gi数据/gi总结/gi
我/rr还/d记得/v今/tg年年初/nz的/ude1项目/gi中/f，/w我们/rr对/p数据/gi的/ude1读取/gi都/d是从/vexecl/nz导出/gi为/pjson/gi文件/gi，/w通过/p解析/gijson/gi文件/gi信息/gi，/w来/vf获取/gi游戏/gi的/ude1配置/gi信息/gi。/w这样/rzv做/v简单/a但是/c当/p我们/rr插入/gi或者/c是/vshi删除/gi其中/rz的/ude1某个/rz数据项/gi的/ude1时候/n，/w修改/gi起来/vf比较/gi的/ude1麻烦/an而且/c容易/ad出现/v错误/gi，/w而且/c不/d容易/ad查错/nz。/w而/cc后/f在/p网上/s看着/v别人/rr分享/gi使用/gisqlite/gi数据库/gi的/ude1方案/gi，/w就/d果断/a去/vf尝试/v。/w对于/psqlite/gi数据库/gi本身/rz我/rr就/d不/d多/a说/v了/ule，/w这里/rzs主要/b是/vshi总结/gi在/p游戏/gi中/f使用/gisqlite/gi数据/gi步奏/nz和/cc方法/gi。/w首先/d需要/v下载/gisqlite/gi数据/gi的/ude1界面/gi可视化/gi工具/ginavicat premium/nz，/w有/vyou了/ule可视化/gi工具/gi，/w我们/rr新建/v表/n和/cc其中/rz的/ude1表项/nz就/d变得/vi十分/d的/ude1容易/ad和/cc简单/a了/ule。/w使用/gi的/ude1界面/gi和/ccmysql/gi数据可视化/gi界面/gi基本上/d差不多/al。/w更多/ad情况下/nz我们/rr都/d需要/v对/p数据库/gi进行/vn加密/gi，/w可以/v参考/gi首先/d是/vshi打开/gi数据库/gi的/ude1操作/gi：/w我们/rr本地/gi新建/v一个/mqtest/nz./nzsqlite/gi放在/vresources/nz的/ude1data/nz目录/gi下/f，/w游戏/gi首/q次/qv运行/gi时/qt，/w数据库/gi是/vshi不在/v游戏/gi的/ude1可/v读取/gi区域/n的/ude1，/w我们/rr需要/v从/p本地/gi拷贝/gi进去/vf。/w这/rzv是/vshi我们/rr自己/rr封装/gi的/ude1文件操作/gi类/gi的/ude1两/nz个/q方法/gi。/w好/a了/ule数据库/gi到/v是/vshi打开/gi了/ule，/w我们/rr现在/t来/vf验证/v数据/gi的/ude1加密/gi与/cc解密/gi。/w首先/d是/vshi加密/gi在/p执行/v以上/f代码/gi后/f，/w我们/rr会/v发现/vtest/nz./nzsqlite/gi已经/d不能/v打开/gi了/ule，/w说明/v加密/gi成功/a了/ule！/w对于/p加密/gi的/ude1具体/a过程/gi，/w可以/v去/vf追究/vsqlite/gi的/ude1源码/gi(/nz注意/v此时/r我们/rr都/d是/vshi对/p可读写/b区域/n的/ude1数据库/gi进行/vn的/ude1操作/gi)/nz然后/c进行/vn数据库/gi的/ude1解密/gi测试/gi：/w刚开始/nz使用/gi出现/v错误/gi，/w原来/d是/vshi加密/gi之后/f的/ude1数据库/gi必须/d使用/gi密钥/gi才能/n打开/gi，/w这样/rzv就/d导致/gi在/p代码/gi中能/j看到/v我们/rr的/ude1密码/gi。/w如果/c要/v隐藏/v密码/gi可以/v采取/v线/n上/f获取/gi，/w或者/c是/vshi本地/gi数据/gi与/cc线/n上/f的/ude1数据库/gi来/vf进行/vn比对/d，/w如果/c出现/v冲突/gi，/w以/p线/n上/f数据库/gi为准/v。/w数据/gi的/ude1加密/gi肯定/v是/vshi在/p之前/f就/d做好/v处理/vn的/ude1，/w所以/c我们/rr还/d得/ude3将/d以上/f代码/gi增加/v封装/gi到/v工具/gi当中/f去/vf，/w在/p本地/gi进行/vn数据/gi的/ude1加密/gi和/cc解密/gi。/w因为/c当/p我们/rr编辑/gi数据/gi的/ude1时候/n，/w数据库/gi就/d不能/v加密/gi，/w而/cc游戏/gi中/f使用/gi的/ude1数据库/gi需要/v加密/gi。/w当然/d此时/r我们/rr把/pba数据库操作/gi类/gi进行/vn单独/d的/ude1封装/gi其中/rzcallback/nz回调/gi函数/gi必须/d输/v静态/gi的/ude1函数/gi，/w而且/c数据读取/gi时/qt一行/n则/d调用/gi一次/nz回调/gi函数/gi，/w所以/c我们/rr需要/v在/p回调/gi中/f把/pba每行/r的/ude1数据/gi放在/v早已/d定义/gi好/a的/ude1数据结构/gi当中/f去/vf！/w而/cc这个/rz过程/gi我们/rr还/d可以/v进行/vn优化/gi，/w而且/c还/d需要/v增加/v一个/mq数据/gi管理/gi类/gi，/w对于/p游戏/gi配置/gi数据/gi，/w不/d应该/v提供/v写/v的/ude1接口/gi，/w玩家/n数据/gi需要/v可/v读取/gi的/ude1接口/gi。/w当然/d了/ule，/w这个/rz类/gi只/d给出/v了/ule基本/a的/ude1数据库操作/gi，/w可以/v根据/p实际/n情况/n增加/v我们/rr需要/v的/ude1操作/gi。/w