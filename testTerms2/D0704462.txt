#oracle /nz两/nz表/n之间/f字段/gi赋值/v错误/gi解析/gi
在/p做/v项目/gi时/qt，/w经常/d需要/v在/p量表/n之间/f进行/vn字段/gi赋/ng进行/vn初始化/v例如/v：/w我们/rr可以/v看到/v，/w在/p上面/f的/ude1代码/gi充分/ad估计/gi到/v了/ule空/ng的/ude1现象/n（/wnvl/nz）/w，/w并/cc对/p可能/v的/ude1多/a条/q记录/gi只/d取/v记录/gi最新/a的/ude1列表/vi，/w但/c依然/d可能/v报错/nz单行子/nz查询/gi返回/v多/a个/q行/ng或者/c“/wora/nz-/nz01427/nz：/wsingle/nz-/nzrow subquery returns more than one row/nz这里/rzs就/d需要/v仔细/ad查看/gi自己/rr的/ude1代码/gi逻辑/n，/w一般来说/vl是/vshi自己/rr的/ude1代码/gi逻辑/n出现/v了/ule问题/gi，/w如果/c确定/v没有/v问题/gi，/w则/d可能/v是/vshi数据库/gi里面/f存在/v重复/gi数据/gi这/rzv就/d需要/v对/p重复/gi数据/gi进行/vn查询/gi这/rzv就是/v对/p上面/f代码/gi进行/vn重复/gi数据/gi的/ude1查询/gi，/w从而/c找到/v了/ule重复/gi数据/gi重复/gi数据/gi的/ude1出现/v可能/v有/vyou很/d多/a，/w最/d常见/a的/ude1是/vshi在/p代码/gi设计阶段/n的/ude1循序渐进/vl造成/v的/ude1，/w虽然/c不/d多/a，/w但/c报错/nz之后/f影响/gi查询/gi，/w需要/v注意/v，/w另外/c一点/m，/w可以/v在/p开发阶段/n专门/d用/p一个/mq测试数据库/nz，/w开发/gi完成/v之后/f再/d进行/vn回滚/gi，/w则/d可以/v避免/v这/rzv部分/n的/ude1内容/gi