#【/w算法/gi】/w递归/gi与/cc尾/ng递归/gi总结/gi
前言/gi：/w今天/t上网/v看/v帖子/n的/ude1时候/n，/w看到/v关于/p尾/ng递归/gi的/ude1应用/gi（/w）/w，/w大脑/gi中/f感觉/gi这个/rz词/n好像/v在/p哪里/rys见过/v，/w但是/c又/d想不起来/l具体/a是/vshi怎么回事/nz。/w如是/c乎/y，/w在/p网上/s搜/v了/ule一下/m，/w顿时/d豁然开朗/vl，/w知道/v尾/ng递归/gi是/vshi怎么回事/nz了/ule。/w下面/f就/d递归/gi与/cc尾/ng递归/gi进行/vn总结/gi，/w以/p方便/a日/b后/f在工作中/l使用/gi。/w1/nz、/w递归/gi　　/nz关于/p递归/gi的/ude1概念/gi，/w我们/rr都/d不/d陌生/a。/w简单/a的/ude1来说/uls递归/gi就是/v一个/mq函数/gi直接/ad或/c间接地/n调用/gi自身/rr，/w是/vshi为/p直接/ad或/c间接/b递归/gi。/w一般来说/vl，/w递归/gi需要/v有/vyou边界条件/gm、/w递归/gi前进/vi段/q和/cc递归/gi返回/v段/q。/w当/p边界条件/gm不/d满足/v时/qt，/w递归/gi前进/vi；/w当/p边界条件/gm满足/v时/qt，/w递归/gi返回/v。/w用/p递归/gi需要/v注意/v以下/f两/nz点/gi：/w(/nz1/nz)/nz /x递归/gi就是/v在/p过程/gi或/c函数/gi里/f调用/gi自身/rr。/w(/nz2/nz)/nz /x在/p使用/gi递归/gi策略/gi时/qt，/w必须/d有一个/nz明确/a的/ude1递归/gi结束/v条件/n，/w称为/v递归/gi出口/vn。/w递归/gi一般/ad用于/v解决/v三类/b问题/gi：/w　/nz(/nz1/nz)/nz数据/gi的/ude1定义/gi是/vshi按/p递归/gi定义/gi的/ude1。/w（/wfibonacci/nz函数/gi，/wn/nz的/ude1阶乘/gm）/w　/nz /x(/nz2/nz)/nz问题/gi解法/gi按/p递归实现/gi。/w（/w回溯/gi）/w　/nz /x(/nz3/nz)/nz数据/gi的/ude1结构/gi形式/gi是/vshi按/p递归/gi定义/gi的/ude1。/w（/w二叉树/gi的/ude1遍历/gi，/w图/gi的/ude1搜索/gi）/w递归/gi的/ude1缺点/gi：/w　　/nz递归/gi解题/gi相对/d常用/a的/ude1算法/gi如/v普通/a循环/gi等/udeng，/w运行/gi效率/gi较低/d。/w因此/c，/w应该/v尽量避免/l使用/gi递归/gi，/w除非/c没有/v更好/d的/ude1算法/gi或者/c某种/rz特定/b情况/n，/w递归/gi更为/d适合/v的/ude1时候/n。/w在/p递归/gi调用/gi的/ude1过程/gi当中/f系统/gi为/p每一层/nz的/ude1返回/v点/gi、/w局部/n量/n等/udeng开辟/v了/ule栈来/nz存储/gi，/w因此/c递归/gi次数/gi过多/d容易/ad造成/v栈溢/nz出/vf。/w　　/nz用/p线性/gi递归实现/gifibonacci/nz函数/gi，/w程序/gi如下/vi所示/nz：/w递归/gi写/v的/ude1代码/gi非常容易/l懂/v，/w完全/ad是/vshi根据/p函数/gi的/ude1条件/n进行/vn选择/gi计算机/gi步骤/gi。/w例如/v现在/t要/v计算/gin/nz=/nz5/nz时/qt的/ude1，/w递归/gi调用/gi过程/gi如下/vi图/gi所示/nz：/w2/nz、/w尾/ng递归/gi　　/nz顾名思义/vl，/w尾/ng递归/gi就是/v从/p最后/f开始/v计算/gi,/nz /x每/rz递归/gi一次/nz就算/d出/vf相应/vi的/ude1结果/n,/nz /x也/d就是说/c,/nz /x函数调用/gi出现/v在/p调用者/n函数/gi的/ude1尾部/n,/nz /x因为/c是/vshi尾部/n,/nz /x所以/c根本/a没有/v必要/a去/vf保存/gi任何/rz局部/n变量/gi./nz /x直接/ad让/v被/pbei调用/gi的/ude1函数/gi返回/v时/qt越过/v调用者/n,/nz /x返回/v到/v调用者/n的/ude1调用者/n去/vf。/w尾/ng递归/gi就是/v把/pba当前/t的/ude1运算/gi结果/n（/w或/c路径/gi）/w放在/v参数/gi里/f传给/v下层/f函数/gi，/w深层/b函数/gi所/usuo面对/v的/ude1不是/c越来越/d简单/a的/ude1问题/gi，/w而是/c越来越/d复杂/a的/ude1问题/gi，/w因为/c参数/gi里/f带有/v前面/f若/c干步/nz的/ude1运算/gi路径/gi。/w　/nz　尾/nz递归/gi是/vshi极其重要/nz的/ude1，/w不用/d尾递/nz归/v，/w函数/gi的/ude1堆栈/n耗用/v难以/d估量/v，/w需要/v保存/gi很/d多/a中间/f函数/gi的/ude1堆栈/n。/w比如/vf/nz(/nzn/nz,/nzsum/gi)/nz=/nzf/nz(/nzn/nz-/nz1/nz)/nzvalue/nz(/nzn/nz)/nzsum/gi;/nz会/v保存/gin/nz个/q函数调用/gi堆栈/n，/w而/cc使用/gi尾递/nz归/vf/nz(/nzn/nz,/nzsum/gi)/nz=/nzf/nz(/nzn/nz-/nz1/nz,/nzsumvalue/nz(/nzn/nz)/nz)/nz;/nz这样/rzv则/d只/d保留/v后/f一个/mq函数/gi堆栈/n即可/v，/w之前/f的/ude1可/v优化/gi删去/v。/w　　/nz采用/v尾递/nz归/v实现/gifibonacci/nz函数/gi，/w程序/gi如下/vi所示/nz：/w例如/v现在/t要/v计算/gin/nz=/nz5/nz时/qt的/ude1，/w尾/ng递归/gi调用/gi过程/gi如下/vi图/gi所示/nz：/w从/p图/gi可以/v看出/v，/w为/p递归/gi不/d需要/v向上/vi返回/v了/ule，/w但是/c需要/v引入/v而外/u的/ude1两/nz个/q空间/n来/vf保持/v当前/t的/ude1结果/n。/w　　/nz为了/p更好/d的/ude1理解/gi尾/ng递归/gi的/ude1应用/gi，/w写/v个/q程序/gi进行/vn练习/v。/w采用/v直接/ad递归/gi和/cc尾递/nz归/v的/ude1方法/gi求解/gi单链表/gi的/ude1长度/gi，/wc语言/gi实现/gi程序/gi如下/vi所示/nz：/w程序/gi测试/gi结果/n如/v下图/n所示/nz：/w参考/gi：/w转载/v链接/gi：/w