#三大/j高级/a排序/gi
原文/n地址/gi：/w三大/j高级/a排序/gi1/nz、/w堆排序/gi堆排序/gi适合于/v数据量/n非常/d大/a的/ude1场合/n（/w百万/nz数据/gi）/w。/w堆排序/gi不/d需要/v大量/m的/ude1递归/gi或者/c多维/gi的/ude1暂存/nz数组/gi。/w这/rzv对于/p数据量/n非常/d巨大/a的/ude1序列/gi是/vshi合适/a的/ude1。/w比如/v超过/v数/n百万条/nz记录/gi，/w因为/c快速排序/gi，/w归并排序/gi都/d使用/gi递/v归来/vi设计/gi算法/gi，/w在/p数据量/n非常/d大/a的/ude1时候/n，/w可能会/nz发生/v堆栈/n溢出/gi错误/gi。/w堆排序/gi会/v将/d所有/b的/ude1数据/gi建成/v一个堆/nz，/w最大/gm的/ude1数据/gi在/p堆顶/nz，/w然后/c将/d堆/gi顶/v数据/gi和/cc序列/gi的/ude1最后/f一个/mq数据交换/nz。/w接下来/vl再次/d重建/v堆/gi，/w交换/gi数据/gi，/w依次/d下去/vf，/w就/d可以/v排序/gi所有/b的/ude1数据/gi。/w2/nz、/w归并排序/gi归并排序/gi先/d分解/gi要/v排序/gi的/ude1序列/gi，/w从/p1/nz分成/vi2/nz，/w2/nz分成/vi4/nz，/w依次/d分解/gi，/w当/p分解/gi到/v只有/c1/nz个/q一/nz组/n的/ude1时候/n，/w就/d可以/v排序/gi这些/rz分组/gi，/w然后/c依次/d合并/gi回/v原来/d的/ude1序列/gi中/f，/w这样/rzv就/d可以/v排序/gi所有/b数据/gi。/w合并/gi排序/gi比/p堆排序/gi稍微/d快一点/nz，/w但是/c需要/v比/p堆排序/gi多一倍/nz的/ude1内存空间/nz，/w因为/c它/rr需要/v一个/mq额外/b的/ude1数组/gi。/w3/nz、/w快速排序/gi快速排序/gi是/vshi一个/mq就地/d排序/gi，/w分而治之/nz，/w大规模/b递归/gi的/ude1算法/gi。/w从/p本质/n上/f来说/uls，/w它/rr是/vshi归并排序/gi的/ude1就地/d版本/n。/w快速排序/gi可以/v由/p下面/f四步/nz组成/gi。/w（/w1/nz）/w /x如果/c不/d多于/v1/nz个/q数据/gi，/w直接/ad返回/v。/w（/w2/nz）/w /x一般/ad选择/gi序列/gi最/d左边/f的/ude1作为/p支点/n数据/gi。/w（/w3/nz）/w /x将/d序列/gi分成/vi2/nz部分/n，/w一/nz部分/n都/d大于/v支点/n数据/gi，/w另外/c一/nz部分/n都/d小于/v支点/n数据/gi。/w（/w4/nz）/w /x对/p两边/f利用/v递归/gi排序/gi数列/gi。/w快速排序/gi比/p大部分/n排序算法/gi都/d要/v快/a。/w尽管/c我们/rr可以/v在/p某些/rz特殊/a的/ude1情况下/nz写出/v比/p快速排序/gi快/a的/ude1算法/gi，/w但是/c就/d通常/d情况/n而言/uls，/w没有/v比/p它/rr更快/d的/ude1了/ule。/w快速排序/gi是/vshi递归/gi的/ude1，/w对于/p内存/gi非常/d有限/a的/ude1机器/gi来说/uls，/w它/rr不是/c一个/mq好/a的/ude1选择/gi。/w