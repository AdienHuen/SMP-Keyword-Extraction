#HDFS/nz的/ude1设计/gi―/w―/w两/nz大一/j小/a+/nz又/d多/a又/d快/a
hdfs/gi的/ude1设计/gi―/w―/w两/nz大一/j小/a又/d多/a又/d快/ahdfs/gi是/vshi为/p以/p流式/n数据/gi访问/gi模式/gi存储/gi超大/b文件/gi而/cc设计/gi的/ude1文件系统/gi，/w在/p商用/b硬件/gi的/ude1集群/gi上/f运行/gi。/w让/v我们/rr仔细/ad看看/v下面/f的/ude1明/ag。/w超大/b文件/gi超大/b文件/gi在/p这里/rzs指/v几百/nzmb/nz，/w几百/nzgb/nz甚至/d几百/nztb/nz大小/n的/ude1文件/gi。/w目前/t已经/d有/vyouhadoop/gi集群/gi存储/gipb/nz(/nzpetabytes/nz)/nz级/q的/ude1数据/gi了/ule。/w流式/n数据/gi访问/gihdfs/gi建立/gi在/p这样/rzv一个/mq思想/gi上/f：/w一次/nz写入/gi、/w多/a次/qv读取/gi模式/gi是/vshi最/d高效/b的/ude1。/w一个/mq数据/gi集/q通常/d由/p数据源/gi生成/v或/c复制/gi，/w接着/c在/p此/rzs基础上/nz进行/vn各种各样/bl的/ude1分析/gi。/w每个/r分析/gi至少/d都会/n涉及/v数据/gi集中/v的/ude1大部分/n数据/gi /x(/nz甚至/d全部/m)/nz，/w因此/c读取/gi整个/b数据集/nz的/ude1时间/gi比/p读取/gi第一条/nz记录/gi的/ude1延迟/v更为重要/l。/w商用/b硬件/gihadoop/gi不/d需要/v运行/gi在/p昂贵/a并且/c高可靠性/n的/ude1硬件/gi上/f。/w它/rr被/pbei设计/gi运行/gi在/p商用/b硬件/gi(/nz在/p各种/rz零售店/nis都/d能/v买到/v的/ude1普通/a硬件/gi)/nz的/ude1集群/gi上/f，/w因此/c至少/d对于/p大/a的/ude1集群/gi来说/uls，/w节点/gi故障/gi的/ude1几率/n还是/c较高/ad的/ude1。/whdfs/gi在/p面对/v这种/r故障/gi时/qt，/w被/pbei设计/gi为/p能够/v继续/v运行/gi而/cc让/v用户/gi察觉/v不到/v明显/a的/ude1中断/gi。/w同时/c，/w那些/rz并不/d适合/vhdfs/gi的/ude1应用/gi也/d是/vshi得/ude3研究/gi的/ude1。/w在/p目前/t，/whdfs/gi还/d不/d太/d适用/vi于/p某些/rz领域/gi，/w不过/c日/b后/f可能会/nz有所改进/l。/w低/a延迟/v数据/gi访问/gi需要/v低/a延迟/v访问/gi数据/gi在/p毫秒/q范围内/nz的/ude1应用/gi并不/d适合/vhdfs/gi。/whdfs/gi是/vshi为/p达到/v高/a数据/gi吞吐量/gi而/cc优化/gi的/ude1，/w这/rzv有可能会/nz以/p延迟/v为/p代价/gi。/w目前/t，/w对于/p低/a延迟/v访问/gi，/whbase/gi(/nz参见第/nz12/nz章/q)/nz是/vshi更好/d的/ude1选择/gi。/w大量/m的/ude1小/a文件名称/nz节点/gi(/nznamenode/gi)/nz存储/gi着/uzhe文件系统/gi的/ude1元数据/gi，/w因此/c文件/gi数量/n的/ude1限制/vn也/d由/p名称/n节点/gi的/ude1内存/gi量/n决定/v。/w根据/p经验/gi，/w每个/r文件/gi，/w索引/gi目录/gi以及/cc块/q占/v大约/d150/nz个/q字节/gi。/w因此/c，/w举例来说/vl，/w如果/c有/vyou一/nz百万个/nz文件/gi，/w每个/r文件/gi占/v一/nz个块/nz，/w就/d至少/d需要/v300/nz mb/nz的/ude1内存/gi。/w虽然/c存储/gi上/f百万/nz的/ude1文件/gi是/vshi可行/a的/ude1，/w十亿/nz或/c更多/ad的/ude1文件/gi就/d超出/v目前/t硬件/gi的/ude1能力/gi了/ule。/w多用户/n写入/gi，/w任意/d修改/gi文件/gihdfs/gi中的/v文件/gi只有/c一个/mq写入/gi者/k，/w而且/c写/v操作/gi总是/d在/p文件/gi的/ude1末尾/n。/w它/rr不/d支持/v多/a个/q写入/gi者/k，/w或/c是/vshi在/p文件/gi的/ude1任意/d位置/gi修改/gi。/w(/nz可能/v在/p以后/f这些/rz会/v被/pbei支持/v，/w但/c它们/rr也/d相对/d不/d那么/c高效/b。/w