#java/gi线程池/gi学习/gi（/w二/nz）/w /x―/w―/w /x实现/gi一个/mq简单/a的/ude1线程池/gi
在/p上/f一篇/nz文章/gi中/f，/w我们/rr简单/a探讨/v了/ule一下/mblockingqueue/nz的/ude1概念/gi。/w那么/c在/p这边/rzs文章/gi，/w我们/rr要/v利用/vblockingqueue/nz来/vf自己/rr实现/gi一个/mq简单/a的/ude1线程池/gi，/w在/p以后/f的/ude1章节/n中/f，/w我们/rr再/d学习/gi一下/m怎么/ryv去/vf使用/gijava/gi为/p我们/rr封装/gi好/a的/ude1线程池/gi。/w首先/d我们/rr关注/v一个/mq /x“/w生产者/n消费者/n”/w /x的/ude1情景/n。/w生产者/n：/w不断/d产生/v新的/a需要/v解决/v的/ude1任务/gi，/w比如/v查询数据库/n，/w执行/v某些/rz业务逻辑/gi等/udeng。/w消费者/n：/w不断/d解决/v产生/v的/ude1问题/gi。/w那么/c把/pba这/rzv两者/rzv连接起来/l的/ude1就要/d用/p到/v我们/rr的/ude1blockingqueue/nz了/ule。/w生产者/n将/d不断/d产生/v的/ude1任务/gi放入/v到/v队列/gi中/f，/w如果/c队列/gi满/a了/ule，/w生产者/n等待/gi。/w消费者/n不断/d的/ude1从/p队列/gi中/f取出/v任务/gi解决/v，/w当/p队列/gi空/ng了/ule，/w消费者/n等待/gi新任务/nz到来/gi。/w首先/dblockqueue/nz的/ude1长度/gi我们/rr要/v限制/vn，/w不然/c如果/c解决/v者/k的/ude1解决/v能力/gi跟不上/v生产者/n的/ude1，/w这个/rz任务/gi队列/gi就/d会/v越来越/d多/a。/w接着/c我们/rr还/d需要/v限定/v问题/gi解决/v者/k的/ude1个数/n，/w就是/v我们/rr所谓/v的/ude1线程池/gi中能/j同时/c运行/gi的/ude1最多/ad的/ude1线程/gi数/n，/w如果/c线程/gi数/n太多/ad的话/udh会/v严重影响/v系统/gi的/ude1稳定性/n。/w那么/c我们/rr根据/p这/rzv两/nz个/q参数/gi写/v一个/mq简单/a的/ude1线程池/gi：/w线程池/gi：/w接下来/vl定义/gi /x消费者/n /x逻辑/n：/w我们/rr在/p上面/f的/ude1例子/gi可以/v看到/v。/w这个/rz线程池/gi中/f最大/gm的/ude1线程/gi数/n是/vshi3/nz，/w就是/v最多/ad只能/v同时/c有/vyou3/nz个/q消费者/n线程/gi执行/v，/w消费者/n会/v监视线/nz程池/nz的/ude1任务/gi队列/gi，/w只要/c队列/gi中/f有/vyou任务/gi，/w就/d会/v取出/v来/vf执行/v。/w接下来/vl我们/rr定义/gi /x生产者/n /x的/ude1逻辑/n：/w到/v此/rzs我们/rr已经/d实现/gi好/a了/ule一个/mq非常简单/nz的/ude1线程池/gi，/w将/d线程/gi的/ude1创建/gi与/cc执行/v过程/gi分离/vi开/v，/w而/cc不是/c将/d线程/gi的/ude1生命周期管理/gi和/cc任务/gi的/ude1执行/v过程/gi绑定/gi在/p一起/s，/w如果/c只是/d想/v简单/a的/ude1丢/v一个/mq任务/gi进去/vf执行/v，/w我们/rr只/d需要/v将/d任务/gi的/ude1执行/v过程/gi封装/gi到/v一个/mqrunnable/nz接口/gi中/f就/d可以/v了/ule。/w而/cc对于/p那些/rz需要/v返回/v结果/n的/ude1任务/gi，/w我们/rr可以/v将/d其/rz封装/gi到/vcallable/nz接口/gi里面/f。/w当然/djava/gi线程池/gi比/p我们/rr自己/rr写/v的/ude1这个/rz高大/a上/f很/d多/a，/w在/p以后/f的/ude1篇幅/n中/f，/w我们/rr再/d做/v具体/a研究/gi。/w