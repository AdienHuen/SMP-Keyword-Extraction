#设计模式/nz /x开放-封闭/nz原则/gi
开放-封闭/nz原则/gi1./nz /x开放-封闭/nz原则/gi的/ude1核心思想/n  /x　　/nz关于/p开放/gi封闭/gi原则/gi，/w其/rz核心/n的/ude1思想/gi是/vshi：/w   /x　　/nz软件/gi实体/n应该/v是/vshi可扩展/nz，/w而/cc不可/v修改/gi的/ude1。/w也/d就是说/c，/w对/p扩展/gi是/vshi开放/gi的/ude1，/w而/cc对/p修改/gi是/vshi封闭/gi的/ude1。/w   /x　　/nz因此/c，/w开放/gi封闭/gi原则/gi主要/b体现/v在/p两/nz个/q方面/n：/w      /x对/p扩展/gi开放/gi，/w意味着/v有/vyou新的/a需求/gi或/c变化/gi时/qt，/w可以/v对/p现有/v代码/gi进行/vn扩展/gi，/w以/p适应/v新的/a情况/n。/w  /x对/p修改/gi封闭/gi，/w意味着/v类/gi一旦/d设计/gi完成/v，/w就/d可以/v独立/a完成/v其/rz工作/gi，/w而/cc不要/d对/p类/gi进行/vn任何/rz修改/gi。/w  /x2./nz /x怎么/ryv可能/v写完/v一个/mq类/gi就/d再也/d不/d改/v了/ule呢/y？/w  /x　/nz　“/nz需求/gi总是/d变化/gi”/w、/w“/w世界/gi上/f没有/v一个/mq软件/gi是/vshi不变/nz的/ude1”/w，/w这些/rz言论/n是/vshi对/p软件需求/gi最/d经典/gi的/ude1表白/v。/w从/p中/f透射/vi出/vf一个/mq关键/n的/ude1意思/n就是/v，/w对于/p软件/gi设计者/nnt来说/uls，/w必须/d在/p不/d需要/v对/p原有/v的/ude1系统/gi进行/vn修改/gi的/ude1情况下/nz，/w实现/gi灵活/a的/ude1系统/gi扩展/gi。/w而/cc如何/ryv能/v做到/v这一点/nz呢/y？/w   /x　　/nz只有/c依赖于/v抽象/gi。/w实现/gi开放/gi封闭/gi的/ude1核心思想/n就是/v对/p抽象/gi编程/gi，/w而/cc不/d对/p具体/a编程/gi，/w因为/c抽象/gi相对/d稳定/an。/w让/v类/gi依赖于/v固定/a的/ude1抽象/gi，/w所以/c对/p修改/gi就是/v封闭/gi的/ude1；/w而/cc通过/p面向对象/gi的/ude1继承/gi和/cc对/p多态/gi机制/gi，/w可以/v实现/gi对/p抽象/gi体/ng的/ude1继承/gi，/w通过/p覆写/nz其/rz方法/gi来/vf改变/v固有/b行为/n，/w实现/gi新的/a扩展/gi方法/gi，/w所以/c对于/p扩展/gi就是/v开放/gi的/ude1。/w这/rzv是/vshi实施/gi开放/gi封闭/gi原则/gi的/ude1基本思路/nz，/w同时/c这种/r机制/gi是/vshi建立/gi在/p两/nz个/q基本/a的/ude1设计原则/gi的/ude1基础上/nz，/w这/rzv就是/vliskov/nz替换/v原则/gi和/cc合成/gi//nz聚合/gi复用/gi原则/gi。/w   /x　　/nz对于/p违反/v这/rzv一/nz原则/gi的/ude1类/gi，/w必须/d进行/vn重构/gi来/vf改善/v，/w常/d用于/v实现/gi的/ude1设计模式/nz主要/b有/vyoutemplate method/nz模式/gi和/ccstrategy/gi模式/gi。/w而/cc封装/gi变化/gi，/w是/vshi实现/gi这/rzv一/nz原则/gi的/ude1重要/a手段/n，/w将/d经常/d发生变化/l的/ude1状态/gi封装/gi为/p一个/mq类/gi。/w   /x　　/nz在/p我们/rr最初/d编写/gi代码/gi时/qt，/w假设/gi变化/gi不会/v发生/v。/w当/p变化/gi发生/v时/qt，/w我们/rr就/d创建/gi抽象/gi来/vf隔离/vn以后/f发生/v的/ude1同类/n变化/gi。/w比如/v，/w之前/f写/v的/ude1加法/gi程序/gi，/w你/rr可以/v很快/d在/p一个/mqclient/nz类/gi中/f就/d完成/v，/w此时/r变化/gi还/d没有/v发生/v。/w然后/c我/rr让/v你/rr加/v一个/mq减法/n功能/gi，/w你/rr发现/v，/w增加/v功能/gi需要/v修改/gi原来/d这个/rz类/gi，/w这/rzv就/d违背/v了/ule“/w开放-封闭/nz原则”/nz，/w于是/cc你/rr就/d该/rz考虑/v重构/gi程序/gi，/w增加/v一个/mq抽象/gi的/ude1运算/gi类/gi，/w通过/p一/nz些/q面向对象/gi的/ude1手段/n，/w如/v继承/gi，/w多态/gi等/udeng来/vf隔离/vn具体/a加法/gi、/w减法/n与/ccclient/nz耦合/vn，/w需求/gi依然/d可以/v满足/v，/w还/d能/v应对/v变化/gi。/w即/v面对/v需求/gi，/w对/p程序/gi的/ude1改动/vn是/vshi通过/p增加/v新/a代码/gi进行/vn的/ude1，/w而/cc不是/c更新/gi现有/v的/ude1代码/gi。/w