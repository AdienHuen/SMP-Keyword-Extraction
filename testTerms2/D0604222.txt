#c++/gi策略模式/gistrategy/gi
意图/gi：/w   /x定义/gi一系列/b的/ude1算法/gi,/nz把/pba它们/rr一个/mq个/q封装/gi起来/vf,/nz并且/c使/v它们/rr可/v相互/d替换/v。/w本/rz模式/gi使得/vi算法/gi可/v独立/a于/p使用/gi它/rr的/ude1客户/n而/cc变化/gi。/w适用性/n：/w   /x许多相关/nz的/ude1类/gi仅仅/d是/vshi行为/n有异/a。/w“/w策略/gi”/w提供/v了/ule一种/nz用/p多/a个/q行为/n中的/v一个/mq行为/n来/vf配置/gi一个/mq类/gi的/ude1方法/gi。/w   /x需要/v使用/gi一个/mq算法/gi的/ude1不同/a变体/nz。/w例如/v，/w你/rr可能会/nz定义/gi一/nz些/q反映/v不同/a的/ude1空间/n//nz时间/gi权衡/v的/ude1算法/gi。/w   /x算法/gi使用/gi客户/n不/d应该/v知道/v的/ude1数据/gi。/w可/v使用/gi策略模式/gi以/p避免/v暴露/v复杂/a的/ude1、/w与/cc算法/gi相关/vn的/ude1数据结构/gi。/w   /x一个/mq类/gi定义/gi了/ule多种/m行为/n,/nz并且/c这些/rz行为/n在/p这个/rz类/gi的/ude1操作/gi中/f以/p多/a个/q条件/n语句/gi的/ude1形式/gi出现/v。/w将/d相关/vn的/ude1条件/n分支/n移入/gi它们/rr各自/rr的/ude1strategy/gi类/gi中/f以/p代替/v这些/rz条件/n语句/gi。/w二我们/nz可以/v结合/v简单工厂模式/gi来/vf定义/gi，/w因为/c在/p实际操作/n的/ude1过程/gi中/f，/w我们/rr会/v发现/v，/w在/pmain/gi函数/gi中/f，/w也/d就是/v在/p客户端/gi使用/gi策略模式/gi时/qt，/w会/v创建/gi非常/d多/a的/ude1strategy/gi，/w而/cc这样/rzv就/d莫名/b的/ude1增加/v了/ule客户端/gi的/ude1压力/n，/w让/v客户端/gi的/ude1复杂度/gi陡然/d增加/v了/ule。/w那么/c，/w我们/rr就/d可以/v借鉴/gi简单工厂模式/gi，/w使/v策略模式/gi和/cc简单工厂/gi相结合/nz，/w从而/c减轻/v客户端/gi的/ude1压力/n，/w代码实现/gi如下/vi：/w