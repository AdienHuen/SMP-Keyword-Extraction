#UDP/nz校验/v
udp/gi结构/gi由/p首部/gi和/cc数据/gi两/nz部分/n组成/gi。/w    /x首部/gi由/p8/nz个/q字节/gi。/w包括/v：/w1./nz源端/nz口号/n，/w两/nz个/q字节/gi2./nz目的/gi端口号/n，/w两/nz个/q字节/gi3./nz长度/gi，/w两/nz个/q字节/gi。/wudp/gi用户/gi数据包/gi的/ude1总长度/n。/w以/p字节/gi为/p单位/n。/w4./nz检验/gi和/cc，/w两/nz个/q字节/gi。/w用来/v检验/giupd/nz伪/ag首部/gi、/w数据/gi部分/n、/w首部/gi。/w和/ccip/gi分组/gi首部/gi校验/v方法/gi一样/uyy。/w  /x其中/rz伪/ag首部/gi：/w又称/gi伪/ag包头/ns，/w是/vshi指/v在/ptcp/gi分段/vd或者/cudp/gi数据/gi式/k中/f，/w在/p数据包/gi首部/gi前面/f增加/v源地址/n、/w目的/gi地址/gi、/wip/gi组/n的/ude1协议/gi字段/gi、/wtcp/gi或/cudp/gi数据/gi的/ude1总长度/n等/udeng共/d12/nz个/q字节/gi，/w协议/gi类型/gi就/d一个字/nz节/q，/w需要/v补充/vn一个字/nz节/q0/nzx/nz0./nz次/qv伪/ag首部/gi是/vshi一个/mq临时/gi结构/gi，/w它/rr既/c不/d向下/vf也/d不向上/nz传递/v，/w仅仅/d为了/p保证/v可以/v校验套/nz接字/v的/ude1正确性/gi。/w   /x伪/ag首部/giudp/gi首部/gi数据/gi /x一起/s计算/gi校验/v和/cc。/w具体方法/l如下/vi：/w1./nz按/p每/rz16/nz位/q求和/vi得出/v一个/mq32/nz位/q的/ude1数/n。/w2./nz如果/c这个/rz32/nz位/q的/ude1数/n，/w高/a16/nz位/q不为/c0/nz，/w则/d高/a16/nz位/q加上/v低/a16/nz再/d得到/v一个/mq32/nz位/q的/ude1数/n。/w3./nz重复/gi第二步/nz，/w直到/v高/a16/nz位/q为/p0./nz，/w之后/f将/d低/a16/nz位/q取反/v，/w得到/v校验/v和/cc。/w   /x感谢/v作者/nnt的/ude1算法/gi，/w在/p此/rzs仅/d做/v个/q记录/gi：/w以上/f是/vshi作者/nnt抓/v的/ude1数据包/gi，/w仅/d作/v参考/gi。/w /x校验/v原理/gi：/w接收/gi方/q进行/vn校验/v时/qt，/w也/d是/vshi对/p每/rz16/nz位/q（/w2/nz字节/gi）/w进行/vn二进制/gi反码/n求和/vi。/w接收/gi方/q计算/gi校验/v和/cc时/qt的/ude1首部/gi与/cc发送/gi方/q计算/gi校验/v和/cc时/qt的/ude1首部/gi相比/vi，/w多/a了/ule一个/mq发送/gi方/q计算出来/l的/ude1校验/v和/cc的/ude1反码/n。/w因此/c，/w如果/c首部/gi在/p传输/gi过程/gi中/f没有/v发生/v差错/n，/w那么/c接收/gi方/q计算/gi的/ude1结果/n应该/v为/p全/a一/nz。/w