#python /nz排序/gisorted/nz(/nz)/nz
排序算法/gi排序/gi也/d是/vshi在/p程序/gi中/f经常/d用/p到/v的/ude1算法/gi。/w无论/c使用/gi冒泡排序/gi还是/c快速排序/gi，/w排序/gi的/ude1核心/n是/vshi比较/gi两/nz个/q元素/gi的/ude1大小/n。/w如果/c是/vshi数字/gi，/w我们/rr可以/v直接/ad比较/gi，/w但/c如果/c是/vshi字符串/gi或者/c两/nz个/qdict/nz呢/y？/w直接/ad比较/gi数学/gi上/f的/ude1大小/n是/vshi没有/v意义/n的/ude1，/w因此/c，/w比较/gi的/ude1过程/gi必须/d通过/p函数/gi抽象/gi出来/vf。/w通常/d规定/n，/w对于/p两/nz个/q元素/gi和/cc，/w如果/c认为/v，/w则/d返回/v，/w如果/c认为/v，/w则/d返回/v，/w如果/c认为/v，/w则/d返回/v，/w这样/rzv，/w排序算法/gi就/d不用/d关心/v具体/a的/ude1比较/gi过程/gi，/w而是/c根据/p比较/gi结果/n直接/ad排序/gi。/wpython/gi内置/vn的/ude1函数/gi就/d可以/v对/plist/gi进行/vn排序/gi：/w此外/c，/w函数/gi也/d是/vshi一个/mq高阶/nz函数/gi，/w它/rr还/d可以/v接收/gi一个/mq比较/gi函数/gi来/vf实现/gi自定义/nz的/ude1排序/gi。/w比如/v，/w如果/c要/v倒序/nz排序/gi，/w我们/rr就/d可以/v自定义/nz一个/mq函数/gi：/w传入/gi自定义/nz的/ude1比较/gi函数/gi，/w就/d可以/v实现/gi倒序/nz排序/gi：/w我们/rr再/d看/v一个/mq字符串/gi排序/gi的/ude1例子/gi：/w默认/v情况下/nz，/w对/p字符串/gi排序/gi，/w是/vshi按照/pascii/gi的/ude1大小/n比较/gi的/ude1，/w由于/p，/w结果/n，/w大写/n字母/gi会/v排在/v小写字母/nz的/ude1前面/f。/w现在/t，/w我们/rr提出/v排序/gi应该/v忽略/v大小写/gi，/w按照/p字母/gi序/n排序/gi。/w要/v实现/gi这个/rz算法/gi，/w不必/d对/p现有/v代码/gi大加/d改动/vn，/w只要/c我们/rr能/v定义出/n忽略/v大小写/gi的/ude1比较/gi算法/gi就/d可以/v：/w忽略/v大小写/gi来/vf比较/gi两/nz个/q字符串/gi，/w实际上/d就是/v先/d把/pba字符串/gi都/d变成/v大写/n（/w或者/c都/d变成/v小写/n）/w，/w再/d比较/gi。/w这样/rzv，/w我们/rr给/p传入/gi上述/b比较/gi函数/gi，/w即可/v实现/gi忽略/v大小写/gi的/ude1排序/gi：/w从/p上述/b例子/gi可以/v看出/v，/w高阶/nz函数/gi的/ude1抽象/gi能力/gi是/vshi非常/d强大/a的/ude1，/w而且/c，/w核心/n代码/gi可以/v保持/v得/ude3非常/d简洁/gi。/w