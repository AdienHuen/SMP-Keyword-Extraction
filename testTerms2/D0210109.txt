#设计模式/nz(/nz行为/n型/k)/nz之/uzhi策略模式/gi(/nzStrategy Pattern/nz)/nz
ps/nz一句/nz：/w最终/d还是/c选择/gicsdn/gi来/vf整理/gi发表/v这/rzv几年/nz的/ude1知识点/gi，/w该/rz文章/gi平行/vi迁移/gi到/vcsdn/gi。/w因为/ccsdn/gi也/d支持/vmarkdown/nz语法/gi了/ule，/w牛逼/nz啊/y！/w【/w工匠/nnd若/c水/n /x】/w /x阅读/gi前/f一/nz篇/q《/w设计模式/nz(/nz行为/n型/k)/nz之/uzhi迭代器模式/gi(/nziterator pattern/nz)/nz》/w概述/gi使用/gi策略模式/gi可以/v定义/gi一/nz些/q独立/a的/ude1类/gi来/vf封装/gi不同/a的/ude1算法/gi，/w每/rz一个/mq类/gi封装/gi一种/nz具体/a的/ude1算法/gi，/w在/p这里/rzs，/w每/rz一个/mq封装/gi算法/gi的/ude1类/gi我们/rr都/d可以/v称之为/v一种/nz策略/gi(/nzstrategy/gi)/nz，/w为了/p保证/v这些/rz策略/gi在/p使用/gi时/qt具有/v一致性/gi，/w一般/ad会/v提供/v一个/mq抽象/gi的/ude1策略/gi类/gi来/vf做/v规则/gi的/ude1定义/gi，/w而/cc每种/r算法/gi则/d对应/vi于/p一个/mq具体/a策略/gi类/gi。/w策略模式/gi的/ude1主要/b目的/gi是/vshi将/d算法/gi的/ude1定义/gi与/cc使用/gi分开/vi，/w将/d算法/gi的/ude1定义/gi放在/v专门/d的/ude1策略/gi类/gi中/f，/w每/rz一个/mq策略/gi类/gi封装/gi了/ule一种/nz实现/gi算法/gi，/w使用/gi算法/gi的/ude1环境/n类/gi针对/gi抽象/gi策略/gi类/gi进行/vn编程/gi，/w符合/v“/w依赖倒转原则/gi”/w。/w在/p出现/v新的/a算法/gi时/qt，/w只/d需要/v增加/v一个/mq新的/a实现/gi了/ule抽象/gi策略/gi类/gi的/ude1具体/a策略/gi类/gi即可/v。/w核心/n概念/gi：/w /x定义/gi一系列/b算法/gi类/gi，/w将/d每/rz一个/mq算法/gi封装/gi起来/vf，/w并/cc让/v它们/rr可以/v相互/d替换/v，/w策略模式/gi让/v算法/gi独立/a于/p使用/gi它/rr的/ude1客户/n而/cc变化/gi，/w也/d称为/v政策/n模式/gi(/nzpolicy/nz)/nz。/w策略模式/gi是/vshi一种/nz对象/gi行为/n型/k模式/gi。/w策略模式/gi结构/gi重要/a核心/n模块/gi：/wcontext/nz（/w环境/n类/gi）/w环境/n类/gi是/vshi使用/gi算法/gi的/ude1角色/gi，/w它/rr在/p解决/v某个/rz问题/gi（/w即/v实现/gi某个/rz方法/gi）/w时/qt可以/v采用/v多/a种/q策略/gi。/w在/p环境/n类/gi中/f维持/v一个/mq对/p抽象/gi策略/gi类/gi的/ude1引用/gi实例/gi，/w用于/v定义/gi所/usuo采用/v的/ude1策略/gi。/wstrategy/gi（/w抽象/gi策略/gi类/gi）/w它/rr为/p所/usuo支持/v的/ude1算法/gi声明/gi了/ule抽象/gi方法/gi，/w是/vshi所有/b策略/gi类/gi的/ude1父类/nz，/w它/rr可以/v是/vshi抽象类/gi或/c具体/a类/gi，/w也/d可以/v是/vshi接口/gi。/w环境/n类/gi通过/p抽象/gi策略/gi类/gi中/f声明/gi的/ude1方法/gi在/p运行/gi时/qt调用/gi具体/a策略/gi类/gi中/f实现/gi的/ude1算法/gi。/wconcretestrategy/nz（/w具体/a策略/gi类/gi）/w它/rr实现/gi了/ule在/p抽象/gi策略/gi类/gi中/f声明/gi的/ude1算法/gi，/w在/p运行/gi时/qt，/w具体/a策略/gi类/gi将/d覆盖/gi在/p环境/n类/gi中/f定义/gi的/ude1抽象/gi策略/gi类/gi对象/gi，/w使用/gi一种/nz具体/a的/ude1算法/gi实现/gi某个/rz业务/gi处理/vn。/w使用场景/gi一个/mq系统/gi需要/v动态/gi地/ude2在/p几/d种/q算法/gi中/f选择/gi一种/nz，/w那么/c可以/v将/d这些/rz算法/gi封装/gi到/v一个/mq个/q的/ude1具体/a算法/gi类/gi中/f，/w而/cc这些/rz具体/a算法/gi类/gi都/d是/vshi一个/mq抽象/gi算法/gi类/gi的/ude1子类/gm。/w换言之/cc，/w这些/rz具体/a算法/gi类/gi均/d有/vyou统一/vn的/ude1接口/gi，/w根据/p“里氏/nz代换/v原则”/nz和/cc面向对象/gi的/ude1多态性/gb，/w客户端/gi可以/v选择/gi使用/gi任何/rz一个/mq具体/a算法/gi类/gi，/w并/cc只/d需要/v维持/v一个/mq数据类型/gi是/vshi抽象/gi算法/gi类/gi的/ude1对象/gi。/w一个/mq对象/gi有/vyou很/d多/a的/ude1行为/n，/w如果/c不用/d恰当/a的/ude1模式/gi，/w这些/rz行为/n就/d只好/d使用/gi多重/b条件/n选择/gi语句/gi来/vf实现/gi。/w此时/r，/w使用/gi策略模式/gi，/w把/pba这些/rz行为/n转移/v到/v相应/vi的/ude1具体/a策略/gi类/gi里面/f，/w就/d可以/v避免/v使用/gi难以/d维护/gi的/ude1多重/b条件/n选择/gi语句/gi。/w不/d希望/v客户端/gi知道/v复杂/a的/ude1、/w与/cc算法/gi相关/vn的/ude1数据结构/gi，/w在/p具体/a策略/gi类/gi中/f封装/gi算法/gi与/cc相关/vn的/ude1数据结构/gi，/w可以/v提高/v算法/gi的/ude1保密性/n与/cc安全性/gi。/w程序猿/nr实例/gi如下/vi示例/gi是/vshi一个/mq简单/a的/ude1策略模式/gi实例/gi程序/gi（/w模拟/gi一个/mqandroid/gi程序猿/nr到底/d选择/gi使用/gijava/gi、/wweb/gi还是/cc语言/gi来/vf开发/gi这款/r应用/gi）/w，/w不/d做/v过多/d解释/gi：/w总结/gi一/nz把/pba策略模式/gi优点/gi：/w策略模式/gi完全符合/nz“/w开闭/nz原则/gi”/w。/w策略模式/gi提供/v了/ule管理/gi相关/vn算法族/nz的/ude1办法/gi。/w恰当/a使用/gi继承/gi可以/v把/pba公共/b的/ude1代码/gi移到/vf抽象/gi策略/gi类/gi中/f，/w从而/c避免/v重复/gi的/ude1代码/gi。/w策略模式/gi提供/v了/ule一种/nz可以/v替换/v继承/gi关系/gi的/ude1办法/gi。/w如果/c不/d使用/gi策略模式/gi，/w那么/c使用/gi算法/gi的/ude1环境/n类/gi就/d可能会/nz有/vyou一些子/nz类/gi，/w每/rz一个子/nz类/gi提供/v一种/nz不同/a的/ude1算法/gi。/w但是/c，/w这样一来/dl算法/gi的/ude1使用/gi就/d和/cc算法/gi本身/rz混/v在/p一起/s，/w不/d符合/v“/w单一/gi职责/gi原则”/nz，/w而且/c使用/gi继承/gi无法/v实现/gi算法/gi或/c行为/n在/p程序运行/n时/qt的/ude1动态/gi切换/vn。/w使用/gi策略模式/gi可以/v避免/v多重/b条件/n选择/gi语句/gi。/w策略模式/gi缺点/gi：/w客户端/gi必须/d知道/v所有/b的/ude1策略/gi类/gi，/w并/cc自行决定/l使用/gi哪/ry一个/mq策略/gi类/gi。/w策略模式/gi将/d造成/v系统/gi产生/v很/d多/a具体/a策略/gi类/gi，/w任何/rz细小/a的/ude1变化/gi都/d将/d导致系统/n要/v增加/v一个/mq新的/a具体/a策略/gi类/gi。/w无法/v同时/c在/p客户端/gi使用/gi多/a个/q策略/gi类/gi，/w也/d就是说/c，/w在/p使用/gi策略模式/gi时/qt，/w客户端/gi每次/r只能/v使用/gi一个/mq策略/gi类/gi，/w不/d支持/v使用/gi一个/mq策略/gi类/gi完成/v部分/n功能/gi后/f再/d使用/gi另一个/nz策略/gi类/gi来/vf完成/v剩余/vn功能/gi的/ude1情况/n。/w【/w工匠/nnd若/c水/n /x】/w /x继续/v阅读/gi《/w设计模式/nz(/nz行为/n型/k)/nz之/uzhi命令模式/gi(/nzcommand pattern/nz)/nz》/w /x