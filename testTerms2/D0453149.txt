#codeforces /nz#/nz285/nz div/nz2/nz /x*/nzA B /nz*/nzC/nz
总结/gi的/ude1来说/uls，/w这次/r还是/c只有/c一道/d题/n，/w但是/c我/rr是/vshi属于/v被/pbei第一/mq题/n坑/n了/ule。/wproblem a/nz题目/gi概述/gi：/w简单/a到/v死/v的/ude1代码/gi题/n，/w就是/v题目/gi给/p你/rr一个式/nz子/ng，/w然后/c让/v你/rr按照/p这个/rz式/k子/ng算/v给定/gi的/ude1数/n，/w之后/f比较/gi大小/n。/w算法/gi思想/gi：/w别问/nz我/rr为什么/ryv错/v了/ule.../w./nz因为/c我/rr在/pdouble/nz之间/f判断/gi了/ule大小/n.../w./nz忽略/v了/ule题目/gi中所/j给/p的/ude1其/rz一定/b能/v被/pbei250/nz整除/v卧槽/nz。/w但是/c其实/d看/v很/d多/a人/ndouble/nz写上去/v也/d对了/vl，/w这/rzv可能/v是因为/c他们/rr算/v3/nz//nz10/nz的/ude1时候/n是/vshi3/nz*/nzdouble/nz//nz10/nz，/w我/rr是/vshidouble/nz*/nz0.3。/nz应该/v是/vshi编译器/gi内部/f的/ude1一些/m问题/gi嗯/e。/w代码/gi部分/n：/wproblem b/nz题目/gi概述/gi：/w不想/v写/v概述/gi啊/y不想/v写/v，/w大意/n就是/v给定/gi一/nz些/q字符串/gi的/ude1链接/gi组合/gi，/w如果/c给定/gi了/uleb/nz-/nzc/nz且/c之前/f有/vyoua/nz-/nzb/nz的话/udh就/d把/pba它/rr替换成/ia/nz-/nzc/nz的/ude1组合/gi。/w算法/gi思想/gi：/w我/rr用/p的/ude1方法/gi比较/gi水/n，/w有/vyou一次/nz开/v了/ule两/nz个/qmap/nz来/vf做/v双向/b记录/gi，/w开始/v给/pa/nz-/nzb/nz组合/gi的话/udh就/d把/pbapaira/nz,/nzb/nz插到/nz第一个/gimap/nz，/w把/pbapairb/nz,/nza/nz插入/gi第二个/nzmap/nz，/w这样/rzv给定/gib/nz-/nzc/nz时候/n的话/udh就/d到/v第二个/nzmap/nz里面/f检查/gi是否/v有/vyoub/nz，/w然后/c有的/rz话做/nz替换/v操作/gi，/w没有/v的话/udh模仿/gi第一次/nz插入/gi就/d好/a了/ule。/w代码/gi部分/n：/wproblem c/nz题目/gi概述/gi：/w好/a了/ule，/w终于/d到/v了/ule我/rr比赛/vn时候/n彻底/ad不会/v做/v的/ude1一道/d题/n。/w这/rzv道/qv题/n是/vshi说/v所/usuo给/p的/ude1是/vshi一个/mq无向无环/nz图/gi，/w现在/t给定/gi每一个/nz顶点/gi的/ude1degree /nz(/nz有/vyou几/d个/q顶点/gi和/cc他/rr相连/vi)/nz，/w以及/cc它/rr相邻/vi顶点/gi的/ude1亦/d或/c和/cc，/w要求/n把/pba所有/b边/k都/d输出/gi出来/vf。/w算法/gi思想/gi：/w开始/v读/v这/rzv道/qv题/n的/ude1时候/n心里/s想/v的/ude1是/vshi卧槽/nz这/rzvtm/nz是/vshi啥/ry啊/y这/rzv能算/nz。/w当然/d到/v比赛/vn结束/v的/ude1时候/n心里/s都/d是/vshi这么/rz想/v的/ude1。/w一直/d到/v今天/t去/vf查/v题解/n，/w然后/c终于/d明白/v了/ule，/w卧槽/nz原来/d是/vshi这么/rz一回事/nz。/w首先/d题目/gi是/vshi一个/mq无环/nz图/gi！/w无/v环/n！/w那/rzv就/d说明/v必然/d存在/v有/vyou一个/mq点/gi的/ude1degree/nz是/vshi为/p1/nz的/ude1！/w那么/c去掉/v这个/rz点/gi（/w把/pba与/cc之/uzhi相连/vi的/ude1点/gi的/ude1degree/nz-/nz1/nz，/wxum/nz减去/v这个/rz点/gi的/ude1index/nz）/w剩下/v的/ude1肯定/v还是/c一个/mq无/v！/w环/n！/w图/gi！/w那么/c肯定/v还/d存在/v有/vyou一个/mq点/gidegree/nz为/p1/nz，/w所以/c重复/gi上述/b操作/gi！/w卧槽/nz然后/c就/d做出/v来/vf了/ule。/w得/ude3注意/v的/ude1是/vshi在/p队列/gi里面/f有可能/nz加进去/v的/ude1时候/ndegree/nz为/p1/nz，/w但是/c前/f一个/mq剪/v完/vi之后/fdegree/nz就/d为/p0/nz了/ule，/w这种/r情况/n要/v跳过/v。/w代码/gi部分/n：/w