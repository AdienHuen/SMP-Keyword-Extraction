#C++/giprimer/nz--泛/nz型/k算法/gi初识/n
在/p这里/rzs，/w我/rr想/v说/v的/ude1重点/n是/vshi对于/p泛型/gi算法/gi，/w他/rr的/ude1特点/n是/vshi不/d直接/ad操纵/gi容器/gi，/w这/rzv是/vshi最主要/nz的/ude1特点/n，/w这/rzv也/d就/d意味着/v他/rr不会/v直接/ad对/p容器/gi进行/vn操作/gi。/w /x例如/v容器/gi的/ude1增删/v改移/nz，/w算法/gi接受/gi的/ude1是/vshi迭代器/nz，/w对/p迭代/gi以及/cc接收/gi到/v的/ude1迭代器/nz范围/n元素/gi进行/vn算法/gi处理/vn，/w而/cc在/p这个/rz过程/gi中/f，/w就算/d容器/gi发生/v了/ule元素/gi的/ude1增删/v改移/nz的/ude1事件/gi，/w算法/gi对/p容器/gi也/d不/d负责/v，/w主要/b是/vshi迭代器/nz的/ude1责任/n，/w这/rzv也/d是/vshi算法/gi的/ude1特殊/a之处/r。/w前/f两/nz个/q小/a节/q的/ude1主要/b算法/gi如下/vi：/w测试/gi结果/n如下/vi：/w          /x对于/p结果/n主要/b有/vyou两/nz点/gi解释/gi：/w     /x-/nz /x1./nz /x对于/p上面/f的/ude1sort/gi一次/nz排序/gi后/f倒数/v第二行/nz出现/v有序/gi的/ude1结果/n，/w然后/c在/p使用/giunique/nz算法/gi后/f出现/v的/ude1显示/gi是/vshi这么/rz的/ude1原理/gi，/w因为/cunique/nz的/ude1作用/gi是/vshi去除/v排序/gi后/f的/ude1相等/vi重复/gi元素/gi，/w只/d留下/v一个/mq。/w但是/c算法/gi对/p容器/gi是/vshi不会/v具有/v真正/d的/ude1操作/gi权限/gi的/ude1 /x，/w他/rr只是/d操纵/gi迭代器/nz对/p容器/gi进行/vn操作/gi，/w在/p这个/rz过程/gi中/f，/w算法/gi根本/a就/d不/d知道/v容器/gi这个/rz玩意儿/nz，/w所以/c在/p去除/v重复/gi元素/gi后/f将/d其余/rz元素/gi按照/p顺序/gi依次/d排列/gi，/w但是/c这个/rz过程/gi中/f，/w容器/gi的/ude1元素/gi数量/n是/vshi不会/v发生/v改变/v的/ude1，/w所以/c后面/f会/v出现/v什么/ry算法/gi是/vshi不/d知道/v的/ude1剩下/v的/ude1就是/v，/w迭代器/nz的/ude1事/n了/ule。/w