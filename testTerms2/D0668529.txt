#大话/n设计模式/nz学习/gi篇--简单/nz工厂模式/gi
1/nz /x以/p一个/mq计算器/gi例子/gi引入/v将/d数据/gi的/ude1输入/v和/cc计算/gi(/nz加减乘除/nz等/udeng)/nz都/d写入/gi主函数/nz体内/s，/w代码/gi难以/d得到/v复用/gi。/w2/nz /x业务封装/gi将/d业务逻辑/gi(/nz计算/gi逻辑/n)/nz与/cc界面/gi输入/v分隔/vi开/v，/w将/d业务逻辑/gi独立/a到/v类/gi当中/f。/w3/nz /x业务/gi的/ude1继承/gi与/cc多态/gi在/p第二部分/nz，/w计算/gi逻辑/n被/pbei独立/a在/p一个/mq类/gi当中/f，/w实现/gi了/ule封装/gi，/w但/c这/rzv还/d远远/d不够/a。/w现实/n情况下/nz，/w业务逻辑/gi通常/d会/v发生变化/l，/w如果/c整体/n的/ude1业务逻辑/gi均/d放在/v一个/mq类/gi下/f，/w那么/c业务/gi的/ude1修改/gi将/d面临/v很/d多/a风险/gi。/w这个/rz时候/n，/w可/v采用/v继承/gi和/cc多态/gi的/ude1方式/n解决/v。/w首先/d，/w对/p业务逻辑/gi（/w计算/gi过程/gi）/w实现/gi抽象/gi；/w之后/f，/w让/v各个/rz过程/gi继承/gi这/rzv一/nz抽象/gi，/w并/cc独立/a实现/gi；/w最终/d，/w当/p需要/v增加/v新逻辑/nz时/qt，/w只需/v继承/gi这/rzv一/nz抽象/gi，/w并/cc独立/a实现/gi自己/rr的/ude1逻辑/n。/w4/nz /x简单工厂模式/gi用/p一个/mq独立/a的/ude1类/gi来/vf完成/v实例/gi的/ude1创建/gi。/w简单工厂模式/gi实际上/d是/vshi对/p实例化/gi的/ude1细节/gi进行/vn封装/gi。/w下面/f是/vshi一个/mq比较/gi好/a的/ude1例子/gi，/w摘自/v博客/gi：/w