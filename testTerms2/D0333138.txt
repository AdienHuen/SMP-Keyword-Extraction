#重构/gi小结/n―/w―/w从/p传参/nz到/v传/v实体/n，/w从/pdatatable/nz到/v泛型/gi
 /x在/p介绍/gi这些/rz内容/gi之前/f，/w我们/rr首先/d来/vf了解/v什么/ry是/vshi面向对象/gi，/w面向对象/gi的/ude1核心/n是/vshi什么/ry？/w一/nz、/w面向对象/gi的/ude1简单/a介绍/gi /x起初/d，/w“/w面向/v”/w是/vshi专指/n在/p中/f采用/v、/w、/w等/udeng设计/gi方法/gi。/w但/c，/w后来/t面向对象/gi的/ude1思想/gi设计/gi到/v了/ule各个方面/l。/w一切/rz事物/n皆/d对象/gi，/w通过/p面向对象/gi的/ude1方式/n，/w将/d现实/n世界/gi的/ude1事物/n抽象/gi成/v对象/gi，/w现实/n世界/gi中的/v关系/gi抽象/gi成/v类/gi、/w，/w帮助/v人们/n实现/gi对/p现实/n世界/gi的/ude1与/cc数字/gi建模/gi。/w通过/p面向对象/gi的/ude1方法/gi，/w更/d利于/v用/p人/n理解/gi的/ude1方式/n对/p复杂/a系统/gi进行/vn分析/gi、/w设计/gi与/cc编程/gi。/w /x所以/c我们/rr可以/v简单/a的/ude1将/d面向对象/gi的/ude1核心/n概况/n为/p对象/gi，/w也/d可以/v说/v是/vshi类/gi。/w二/nz、/w实体/n的/ude1简单/a了解/v实体类/nz是/vshi用于/v对/p必须/d存储/gi信息/gi和/cc相关/vn行为/n建模/gi的/ude1类/gi。/w实体/n对象/gi（/w实体类/nz的/ude1实例/gi）/w用于/v保存/gi和/cc更新/gi一/nz些/q现象/n的/ude1有关/vn信息/gi。/w /x实体类/nz将/d大量/m的/ude1数据/gi进行/vn封装/gi然后/c传递/v，/w体现/v了/ule面向对象/gi程序开发/gi的/ude1思想/gi。/w在/p三层架构/gi中/f，/wu/nz层/gi和/ccb/nz层/gi的/ude1编写/gi可以/v不用/d了解/v数据库/gi的/ude1结构/gi，/w通过/p该/rz实体/n对象/gi的/ude1属性/gi把/pba所/usuo需要/v的/ude1字段/gi提取/v出来/vf。/w三/nz、/w在/p面向对象/gi的/ude1思想/gi下/f看/v传参/nz和/cc实体/n /x传参/nz是/vshi传递/v某/rz几个字/nz段/q，/w而/cc面向对象/gi是/vshi对/p对象/gi的/ude1操作/gi。/w而/cc这些/rz字段/gi可以/v看做/v对象/gi的/ude1一些/m属性/gi，/w将/d这些/rz字段/gi封装/gi为/p一个/mq实体类/nz。/w所以/c在/p面向对象/gi的/ude1思想/gi中/f，/w我们/rr选择/gi了/ule用/p实体/n代替/v参数/gi进行/vn传递/v。/w三/nz、/w三层架构/gi中/f查询/gi返回/v实体/n还是/c返回/vdatatabledatatabel/nz是/vshi个/q数据/gi集/q，/w相当于/v数据表/gi在/p内存/gi中的/v映射/gi，/w是/vshi一个/mq临时/gi保存/gi数据/gi的/ude1网/n虚拟表/nz。/w它/rr是/vshid/nz层/gi与/cc数据库/gi交互/gi得到/v的/ude1产物/n。/w它/rr的/ude1特点/n是/vshi：/wdatatabel/nz是/vshi弱/a类型/gi，/w围绕/v数据库/gi编程/gi的/ude1。/wdatatable/nz在/p使用/gi时/qt，/w需要/v了解/v数据库/gi的/ude1结构/gi，/w比如/v，/w我们/rr想要/v获得/v某个/rz字段/gi的/ude1，/w就/d必须/d知道/v它/rr在/p数据表/gi中的/v第几个字/nz段/q，/w例/n：/wdatatable/nz./nzrows/nz(/nz1/nz)/nz./nzitem/nz(/nz2/nz)/nz等/udeng。/w但/cb/nz层/gi和/ccu/nz层/gi是/vshi不/d涉及/v数据库/gi的/ude1，/w所以/c我们/rr用/p传/v实体/n来/vf代替/vdatatabel/nz。/w四/nz、/wdatatable/nz到/v实体/n的/ude1转换/gi datatable/nz到/v实体/n的/ude1转换/gi我们/rr用/p到/v了/ule泛型/gi集合/gi。/w把/pbadatatable/nz中的/v每/rz一行/n记录/gi视为/v一个/mq实体类/nz，/w把/pba其中/rz的/ude1字段/gi读取/gi出来/vf，/w存放/v到/v实体类/nz的/ude1属性/gi中/f，/w再/d把/pba所有/b的/ude1实体类/nz存在/v泛型/gi集合/gi中/f。/w因此/c，/wdatatable/nz中/f有/vyou多少/ry个/q记录/gi，/w泛型/gi集合/gi中/f就/d有/vyou多少/ry个/q实体类/nz，/w每个/r实体类/nz的/ude1属性/gi和/ccdatatable/nz的/ude1字段/gi是/vshi相/d对应/vi的/ude1。/w五/nz、/w总结/gi /x对于/p单表/nz查询/gi，/w可以/v将/ddatatable/nz与/cc某个/rz实体类/nz对应/vi，/w但是/c如果/c多/a表/n查询/gi呢/y，/w没有/v实体类/nz与/cc之/uzhi对应/vi，/w没有/v实体类/nz就/d没有/v办法/gi转换/gi，/w我们/rr再/d建立/gi一个/mq差不多/al的/ude1实体/n？/w /x目前/t比/p普遍/ad的/ude1解决方案/gi就是/v创建/gi一个/mq包含/v多/a个/q表/n的/ude1实体类/nz，/w只要/c实体类/nz中/f包含/v联合/gi查询/gi的/ude1这些/rz表/n就/d可以/v。/w但是/c这样/rzv效率/gi没/ddatatable/nz高/a。/w所以/c如何/ryv合理/a的/ude1使用/gi实体/n与/ccdatatable/nz呢/y？/w我们/rr可以/v看看/v这/rzv篇文章/n