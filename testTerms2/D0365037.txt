#redis/gi源码/gi学习/gi（/w集群/gi）/w
集群/gi是/vshi一种/nz分布式/gi的/ude1思想/gi，/w把/pba数据存储/gi到/v各个/rz节点/gi上去/vf提供/v服务/gi。/w分布式/gi一个/mq重要/a的/ude1步骤/gi，/w就是/v分片/gi。/w那/rzvredis/gi集群/gi是/vshi怎么/ryv分片/gi的/ude1呢/y，/w以及/cc集群/gi服务/gi的/ude1稳定性/n和/cc可靠性/gi怎么/ryv保证/v。/w下面/f就/d来/vf剖析/gi下/f。/w1./nz /x集群/gi是/vshi怎么/ryv创建/gi的/ude1，/w分片/gi怎么/ryv设计/gi的/ude1？/w分片/gi原理/gi：/wredis/gi的/ude1核心/n数据/gi是/vshi个/qhash table/nz，/w分片/gi是/vshi按照/pkey/gi来/vf划分/v，/w再/dreds/nz里面/f叫/vi槽/ng(/nzslot/nz)/nz，/w集群/gi中的/v各个/rz节点/gi都会/n分/qt一/nz些/q槽/ng，/w用于/v存储/gi它们/rr的/ude1数据/gi。/w客户端/gi在/p请求/gi集群/gi的/ude1服务/gi时候/n，/w通过/p查询/gi的/ude1key/gi，/w算出/vf一个/mqhash/gi，/w再/d使用/gihash/gi％/w槽/ng数/n得到/v第几/nz个/q槽/ng，/w再/d通过/p对应/vi槽找/nz对应/vi节点/gi，/w进行/vn查询/gi或者/c更新/gi操作/gi。/w基本/a数据结构/gi：/w集群/gi节点/gi：/w这个/rz是/vshi集群/gi的/ude1原子结构/n每个/r集群/gi节点/gi都/d有/vyou一个/mq对应/vi集群/gi状态/gi的/ude1记录/gi，/w并且/cserver/gi端/v属性/gi纪录/n的/ude1是/vshi集群/gi的/ude1状态/gi。/w创建/gi过程/gi：/wredis/gi./nzc/nz---int main---initserver---/nzclusterinit/nz函数/gi：/w2./nz /x集群/gi是/vshi如何/ryv工作/gi的/ude1，/w但/c一个/mq命令/gi过来/vf，/w集群/gi是/vshi如何/ryv执行命令/n的/ude1？/w数据库/gi中的/v所有/b的/ude1槽/ng，/w比如说/vl是/vshi16384/nz个/q，/w都/d进行/vn了/ule指派/gi，/w集群/gi就/d会/v进入/v上线/n状态/gi，/w这时/rzt客户端/gi可以/v像/v集群/gi中的/v节点/gi发送数据/n命令/gi了/ule。/w详细/gi的/ude1工作原理/gi：/w1/nz）/w一个/mq命令/gi过来/vf，/w首先/d得到/v此/rzs命令/gi要/v查/v的/ude1key/gi，/w通过/pkey/gi计算/gi它/rr属于/v哪个/ry槽/ng。/w2/nz）/w先/d看看/v当前/t节点/gi有/vyou没有/v这个/rz槽/ng，/w如果/c有/vyou直接/ad查询/gi或/c操作/gi此/rzs节点/gi，/w并/cc返回/v消息/n给/p客户端/gi。/w3/nz）/w如果/c此/rzs节点/gi没有/v，/w那么/c节点/gi会/v向/p客户端/gi返回/v一个/mqmoved/nz错误/gi，/w指引/vn客户端/gi转向/vi至/p正确/a的/ude1节点/gi，/w并且/c再次/d发送/gi命令/gi，/w并/cc返回/v结果/n。/w3./nz /x故障/gi转移/v  /x集群/gi中的/v节点/gi可以/v设置/gi为主/vi从/p模式/gi，/w这样/rzv实现/gi了/ule重要/a数据/gi的/ude1备份/gi，/w单一个/nz节点/gi发生/v故障/gi的/ude1时候/n，/w可以/v把/pba此/rzs节点/gi下线/n，/w使用/gi它/rr的/ude1备份/gi节点/gi（/w从/p节点/gi）/w继续/v工作/gi，/w不/d影响/gi集群/gi的/ude1操作/gi。/w4./nz /x为什么/ryv要用/v集群/gi集群/gi的/ude1好处/gi有/vyou两/nz点/gi，/w1/nz）/w能/v存储/gi更大/d的/ude1数据量/n，/wredis/gi是/vshi内存数据库/gi，/w内存/gi的/ude1资源/gi有限/a，/w使用/gi集群/gi可以/v达到/v大数据量/gi的/ude1存储/gi。/w2/nz）/w效率/gi更高/d，/w当然/d这个/rz是/vshi对于/p一定/b规模/gi的/ude1数据/gi来说/uls。/w数据量/n小/a的话/udh，/w也/d要/v分库/gi，/w中间/f调度/vn的/ude1损耗/vn也挺/nz大/a的/ude1。/w分库/gi集群/gi，/w相当于/v多/a点/gi处理/vn，/w能够/v并发/gi进行/vn，/w效率/gi当然/d高/a多/a了/ule。/w5./nz /x为啥/rmysql/gi没法/v实现/gi集群/gi，/w只能/v使用/gi分表/n，/w这种/r复杂/a的/ude1处理/vn逻辑/n？/w这个/rz更/d数据存储/gi结构/gi有/vyou关系/gi，/wredis/gi是/vshihash table/nz结构/gi，/w而/ccmysql/gi底层/n结构/gi是/vshib/nz树/gi，/whash/gi表/n好/a拆分/gi，/wb/nz树/gi不好/a拆/v。/wmysql/gi分表/n逻辑/n就/d比较复杂/l了/ule，/w有/vyou垂直/gi拆分/gi和/cc水平/n拆分/gi，/w垂直/gi简单/a点/gi，/w水平/n复杂/a些/q，/w但是/c所有/b的/ude1拆分/gi，/w都/d涉及/v到/v调用/gi的/ude1修改/gi。/w如果/c前端/gi直接/ad调用/gi的话/udh，/w那/rzv改/v动量/n就/d大/a了/ule。/w