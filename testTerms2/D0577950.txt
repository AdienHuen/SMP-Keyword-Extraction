#算法/gi之/uzhi七大/n经典/gi排序/gi
针对/gi现实/n中的/v排序/gi问题/gi，/w算法/gi有/vyou七/nz把/pba利剑/n可以/v助/v你/rr马道/nz成功/a。/w首先/d排序/gi分为/v四种/nz：/w   /x交换排序/gi：/w /x包括/v冒泡排序/gi，/w快速排序/gi。/w   /x选择排序/gi：/w /x包括/v直接/ad选择排序/gi，/w堆排序/gi。/w   /x插入排序/gi：/w /x包括/v直接插入排序/gi，/w希尔排序/gi。/w   /x合并/gi排序/gi：/w /x合并/gi排序/gi。/w冒泡排序/gi简单/a来说/uls就是/v利用/v两/nz个/qfor/nz循环/gi来/vf进行/vn排序/gi，/w由/p前/f一个/mq数据/gi和/cc后/f一个/mq数据/gi比较/gi，/w如果/c前/f一个/mq大于/v后/f一个/mq则/d交换/gi，/w这样/rzv如果/c从头/d循环/gi一次/nz，/w就/d会/v找到/v整个/b列表/vi中/f最大/gm的/ude1那个/rz数/n，/w将/d其/rz固定/a在/p最后/f一位/nz，/w所以/c循环/gin/nz次/qv就/d能/v确定/v所有/b顺序/gi了/ule。/w快速排序/gi是/vshi冒泡排序/gi的/ude1升级版/nz，/w一般/adstl/gi里/f使用/gi的/ude1都/d是/vshi快排/nz，/w效率/gi还是/c可以/v的/ude1。/w主要/b思想/gi就是/v选择/gi第一个/gi数/n为/p标准/gi数/nb/nz，/w先/d从/p右/f开始/v找/v，/w找/v一个/mq比/pb/nz小/a的/ude1数/n赋/ng给/pleft/nz位/q上/f的/ude1数/n，/w也/d就是/vb/nz，/w之后/f从/p左/f开始/v找/v，/w找/v一个/mq比/pb/nz大/a的/ude1数/n与/ccright/nz位/q上/f的/ude1数/n，/w因为/cright/nz位/q上/f的/ude1数/n已经/d赋/ng给/pleft/nz了/ule，/w所以/c其中/rzright/nz位置/gi上/f的/ude1数/n是/vshi多余/gi的/ude1，/w之后/f只要/cleftright/nz就/d循环/gi下去/vf，/w当/pleft /nz=/nz=/nz right/nz的/ude1时候/n，/w将/db/nz赋/ng在/pleft/nz位/q上/f，/w现在/t的/ude1局面/n就是/vleft/nz左边/f都/d是/vshi比/pb/nz小/a的/ude1，/wleft/nz右边/f都/d是/vshi比/pb/nz大/a的/ude1。/w然后/c在/p分别/d求/v两边/f的/ude1快排/nz，/w写/v一个/mq小递/nz归/v就/dok/nz了/ule，/w递归/gi的/ude1退出/gi条件/n就是/vleftright/nz,/nz其实/d就是/v已经/d将/d列表/vi分解成/n单个/b数据/gi的/ude1时候/n就/d退出/gi递归/gi，/w返回/v数据/gi。/wjava/gi版/n