#设计模式/nz /x-/nz /x适配器模式/gi
  /x适配器模式/gi，/w将/d一个/mq类/gi的/ude1接口/gi转换成/i客户/n希望/v的/ude1另外/c一个/mq接口/gi。/w适配器模式/gi使得/vi原本/d由于/p接口/gi不/d兼容/vi，/w而/cc不能/v一起/s工作/gi的/ude1那些/rz类/gi，/w可以/v一起/s工作/gi。/w  /x在/p开发/gi时/qt，/w当/p系统/gi的/ude1数据/gi和/cc逻辑/n都/d正确/a，/w但/c接口/gi不符/v时/qt，/w可以/v考虑/v使用/gi适配器/n，/w目的/gi是/vshi使/v控制/vn范围/n之外/f的/ude1一个/mq原有/v对象/gi，/w与/cc某个/rz接口/gi匹配/gi。/w  /x主要/b有/vyou两/nz种/q适配器模式/gi类型/gi：/w类/gi适配器/n、/w对象/gi适配器/n。/w类/gi适配器/n采用/v多重/b继承/gi，/w而/cc对象/gi适配器/n采用/v组合/gi接口类/n。/w对象/gi适配器模式/gi更为/d通用/gi一/nz些/q，/w以下/f就是/v它/rr的/ude1uml结构图/gi：/w  target/nz，/w客户/n所/usuo期待/v的/ude1接口类/n，/w可以/v是/vshi具体/a类/gi，/w也/d可以/v是/vshi抽象类/gi。/w  adaptee/nz，/w需要/v被/pbei适配/nz的/ude1类/gi，/w其/rz接口/gi与/cc客户/n所/usuo期待/v的/ude1接口/gi不/d兼容/vi，/w需要/v被/pbei转换/gi。/w  adapter/nz，/w适配器/n类/gi，/w做/v转换/gi工作/gi，/w内部/f维护/gi一个/mqadaptee/nz对象/gi指针/gi，/w把/pba不/d兼容/vi的/ude1adaptee/nz的/ude1接口/gi，/w转换成/i客户/n期望/vn的/ude1target/gi的/ude1接口/gi。/w  /x基本/a实现代码/gi如下/vi：/w  /x适配器模式/gi其实/d就是/v把/pba完成/v同一个/b功能/gi、/w但/c接口/gi不能/v兼容/vi的/ude1类/gi，/w桥/n接在/v一起/s，/w使/v之/uzhi可以/v协同工作/n。/w当/p我们/rr想要/v复用/gi一/nz些/q现存/v的/ude1类/gi、/w或/c是/vshi旧/a的/ude1接口/gi时/qt，/w而/cc复用/gi的/ude1环境/n又/d与/cc接口/gi的/ude1要求/n不/d一致/a，/w就/d可以/v使用/gi适配器模式/gi。/w  /x何时/ryt使用/gi适配器模式/gi？/w    /x两/nz个/q类/gi所/usuo做/v的/ude1事情/n相同/a或/c相/d、/w但有/c不同/a的/ude1接口/gi时/qt使用/gi。/w但/c适配器模式/gi不能/v滥用/v，/w一般/ad在/p开发/gi后期/f或/c维护阶段/n才/d考虑/v使用/gi，/w而/cc在/p设计/gi初期/f，/w是/vshi不必/d用/p到/v适配器模式/gi的/ude1。/w    /x一个/mq大/a的/ude1原则/gi：/w在/p使用/gi双方/n都/d不/d太/d容易/ad修改/gi的/ude1时候/n再/d使用/gi适配器模式/gi来/vf进行/vn兼容/vi匹配/gi，/w而/cc不是/c一/nz有/vyou不同/a就/d使用/gi它/rr。/w