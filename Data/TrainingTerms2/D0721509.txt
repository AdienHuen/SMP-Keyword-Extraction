#基本/a的/ude1优化规则/gi
对/p代码/gi进行/vn优化处理/gi时/qt，/w需要/v考虑/v一/nz些/q基本/a的/ude1优化规则/gi：/w1./nz在/p代码优化/gi之前/f，/w先要/b有/vyou一个/mq同一/b代码/gi的/ude1可靠/a的/ude1、/w非/b优化/gi的/ude1版本/n。/w2./nz应/v利用/v算法/gi优化/gi措施/gi，/w而/cc不是/c通过/p提升/gi系统/gi特性/gi来/vf获取/gi最大限度/nz的/ude1性能/gi提升/gi。/w3./nz不要/d将/d代码优化/gi与/cc汇编语言/gi实现/gi混为一谈/vl。/w4./nz在/p试图用/n汇编语言/gi重写/gi程序/gi之前/f，/w先/d查看/gi一/nz下/f编译器/gi生成/v的/ude1汇编/gi代码/gi并/cc估算/v它/rr的/ude1效率/gi。/w5./nz如果/c编译器/gi生成/v的/ude1汇编语言/gi列表/vi虽然/c显得/v很/d不错/a，/w但是/c程序运行/n起来/vf仍然/d很慢/d，/w就/d可以/v考虑/v将/d它/rr加载/gi到/v一个/mq反汇编/gi工具/gi之中/f去/vf。/w6./nz如果/c可用/v的/ude1处理器/gi指令/gi能够/v实现/gi比较/gi高效/b的/ude1算法/gi，/w那么/c就/d用不着/bl去/vf管/v编译器/gi而/cc可以/v着手/v去/vf实现/gi汇编/gi代码/gi。/w7./nz在/p开发/gi汇编/gi代码/gi时/qt，/w不管/c存在/v什么样/ryv的/ude1干扰/gi，/w都/d应该/v给出/v一个/mq精巧/a而/cc高效/b的/ude1方案/gi。/w