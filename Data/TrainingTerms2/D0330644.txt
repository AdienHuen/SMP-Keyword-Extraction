#纯/aC++/gi11/nz标准/gi写类/nztopk/nz算法/gi(/nz不/d稳定/an排序/gi)/nz类/gi模板/gi
topk排序/gi是/vshi指/v从/pn/nz个/q数据/gi中/f找出/v最大/gm//nz小/a的/ude1前/fk/nz个/q数据/gi,/nz并以/c升/v//nz降序/nz排列/gi,/nz本文/r讨论/gi的/ude1topk/nz与/cc这个/rz定义/gi稍/d有/vyou差别/n(/nz所以/c叫/vi类topk算法/gi)/nz:/w  /x从/pn/nz个/q数据/gi中将/nnt临时/gi计算/gi结果/nt/nz满足/v阀值/nzt/nz(/nz大于/v或/c小于/vt/nz)/nz的/ude1前/fk/nz个/q数据/gi找出/v,/nz并以/c升/v//nz降序/nz排列/gi(/nz不/d满足/v阀值/nz的/ude1t/nz不/d允许/v占用/v内存/gi)/nz。/w   /x比如/v，/w从/p今年/t中考/v成绩/gi中/f挑出/vf总成绩/n(/nz总成绩/n是/vshi根据/p各科/r成绩/gi加总/vn临时/gi计算/gi的/ude1结果/n，/w不/d允许/v保存/gi)/nz大于/v520/nz分/qt的/ude1前/f20/nz个/q学生/gi。/w如果/c有/vyou50/nz个/q大于/v520/nz的/ude1学生/gi，/w我/rr也/d只/d挑/v前/f20/nz个/q。/w如果/c只有/c10/nz个/q学生/gi总分/n大于/v520/nz，/w那么/c结果/n就是/v10/nz个/q。/w最/d适合/vtopk排序/gi的/ude1无疑/d是/vshi堆排序/gi算法/gi(/nzheap sort/nz)/nz,/nz但/c因为/c有/vyou阀值/nzt/nz的/ude1存在/v，/w而且/c加上/v”/w不/d满足/v阀值/nz的/ude1数据/gi不能/v占用/v内存/gi”/w的/ude1要求/n,/nz所以/c传统/n的/ude1堆排序/gi算法/gi并不/d适合/v(/nz建堆/nz的/ude1过程/gi要求/n临时/gi保存/gi所有/b排序/gi数据/gi)/nz。/w /x为什么/ryv会/v有/vyou”/w不/d满足/v阀值/nz的/ude1数据/gi不能/v占用/v内存/gi”/w这么/rz看似/v奇怪/v的/ude1要求/n呢/y?/nz /x比如/v在/p一个/mq数据库/gi中/f有/vyou千万级/nz至/p亿级/nz的/ude1标明/v地点/n的/ude1gps/gi位置/gi数据/gi。/w现在/t要/v从/p数据库/gi中/f找出/v距离/gi位置/gip /nz1/nz公里/q以内/f最近/t的/ude1前/f100/nz个/q地点/n。/w按/p传统/n的/ude1堆排序/gi算法/gi就要/d将/dp/nz与/cc所有/b这些/rz地点/n计算/gi出/vf距离/gi，/w然后/c在/p内存/gi中/f建堆/nz，/w排序/gi找出/vtopk/nz。/w这/rzv需要/v消耗/gi大量/m内存/gi的/ude1,/nz很/d不/d现实/n，/w也/d很/d不/d经济/gi，/w更/d没/d必要/a。/w /x合适/a的/ude1做法/n是/vshi：/w  /x建立/gi一个/mq容量/gi为/p100/nz条/q记录/gi的/ude1排序/gi缓冲区/gi数组/gisort/gi,/nz初始/b时/qt缓冲区/gi是/vshi空/ng的/ude1，/w排序/gi结果/n数目/gisize/nz为/p0。/nz   /x对/p数据库/gi中/f每个/r地址/gi的/ude1位置/gi计算/gi与/ccp/nz的/ude1距离/gi，/w当/p距离/gi大于/v1/nz公里时/nz，/w这个/rz地点/n自然/n被/pbei丢弃/v。/w   /x小于/v1/nz公里时/nz，/w把/pba这个/rz地点/np/nz按/p降序/nz插入/gisort/gi(/nz对于/p有序/gi数组/gi采取/v二分法查找/gi获取/gi插/v的/ude1位置/gi)/nz,/nzsort/gi中/f已经/d有的/rz数据/gi中/f所有/b小于/vp/nz的/ude1数据/gi自动/d向/p后/f移动/vn一个/mq数据/gi单元/n,/nzsize/nz累加/vi1。/nz如果/c缓冲区/gi满/a（/wsize/nz=/nz=/nz100/nz）/w则/d最后/f的/ude1一条/nz数据/gi自动/d被/pbei丢弃/v，/w同时/c将/d最后/f一条/nz记录/gi的/ude1距离/gi值/n做为/v最小/a阀值/nz(/nz比如/v0.9/nz公里/q)/nz,/nz用于/v下一次/nz计算/gi时/qt的/ude1阀值/nz。/w   /x对/p所有/b的/ude1地点/n处理/vn完/vi之后/f。/wsort/gi中/f自然/n是/vshi要求/n的/ude1前/f100/nz个/q地点/n。/w以下/f是/vshi使用/gi纯/ac++/gi11/nz标准/gi实现/gi的/ude1代码/gi说明/v：/w /x考虑/v的/ude1并行计算/gi的/ude1需求/gi，/w支持/v归并排序/gi，/w方法/gi就/d用于/v对/p两/nz个/q已经/d排序/gi过/uguo的/ude1topk/nz_/nzbase/nz对象/gi进行/vn归并排序/gi，/w生成/v新的/a排序/gi结果/n，/w新/a结果/n的/ude1容量/gi仍然/d不变/nz。/w /x在/p构造函数/gi使用/gi了/ule上/f一篇/nz文章/gi中/f提到/v的/ude1make/nz_/nzunique/nz函数/gi(/nz)/nz,/nz所以/c代码/gi中/f虽然/c有/vyou使用/gi堆/gi内存/gi，/w但/c没有/v使用/ginew/nz//nzdelete/nz内存/gi申请/v释放/gi代码/gi,/nz内存/gi管理/gi都/d由/p智能指针/gi自动/d完成/v。/w为/p减少/v手工/gi定义数据/n类型/gi经常/d出/vf容量/gi出现/v不/d一致/a的/ude1问题/gi，/w代码/gi中/f大量/m使用/gi了/ulec++/gi11/nz的/ude1新/a特性/gi”/w类型/gi推导/gi”/w,/nz除了/p类/gi最/d开始/v的/ude1代码/gi出现/v了/ule具体/a数据类型/gi，/w类/gi中/f所有/b的/ude1成员/nnt变量/gi局部/n变量/gi，/w返回值/nz都/d由此/d推导/gi。/w /x例如/v：/w以下/f是/vshi调用/gi方法/gi的/ude1示范/vn代码/gi