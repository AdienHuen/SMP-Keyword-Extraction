#设计模式/nz之/uzhi迭代器模式/gi
    /x迭代器/nz模式定义/l：/w提供/v一种/nz方法/gi顺序/gi的/ude1访问/gi一/nz组/n聚合/gi元素/gi，/w而/cc又/d不/d暴露/v该/rz对象/gi的/ude1内部结构/nz。/w说明/v：/w首先/d说明/v，/w使用/gi迭代器/nz的/ude1对象/gi必须/d是/vshi一/nz组/n聚合/gi对象/gi，/w比如/v公交车/nz就是/v一/nz组/n聚合/gi对象/gi，/w车内/s的/ude1人/n互相/d之间/f可能/v有/vyou关系/gi，/w可能/v没关系/vl，/w他们/rr组合/gi起来/vf组成/gi了/ule这个/rz聚合/gi对象/gi。/w并且/c，/w这个/rz顺序/gi可以/v是/vshi任何/rz顺序/gi，/w比如/v从/p大/a到/v小/a，/w或者/c从小到大/nz，/w也/d就是说/c迭代器/nz迭代/gi一个/mq对象/gi时/qt，/w下/f一个/mq对象/gi已经/d确定/v了/ule，/w这个/rz而/cc对象/gi是/vshi唯一/b的/ude1。/w最后/f就是/v内部结构/nz，/w其实/d我们/rr只是/d从外部/nz可以/v得到/v这个/rz对象/gi的/ude1，/w但是/c聚合/gi对象/gi内部/f的/ude1构造/n，/w我们/rr是/vshi不/d清楚/a的/ude1。/w迭代器/nz类图/gi：/w代码实现/gi：/w   /x因为/c迭代器/nz在/p编程/gi中泰/nz常见/a了/ule，/w所以/c高级/a语言/gi将/d迭代器/nz进行/vn了/ule高度/d的/ude1抽象/gi，/w比如说/vl数组/gi、/warrylist/nz、/w集合/gi、/w哈希表/nz、/w字典/gi都/d进行/vn了/ule封装/gi，/w所以/c我们/rr平时/t并/cc不会/v注意到/v这个/rz模式/gi。/w接下来/vl看看/v.net/gi内置/vn的/ude1迭代器/nz。/w如果/c我们/rr想/v在/p自定义/nz的/ude1数据结构/gi中/f添加/gi迭代器/nz，/w改/v如何/ryv实现/gi呢/y？/w我们/rr只/d需要/v继承/gi并/cc实现/gi接口/giienumerable/nz即可/v。/w