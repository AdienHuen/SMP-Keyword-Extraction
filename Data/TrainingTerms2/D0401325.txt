#ASP/nz./nzNet MVC /nz给/p母版/nz页视图/nz传递数据/n
在/pmvc/gi中/f，/w我们/rr会/v遇到/v这样/rzv的/ude1场景/gi：/w我们/rr需要/v在/p每/rz一/nz页/q中都/ns显示/gi地区/n信息/gi，/w这些/rz地区/n信息/gi都/d是/vshi存储/gi在/p数据库/gi当中/f的/ude1。/w那/rzv我们/rr需要/v在/p模板/gi页/q中/f显示/gi地区/n信息/gi，/w问题/gi出来/vf了/ule，/w怎么/ryv在/p视图/gi母版/nz页面/gi里/f从/p数据库/gi检索/gi这些/rz地区/n信息/gi？/w直接/ad在/p视图/gi中/f操作/gi数据库/gi检索/gi数据/gi？/w这样/rzv的确/d很/d方便/a，/w但是/c这样/rzv就/d违反/v了/ulemvc/gi的/ude1设计/gi初衷/n，/wmodel/gi-/nzview/gi-/nzcontroller/gi，/w就是/v为了/p将/d关注点/n进行/vn分离/vi，/w当然/d这/rzv也/d是/vshimvc/gi的/ude1优点/gi之一/rz。/w在/pmvc/gi中/f，/w所有/b的/ude1model/gi的/ude1传递/v和/cc交换/gi都/d应该/v由/pcontroller/gi来/vf进行/vn，/w这样/rzv做/v会/v加强/v系统/gi的/ude1可维护性/gi以及/cc可扩展性/gi。/w也/d就是说/c所有/b传往/nz视图/gi的/ude1数据/gi都/d应该/v由/p控制器/n来/vf控制/vn。/w那/rzv这么/rz说来/v，/w我们/rr应该/v如何/ryv将/d数据传递/gi到/v母版/nz页视图/nz（/w_/nzlayout/nz./nzcshtml/nz）/w呢/y？/w方法/gi一/nz：/w我们/rr可以/v在/p控制器/n内/f的/ude1每个/r方法/gi中/f，/w为/p母版/nz页/q传递数据/n！/w也/d就是说/c在/p控制器/n的/ude1没/d个/q方法/gi中/f给/pviewdata/nz进行/vn赋/ng。/w这么/rz做/v确实/ad能/v实现/gi，/w但是/c每个/r方法/gi内都/ns要/v写/v这么/rz一段/nz代码/gi。/w问题/gi在于/v：/wdry/nz！/wdon/nz’/wt repeat yourself/nz！/w每/rz一个/mq方法/gi内都/ns加/v一段/nz读取数据/n的/ude1代码/gi会/v提高/v程序/gi的/ude1复杂度/gi，/w造成/v后续/vn的/ude1维护/gi困难/an，/w那/rzv我们/rr应该/v怎么做/nz呢/y，/w别着急/i，/w往/p下/f看/v！/w方法二/nz：/w既然/c不能/v这么/rz重复/gi的/ude1写/v代码/gi，/w那/rzv我们/rr就/d换/v个/q思路/gi。/w因为/c我们/rr只/d需要/v对/p母版/nz页视图/nz传递/v一次/nz数据/gi就/d好/a了/ule。/w那/rzv我们/rr就/d将/d从/p数据库/gi中/f读取数据/n的/ude1操作/gi放在/v控制器/n的/ude1构造方法/gi中/f，/w这样/rzv就/d避免/v了/ule要/v在/p每个/r方法/gi中都/ns加上/v相同/a的/ude1代码/gi。/w但是/c这样/rzv之后/f，/w细心/a的/ude1同学/n又/d会/v发现/v，/w那/rzv岂不是/d我/rr每个/r控制器/n的/ude1构造方法/gi中都/ns需要/v加上/v这么/rz一段/nz代码/gi，/w还是/c违反/v了/uledry/nz。/w没错/vi，/w那么/c这里/rzs我们/rr就要/d用/p到/v面向对象/gi的/ude1特性/gi：/w封装/gi、/w继承/gi、/w多态/gi中的/v继承/gi。/w我们/rr可以/v定义/gi一个/mq抽象类/gibasecontroller/nz，/w让/vbasecontroller/nz继承/gi于/psystem/nz./nzweb/gi./nzmvc/gi./nzcontroller/gi。/w然后/c在/pbasecontroller/nz的/ude1构造方法/gi中/f，/w我们/rr对/pviewdata/nz进行/vn赋/ng。/w在/p项目/gi中/f其他/rzv的/ude1控制器/n里/f，/w我们/rr让/v控制器/n继承/gi于/pbasecontroller/nz，/w那么/c我们/rr的/ude1问题/gi就/d解决/v了/ule。/w有人/r可能会/nz问/v，/w为什么/ryv要用/v抽象类/gi呢/y？/w因为/c，/w我们/rr这个/rz类/gi需要/v做/v的/ude1工作/gi只是/d为/p母版/nz页/q加载/gi数据/gi，/w并/cc没有/v相/d对应/vi的/ude1其他/rzv操作/gi。/w设置/gi为/p抽象类/gi可以/v防止/gi其他/rzv类/gi直接/ad调用/gi该类/r中的/v方法/gi。/w到/v这里/rzs，/w我们/rr需要/v给/p母版/nz页/q传/v的/ude1问题/gi已经/d解决/v了/ule。/w