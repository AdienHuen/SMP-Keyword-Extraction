#转/v：/wHbase/gi与/ccOracle/gi比较/gi（/w列式数据库/gi与/cc行式数据库/gi）/w
1/nz /x主要/b区别/gi1.1/nz、/whbase/gi适合/v大量/m插入/gi同时/c又/d有/vyou读/v的/ude1情况/n1.2/nz、/w hbase/nz的/ude1瓶颈/gi是/vshi硬盘/gi传输速度/nz，/woracle/gi的/ude1瓶颈/gi是/vshi硬盘/gi寻道/gi时间/gi。/whbase/gi本质/n上/f只有/c一种/nz操作/gi，/w就是/v插入/gi，/w其/rz更新/gi操作/gi是/vshi插入/gi一个/mq带有/v新的/a时间/gi戳/v的/ude1行/ng，/w而/cc删除/gi是/vshi插入/gi一个/mq带有/v插入/gi标记/gi的/ude1行/ng。/w其/rz主要/b操作/gi是/vshi收集/v内存/gi中/f一/nz批/q数据/gi，/w然后/c批量/d的/ude1写入/gi硬盘/gi，/w所以/c其/rz写入/gi的/ude1速度/n主要/b取决于/v硬盘/gi传输/gi的/ude1速度/n。/woracle/gi则/d不同/a，/w因为/c他/rr经常/d要/v随机/b读写/gi，/w这样/rzv硬盘/gi磁头/gi需要/v不断/d的/ude1寻找/v数据/gi所在/n，/w所以/c瓶颈/gi在于/v硬盘/gi寻道/gi时间/gi。/w1.3/nz、/whbase/gi很/d适合/v寻找/v按照/p时间/gi排序/gitop n/nz的/ude1场景/gi1.4/nz、/w索引/gi不同/a造成/v行为/n的/ude1差异/n。/w1.5/nz、/woracle /nz既/c可以/v做/voltp/gi又/d可以/v做/volap/gi，/w但/c在/p某种/rz极端/n的/ude1情况下/nz(/nz负荷/n十分/d之/uzhi大/a)/nz，/w就/d不/d适合/v了/ule。/w2/nz /x：/whbase/gi的/ude1局限/gi：/w1/nz、/w只能/v做/v简单/a的/ude1key value/nz查询/gi，/w复杂/a的/ude1sql/gi统计/gi做/v不到/v。/w /x2/nz、/w只能/v在/prow key/nz上/f做/v快速/d查询/gi。/w3/nz /x传统/n数据库/gi的/ude1行式/nz存储/gi在/p数据分析/gi的/ude1场景/gi里面/f，/w我们/rr经常/d是/vshi以/p某个/rz列/v作为/p查询/gi条件/n，/w返回/v的/ude1结果/n经常/d也/d只是/d某些/rz列/v，/w不是/c全部/m的/ude1列/v。/w行式数据库/gi在/p这种/r情况下/nz的/ude1i/nz//nzo/nz性能/gi会/v很差/d，/w以/poracle/gi为/p例/n，/woracle/gi会/v有/vyou一个/mq很大/d的/ude1数据文件/nz，/w在/p这个/rz数据文件/nz中/f，/w划分/v了/ule很/d多/ablock/nz，/w然后/c在/p每个/rblock/nz中/f放入/v行/ng，/w行/ng是/vshi一行/n一行/n放进去/v，/w挤/v在/p一起/s，/w然后/c把/pbablock/nz塞满/nz，/w当然/d也/d会/v预留/v一/nz些/q空间/n，/w用于/v将来/tupdate/gi。/w这种/r结构/gi的/ude1缺点/gi是/vshi：/w当/p我们/rr读/v某个/rz列/v的/ude1时候/n，/w比如/v我们/rr只/d需要/v读/v红色/gi标记/gi的/ude1列/v的/ude1时候/n，/w不能/v只读/v这/rzv部分/n数据/gi，/w我/rr必须/d把/pba整个/bblock/nz读取/gi到/v内存/gi中/f，/w然后/c再/d把/pba这些/rz列/v的/ude1数据/gi取出/v来/vf，/w换句话说/c，/w我/rr为了/p读表/nz中/f某些/rz列/v的/ude1数据/gi，/w我/rr必须/d把/pba整个/b列/v的/ude1行/ng读完/v，/w才/d可以/v读到/v这些/rz列/v。/w如果/c这些/rz列/v的/ude1数据/gi很少/ad，/w比如/v1/nzt/nz的/ude1数据/gi中/f只/d占/v了/ule100/nzm/nz,/nz /x为了/p读/v100/nzm/nz数据/gi却/d要/v读取/gi1/nztb/nz的/ude1数据/gi到/v内存/gi中/f去/vf，/w则/d显然/ad是/vshi不划算/l。/w4/nz /x列式/nz存储/gi同一个列/nz的/ude1数据/gi会/v挤/v在/p一起/s，/w比如/v挤/v在/pblock/nz里/f，/w当/p我/rr需要/v读/v某个/rz列/v的/ude1时候/n，/w值/n需要/v把/pba相关/vn的/ude1文件/gi或/c块/q读到/v内存/gi中/f去/vf，/w整个/b列/v就/d会/v被/pbei读出来/v，/w这样/rzvi/nz//nzo/nz会/v少/a很/d多/a。/w转/v自/p：/w   /x