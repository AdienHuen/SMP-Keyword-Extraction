#设计模式/nz /x--外观/nz模式/gi(/nzFacade/nz)/nz
什么/ry是/vshi外观模式/gi？/w外观模式/gi（/wfacade/gi）/w，/w为/p子系统/gi中的/v一/nz组/n接口/gi提供/v一个/mq一致/a的/ude1界面/gi，/w定义/gi一个/mq高层/n接口/gi，/w这个/rz接口/gi使得/vi这/rzv一/nz子系统/gi更加/d容易/ad使用/gi。/w /x简单/a点/gi说/v：/w外观模式/gi是/vshi一种/nz使用/gi频率/n非常/d高/a的/ude1结构型/n设计模式/nz，/w它/rr通过/p引入/v一个/mq外观/gi角色/gi来/vf简化/gi客户端/gi与/cc子系统/gi之间/f的/ude1交互/gi，/w为/p复杂/a的/ude1子系统/gi调用/gi提供/v一个/mq统一/vn的/ude1入口/n，/w降低/v子系统/gi与/cc客户端/gi的/ude1耦合度/gp，/w且/c客户端/gi调用/gi非常/d方便/a。/w概述/gi:/w在/p真实/a的/ude1应用系统/gi中/f，/w一个子/nz系统/gi可能/v由/p很/d多/a类/gi组成/gi。/w子系统/gi的/ude1客户/n为了/p它们/rr的/ude1需要/v，/w需要/v和/cc子系统/gi中的/v一/nz些/q类/gi进行/vn交互/gi。/w客户/n和/cc子系统/gi的/ude1类/gi进行/vn直接/ad的/ude1交互/gi会/v导致/gi客户端/gi对象/gi和/cc子系统/gi之间/f高度/d耦合/vn。/w任何/rz的/ude1类/gi于/p对/p子系统/gi中/f类/gi的/ude1接口/gi的/ude1修改/gi，/w会/v对/p依赖于/v它/rr的/ude1所有/b的/ude1客户/n类/gi造成/v影响/gi。/w从/p上面/f外观模式/gi的/ude1定义/gi我们/rr看/v以/p看到/v外观模式/gi能/v很好/ad的/ude1解决/v上述/b问题/gi，/w为/p子系统/gi提供/v了/ule一个/mq更高/d层次/n、/w更/d简单/a的/ude1接口/gi，/w从而/c降低/v了/ule子系统/gi的/ude1复杂度/gi和/cc依赖/v。/w这/rzv使得/vi子系统/gi更/d易于/vd使用/gi和/cc管理/gi。/w外观/gi是/vshi一个/mq能/v为/p子系统/gi和/cc客户/n提供/v简单/a接口/gi的/ude1类/gi。/w当/p正确/a的/ude1应用/gi外观/gi，/w客户/n不再/d直接/ad和/cc子系统/gi中的/v类/gi交互/gi，/w而是/c与/cc外观/gi交互/gi。/w外观/gi承担/v与/cc子系统/gi中/f类/gi交互/gi的/ude1责任/n。/w实际上/d，/w外观/gi是/vshi子系统/gi与/cc客户/n的/ude1接口/gi，/w这样/rzv外观模式/gi降低/v了/ule子系统/gi和/cc客户/n的/ude1耦合度/gp。/w实例/gi：/w下面/f用/p一个/mq简单/a的/ude1例子/gi来/vf说明/v外观模式/gi：/w结构图/gi：/w子系统/gi类/gi通常/d是/vshi一/nz些/q业务/gi类/gi，/w实现/gi了/ule一/nz些/q具体/a的/ude1、/w独立/a的/ude1业务/gi功能/gi，/w其/rz典型/n代码/gi如下/vi：/w在/p引入/v外观/gi类/gi之后/f，/w与/cc子系统/gi业务/gi类/gi之间/f的/ude1交互/gi统一/vn由/p外观/gi类/gi来/vf完成/v，/w在/p外观/gi类/gi中/f通常/d存在/v如下/vi代码/gi：/w由于/p在/p外观/gi类/gi中/f维持/v了/ule对/p子系统/gi对象/gi的/ude1引用/gi，/w客户端/gi可以/v通过/p外观/gi类/gi来/vf间接/b调用/gi子系统/gi对象/gi的/ude1业务/gi方法/gi，/w而无须/i与/cc子系统/gi对象/gi直接/ad交互/gi。/w引入/v外观/gi类/gi后/f，/w客户端/gi代码/gi变得/vi非常简单/nz，/w典型/n代码/gi如下/vi：/w何时/ryt使用/gi外观模式/gi？/w /x第一/mq：/w设计/gi初期/f阶段/gi，/w有意识/v的/ude1将/d不同/a的/ude1两/nz个/q层/gi分离/vi，/w层/gi与/cc层/gi之间/f建立/gi外观/gifacade/gi，/w这样/rzv就/d可以/v为/p复杂/a的/ude1子系统/gi提供/v一个/mq简单/a的/ude1接口/gi，/w耦合性/nz降低/v。/w /x第二/mq：/w在/p开发阶段/n，/w子系统/gi往往/d因为/c不断/d的/ude1重构/gi演化/gi而/cc变/v的/ude1越来越/d复杂/a，/w增加/v外观/gifacade/gi可以/v提供/v一个/mq简单/a的/ude1接口/gi，/w减少/v它们/rr之间/f的/ude1依赖性/n./nz /x第三/nz：/w维护/gi一个/mq大型/b系统/gi时/qt，/w可能/v这个/rz系统/gi已经/d非常/d难以/d维护/gi和/cc扩展/gi，/w此时/r可以/v为/p系统/gi新/a开发/gi一个/mqfacade/gi类/gi，/w来/vf提供/v设计/gi粗糙/a或/c高度/d复杂/a的/ude1遗留/v代码/gi的/ude1比较/gi清晰/a简单/a接口/gi，/w让/v新/a系统/gi与/ccfacade/gi对象/gi交互/gi，/wfacade/gi与/cc遗留/v代码/gi交互/gi所有/b复杂/a的/ude1工作/gi。/w