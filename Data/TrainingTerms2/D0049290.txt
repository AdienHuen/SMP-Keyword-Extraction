#测试/gi驱动开发/giTDD/gi
原文/n链接/gi：/w背景一个/nz高效/b的/ude1软件开发/nz过程/gi对/p软件开发/nz人员/gi来说/uls是/vshi至关重要/bl的/ude1，/w决定/v着/uzhe开发/gi是/vshi痛苦/an的/ude1挣扎/gi，/w还是/c不断进步/l的/ude1喜悦/an。/w国人/n对/p软件/gi蓝领/b的/ude1不屑/v，/w对/p繁琐/a冗长/a的/ude1传统开发/gi过程/gi的/ude1不耐/a，/w使/v大/a多数/a开发人员/n无/v所适从/nz。/w最近/t兴起/v的/ude1一些/m软件开发/nz过程/gi相关/vn的/ude1技术/gi，/w提供/v一/nz些/q比较/gi高效/b、/w实用/a的/ude1软件/gi过程/gi开发方法/nz。/w其中/rz比较/gi基础/gi、/w关键/n的/ude1一个/mq技术/gi就是/v测试/gi驱动开发/gi（/wtest/nz-/nzdriven development/nz）/w。/w虽然/ctdd/gi光大/v于/p极限/n编程/gi，/w但/c测试/gi驱动开发/gi完全/ad可以/v单独/d应用/gi。/w下面/f就/d从/p开发人员/n使用/gi的/ude1角度/n进行/vn介绍/gi，/w使/v开发人员/n用/p最少/d的/ude1代价/gi尽快/d理解/gi、/w掌握/v、/w应用/gi这种/r技术/gi。/w下面/f分/qt优势/gi，/w原理/gi，/w过程/gi，/w原则/gi，/w测试技术/gi，/wtips/nz等/udeng方面/n进行/vn讨论/gi。/w1./nz /x优势/gitdd/gi的/ude1基本思路/nz就是/v通过/p测试/gi来/vf推动/v整个/b开发/gi的/ude1进行/vn。/w而/cc测试/gi驱动/gi开发技术/n并不/d只是/d单纯/a的/ude1测试/gi工作/gi。/w需求/gi向来/d就是/v软件开发/nz过程/gi中/f感觉/gi最/d不好/a明确/a描述/gi、/w易变/nz的/ude1东西/n。/w这里/rzs说/v的/ude1需求/gi不/d只是/d指/v用户/gi的/ude1需求/gi，/w还包括/nz对/p代码/gi的/ude1使用/gi需求/gi。/w很/d多/a开发人员/n最/d害怕/v的/ude1就是/v后期/f还要/d修改/gi某个/rz类/gi或者/c函数/gi的/ude1接口/gi进行/vn修改/gi或者/c扩展/gi，/w为什么/ryv会/v发生/v这样/rzv的/ude1事情/n就是/v因为/c这/rzv部分/n代码/gi的/ude1使用/gi需求/gi没有/v很好/ad的/ude1描述/gi。/w测试/gi驱动开发/gi就是/v通过/p编写/gi测试用例/gi，/w先/d考虑/v代码/gi的/ude1使用/gi需求/gi（/w包括/v功能/gi、/w过程/gi、/w接口/gi等/udeng）/w，/w而且/c这个/rz描述/gi是/vshi无二义/nz的/ude1，/w可执行/nz验证/v的/ude1。/w通过/p编写/gi这/rzv部分/n代码/gi的/ude1测试用例/gi，/w对/p其/rz功能/gi的/ude1分解/gi、/w使用/gi过程/gi、/w接口/gi都/d进行/vn了/ule设计/gi。/w而且/c这种/r从/p使用/gi角度/n对/p代码/gi的/ude1设计/gi通常/d更/d符合/v后期/f开发/gi的/ude1需求/gi。/w可/v测试/gi的/ude1要求/n，/w对/p代码/gi的/ude1内聚性/gp的/ude1提高/v和/cc复用/gi都/d非常/d有益/a。/w因此/c测试/gi驱动开发/gi也/d是/vshi一种/nz代码/gi设计/gi的/ude1过程/gi。/w开发人员/n通常/d对/p编写/gi文档/gi非常/d厌烦/v，/w但要/c使用/gi、/w理解/gi别人/rr的/ude1代码/gi时/qt通常/d又/d希望/v能/v有/vyou文档/gi进行/vn指导/vn。/w而/cc测试/gi驱动开发/gi过程/gi中/f产生/v的/ude1测试用例/gi代码/gi就是/v对/p代码/gi的/ude1最好/d的/ude1解释/gi。/w快乐/a工作/gi的/ude1基础/gi就是/v对/p自己/rr有/vyou信心/n，/w对/p自己/rr的/ude1工作/gi成果/gi有/vyou信心/n。/w当前/t很/d多/a开发人员/n却/d经常/d在/p担心/v：/w“/w代码/gi是否/v正确/a？/w”“/nz辛苦/a编写/gi的/ude1代码/gi还有/v没有/v严重/abug/gi？/w”/w“/w修改/gi的/ude1新/a代码/gi对/p其他/rzv部分/n有/vyou没有/v影响/gi？/w”/w。/w这种/r担心/v甚至/d导致/gi某些/rz代码/gi应该/v修改/gi却/d不敢/d修改/gi的/ude1地步/n。/w测试/gi驱动开发/gi提供/v的/ude1测试/gi集/q就/d可以/v作为/p你/rr信心/n的/ude1来源/gi。/w当然/d测试/gi驱动开发/gi最重要/nz的/ude1功能/gi还/d在于/v保障/vn代码/gi的/ude1正确性/gi，/w能够/v迅速/ad发现/v、/w定位/gibug/gi。/w而/cc迅速/ad发现/v、/w定位/gibug/gi是/vshi很/d多/a开发人员/n的/ude1梦想/gi。/w针对/gi关键/n代码/gi的/ude1测试/gi集/q，/w以及/cc不断完善/l的/ude1测试用例/gi，/w为/p迅速/ad发现/v、/w定位/gibug/gi提供/v了/ule条件/n。/w我/rr的/ude1一段/nz功能/gi非常复杂/b的/ude1代码/gi使用/gitdd/gi开发/gi完成/v，/w真实/a环境/n应用/gi中/f只/d发现/v几个/nzbug/gi，/w而且/c很快/d被/pbei定位/gi解决/v。/w您/rr在/p应用/gi后/f，/w也/d一定会/nz为/p那种/r自信/gi的/ude1开发/gi过程/gi，/w功能/gi不断/d增加/v、/w完善/v的/ude1感觉/gi，/w迅速/ad发现/v、/w定位/gibug/gi的/ude1能力/gi所/usuo感染/v，/w喜欢/gi这个/rz技术/gi的/ude1。/w那么/c是/vshi什么样/ryv的/ude1原理/gi、/w方法/gi提供/v上面/f说/v的/ude1这些/rz好处/gi哪/ry？/w下面/f我们/rr就/d看看/vtdd/gi的/ude1原理/gi。/w2./nz /x原理/gi测试/gi驱动开发/gi的/ude1基本/a思想/gi就是/v在/p开发/gi功能/gi代码/gi之前/f，/w先/d编写/gi测试代码/n。/w也/d就是说/c在/p明确/a要/v开发/gi某个/rz功能/gi后/f，/w首先/d思考/gi如何/ryv对/p这个/rz功能/gi进行/vn测试/gi，/w并/cc完成/v测试代码/n的/ude1编写/gi，/w然后/c编写/gi相关/vn的/ude1代码/gi满足/v这些/rz测试用例/gi。/w然后/c循环/gi进行/vn添加/gi其他/rzv功能/gi，/w直到/v完全/ad部/q功能/gi的/ude1开发/gi。/w我们/rr这里/rzs把/pba这个/rz技术/gi的/ude1应用领域/l从/p代码/gi编写/gi扩展到/v整个/b开发/gi过程/gi。/w应该/v对/p整个/b开发/gi过程/gi的/ude1各个/rz阶段/gi进行/vn测试/gi驱动/gi，/w首先/d思考/gi如何/ryv对/p这个/rz阶段/gi进行/vn测试/gi、/w验证/v、/w考核/gi，/w并/cc编写/gi相关/vn的/ude1测试/gi文档/gi，/w然后/c开始/v下一步/nz工作/gi，/w最后/f再/d验证/v相关/vn的/ude1工作/gi。/w下图/n是/vshi一个/mq比较/gi流行/v的/ude1测试/gi模型/gi：/wv/nz测试/gi模型/gi。/w【/w图/gi v/nz测试/gi模型/gi】/w在/p开发/gi的/ude1各个/rz阶段/gi，/w包括/v需求分析/gi、/w概要设计/gi、/w详细设计/gi、/w编码/gi过程/gi中都/ns应该/v考虑/v相/d对应/vi的/ude1测试/gi工作/gi，/w完成/v相关/vn的/ude1测试用例/gi的/ude1设计/gi、/w测试/gi方案/gi、/w测试计划/gi的/ude1编写/gi。/w这里/rzs提到/v的/ude1开发阶段/n只是/d举例/gi，/w根据/p实际/n的/ude1开发/gi活动/gi进行/vn调整/vn。/w相关/vn的/ude1测试/gi文档/gi也/d不一定/nz是/vshi非常/d详细/gi复杂/a的/ude1文档/gi，/w或者/c什么/ry形式/gi，/w但/c应该/v养成/v测试/gi驱动/gi的/ude1习惯/n。/w关于/p测试/gi模型/gi，/w还有/vx/nz测试/gi模型/gi。/w这个/rz测试/gi模型/gi，/w我/rr认为/v，/w是/vshi对/p详细/gi阶段/gi和/cc编码/gi阶段/gi进行/vn建模/gi，/w应该/v说/v更/d详细/gi的/ude1描述/gi了/ule详细设计/gi和/cc编码/gi阶段/gi的/ude1开发/gi行为/n。/w及/cc针对/gi某个/rz功能/gi进行/vn对应/vi的/ude1测试/gi驱动开发/gi。/w【/w图/gi x/nz测试/gi模型/gi】/w基本原理/nz应该/v说/v非常简单/nz，/w那么/c如何/ryv进行/vn实际操作/n哪/ry，/w下/f面对/v开发/gi过程/gi进行/vn详细/gi的/ude1介绍/gi。/w3./nz /x过程/gi软件开发/nz其他/rzv阶段/gi的/ude1测试/gi驱动开发/gi，/w根据/p测试/gi驱动开发/gi的/ude1思想/gi完成/v对应/vi的/ude1测试/gi文档/gi即可/v。/w下面/f针对/gi详细设计/gi和/cc编码/gi阶段/gi进行/vn介绍/gi。/w测试/gi驱动开发/gi的/ude1基本/a过程/gi如下/vi：/w1/nz）/w /x明确/a当前/t要/v完成/v的/ude1功能/gi。/w可以/v记录/gi成/v一个/mq todo /nz列表/vi。/w2/nz）/w /x快速/d完成/v针对/gi此/rzs功能/gi的/ude1测试用例/gi编写/gi。/w3/nz）/w /x测试代码/n编译/gi不/d通过/p。/w4/nz）/w /x编写/gi对应/vi的/ude1功能/gi代码/gi。/w5/nz）/w /x测试通过/n。/w6/nz）/w /x对/p代码/gi进行/vn重构/gi，/w并/cc保证/v测试通过/n。/w7/nz）/w /x循环/gi完成/v所有/b功能/gi的/ude1开发/gi。/w为了/p保证/v整个/b测试过程/gi比较/gi快捷/z、/w方便/a，/w通常/d可以/v使用/gi测试/gi框架/gi组织/gi所有/b的/ude1测试用例/gi。/w一个/mq免费/vd的/ude1、/w优秀/gi的/ude1测试/gi框架/gi是/vshi xunit /nz系列/n，/w几乎/d所有/b的/ude1语言/gi都/d有/vyou对应/vi的/ude1测试/gi框架/gi。/w我/rr曾经/d写/v过/uguo一/nz篇文章/n介绍/gicppunit/nz的/ude1文章/gi（/w）/w。/w开发/gi过程/gi中/f，/w通常/d把/pba测试代码/n和/cc功能/gi代码/gi分开/vi存放/v，/w这里/rzs提供/v一个/mq简单/a的/ude1测试/gi框架/gi使用/gi例子/gi，/w您/rr可以/v通过/p它/rr了解/v测试/gi框架/gi的/ude1使用/gi。/w下面/f是/vshi文件/gi列表/vi。/w主要流程/gi基本/a如此/rzv，/w但要/c让/v你/rr的/ude1代码/gi很容易/nz的/ude1进行/vn测试/gi，/w全面/ad又/d不/d繁琐/a的/ude1进行/vn测试/gi，/w还是/c有/vyou很/d多/a测试/gi原则/gi和/cc技术/gi需要/v考虑/v。/w4./nz /x原则/gi测试/gi隔离/vn。/w不同/a代码/gi的/ude1测试/gi应该/v相互/d隔离/vn。/w对/p一块/s代码/gi的/ude1测试/gi只/d考虑/v此/rzs代码/gi的/ude1测试/gi，/w不要/d考虑/v其/rz实现/gi细节/gi（/w比如/v它/rr使用/gi了/ule其他/rzv类/gi的/ude1边界条件/gm）/w。/w一顶/nz帽子/n。/w开发人员/n开发/gi过程/gi中/f要/v做/v不同/a的/ude1工作/gi，/w比如/v：/w编写/gi测试代码/n、/w开发/gi功能/gi代码/gi、/w对/p代码/gi重构/gi等/udeng。/w做/v不同/a的/ude1事/n，/w承担/v不同/a的/ude1角色/gi。/w开发人员/n完成/v对应/vi的/ude1工作/gi时/qt应该/v保持/v注意力/n集中/v在/p当前工作/l上/f，/w而/cc不要/d过多/d的/ude1考虑/v其他/rzv方面/n的/ude1细节/gi，/w保证/v头上/s只有/c一顶/nz帽子/n。/w避免/v考虑/v无关/v细节/gi过多/d，/w无谓/b地/ude2增加/v复杂度/gi。/w测试/gi列表/vi。/w需要/v测试/gi的/ude1功能/gi点/gi很/d多/a。/w应该/v在/p任何/rz阶段/gi想/v添加/gi功能/gi需求/gi问题/gi时/qt，/w把/pba相关/vn功能/gi点/gi加到/v测试/gi列表/vi中/f，/w然后/c继续/v手头/n工作/gi。/w然后/c不断/d的/ude1完成/v对应/vi的/ude1测试用例/gi、/w功能/gi代码/gi、/w重构/gi。/w一是/nz避免/v疏漏/n，/w也/d避免/v干扰/gi当前/t进行/vn的/ude1工作/gi。/w测试/gi驱动/gi。/w这个/rz比较/gi核心/n。/w完成/v某个/rz功能/gi，/w某个/rz类/gi，/w首先/d编写/gi测试代码/n，/w考虑/v其/rz如何/ryv使用/gi、/w如何/ryv测试/gi。/w然后/c在/p对/p其/rz进行/vn设计/gi、/w编码/gi。/w先写/nz断言/v。/w测试代码/n编写/gi时/qt，/w应该/v首先/d编写/gi对/p功能/gi代码/gi的/ude1判断/gi用/p的/ude1断言/v语句/gi，/w然后/c编写/gi相应/vi的/ude1辅助/vn语句/gi。/w可/v测试性/nz。/w功能/gi代码/gi设计/gi、/w开发/gi时/qt应该/v具有/v较强/d的/ude1可/v测试性/nz。/w其实/d遵循/gi比较/gi好/a的/ude1设计原则/gi的/ude1代码/gi都/d具备/v较好/d的/ude1测试性/nz。/w比如/v比较/gi高/a的/ude1内聚性/gp，/w尽量/d依赖于/v接口/gi等/udeng。/w及时/ad重构/gi。/w无论是/c功能/gi代码/gi还是/c测试代码/n，/w对/p结构/gi不合理/nz，/w重复/gi的/ude1代码/gi等/udeng情况/n，/w在/p测试通过/n后/f，/w及时/ad进行/vn重构/gi。/w关于/p重构/gi，/w我会/r另/rz撰文/vi详细分析/n。/w小步/nz前进/vi。/w软件开发/nz是/vshi个/q复杂性/gi非常/d高/a的/ude1工作/gi，/w开发/gi过程/gi中/f要/v考虑/v很/d多/a东西/n，/w包括/v代码/gi的/ude1正确性/gi、/w可扩展性/gi、/w性能/gi等等/udeng，/w很/d多/a问题/gi都/d是因为/c复杂性/gi太大/d导致/gi的/ude1。/w极限/n编程/gi提出/v了/ule一个/mq非常/d好/a的/ude1思路/gi就是/v小步/nz前进/vi。/w把/pba所有/b的/ude1规模/gi大/a、/w复杂性/gi高/a的/ude1工作/gi，/w分解成/n小/a的/ude1任务/gi来/vf完成/v。/w对于/p一个/mq类/gi来说/uls，/w一个/mq功能/gi一个/mq功能/gi的/ude1完成/v，/w如果/c太/d困难/an就/d再/d分解/gi。/w每个/r功能/gi的/ude1完成/v就/d走/v测试代码/n－/w功能/gi代码/gi－/w测试/gi－/w重构/gi的/ude1循环/gi。/w通过/p分解/gi降低/v整个/b系统开发/gi的/ude1复杂性/gi。/w这样/rzv的/ude1效果/gi非常/d明显/a。/w几/d个/q小/a的/ude1功能/gi代码/gi完成/v后/f，/w大/a的/ude1功能/gi代码/gi几乎/d是/vshi不用/d调试/gi就/d可以/v通过/p。/w一个/mq个/q类/gi方法/gi的/ude1实现/gi，/w很快/d就/d看到/v整个/b类/gi很快/d就/d完成/v啦/y。/w本来/d感觉/gi很/d多/a特性/gi需要/v增加/v，/w很快/d就/d会/v看到/v没有/v几/d个/q啦/y。/w你/rr甚至/d会/v为/p这个/rz速度/n感到/v震惊/v。/w（/w我/rr理解/gi，/w是/vshi大幅度/d减少/v调试/gi、/w出错/gi的/ude1时间/gi产生/v的/ude1这种/r速度感/nz）/w5./nz /x测试技术/gi5.1./nz /x测试/gi范围/n、/w粒度/gi对/p哪些/ry功能/gi进行/vn测试/gi？/w会/v不会/v太/d繁琐/a？/w什么/ry时候/n可以/v停止/gi测试/gi？/w这些/rz问题/gi比较/gi常见/a。/w按/p大师/nnt kent benk /nz的话/udh，/w对/p那些/rz你/rr认为/v应该/v测试/gi的/ude1代码/gi进行/vn测试/gi。/w就是说/c，/w要/v相信/v自己/rr的/ude1感觉/gi，/w自己/rr的/ude1经验/gi。/w那些/rz重要/a的/ude1功能/gi、/w核心/n的/ude1代码/gi就/d应该/v重点/n测试/gi。/w感到/v疲劳/an就/d应该/v停下来/nz休息/v一下/m。/w感觉/gi没有/v必要/a更/d详细/gi的/ude1测试/gi，/w就/d停止/gi本轮/r测试/gi。/w测试/gi驱动开发/gi强调/v测试/gi并不/d应该/v是/vshi负担/n，/w而/cc应该/v是/vshi帮助/v我们/rr减轻/v工作量/n的/ude1方法/gi。/w而/cc对于/p何时/ryt停止/gi编写/gi测试用例/gi，/w也/d是/vshi应该/v根据/p你/rr的/ude1经验/gi，/w功能/gi复杂/a、/w核心/n功能/gi的/ude1代码/gi就/d应该/v编写/gi更/d全面/ad、/w细致/a的/ude1测试用例/gi，/w否则/c测试流程/gi即可/v。/w测试/gi范围/n没有/v静态/gi的/ude1标准/gi，/w同时/c也/d应该/v可以/v随着/p时间/gi改变/v。/w对于/p开始/v没有/v编写/gi足够/v的/ude1测试/gi的/ude1功能/gi代码/gi，/w随着/pbug/gi的/ude1出现/v，/w根据/pbug/gi补齐/nz相关/vn的/ude1测试用例/gi即可/v。/w小步/nz前进/vi的/ude1原则/gi，/w要求/n我们/rr对/p大/a的/ude1功能块/n测试/gi时/qt，/w应该/v先分/nz拆成/nz更/d小/a的/ude1功能块/n进行/vn测试/gi，/w比如/v一个/mq类/gia/nz使用/gi了/ule类/gib/nz、/wc/nz，/w就/d应该/v编写/gi到/va/nz使用/gib/nz、/wc/nz功能/gi的/ude1测试代码/n前/f，/w完成/v对/pb/nz、/wc/nz的/ude1测试/gi和/cc开发/gi。/w那么/c是不是/v每个/r小类/nz或者/c小函数/nz都/d应该/v测试/gi哪/ry？/w我/rr认为/v没有/v必要/a。/w你/rr应该/v运用/v你/rr的/ude1经验/gi，/w对/p那些/rz可能/v出/vf问题/gi的/ude1地方/n重点/n测试/gi，/w感觉/gi不/d可能/v出/vf问题/gi的/ude1地方/n就/d等/udeng它/rr真正/d出/vf问题/gi的/ude1时候/n再补/v测试/gi吧/y。/w5.2./nz /x怎么/ryv编写/gi测试用例/gi测试用例/gi的/ude1编写/gi就/d用上/v了/ule传统/n的/ude1测试技术/gi。/w操作过程/l尽量/d模拟/gi正常/a使用/gi的/ude1过程/gi。/w全面/ad的/ude1测试用例/gi应该/v尽量/d做到/v分支/n覆盖/gi，/w核心/n代码/gi尽量/d做到/v路径/gi覆盖/gi。/w测试数据/gi尽量/d包括/v：/w真实/a数据/gi、/w边界/n数据/gi。/w测试/gi语句/gi和/cc测试数据/gi应该/v尽量/d简单/a，/w容易/ad理解/gi。/w为了/p避免/v对/p其他/rzv代码/gi过多/d的/ude1依赖/v，/w可以/v实现/gi简单/a的/ude1桩/q函数/gi或/c桩类/nz（/wmock object/nz）/w。/w如果/c内部/f状态/gi非常复杂/b或者/c应该/v判断/gi流程/gi而/cc不是/c状态/gi，/w可以/v通过/p记录/gi日志/gi字符串/gi的/ude1方式/n进行/vn验证/v。/w6./nz tips/nz很/d多/a朋友/n有/vyou疑问/n，/w“/w测试代码/n的/ude1正确性/gi如何/ryv保障/vn？/w是/vshi写/v测试代码/n还是/c写/v测试/gi文档/gi？/w”/w这样/rzv是不是/v会/v陷入/v“鸡/nz生蛋/nz，/w蛋/nf生/v鸡”/nz的/ude1循环/gi。/w其实/d是/vshi不会/v的/ude1。/w通常/d测试代码/n通常/d是/vshi非常简单/nz的/ude1，/w通常/d围绕/v着/uzhe某个/rz情况/n的/ude1正确性/gi判断/gi的/ude1几个/nz语句/gi，/w如果/c太/d复杂/a，/w就/d应该/v继续/v分解/gi啦/y。/w而/cc传统/n的/ude1开发/gi过程/gi通常/d强调/v测试/gi文档/gi。/w但/c随着/p开发/gi节奏/n的/ude1加快/v，/w用户/gi需求/gi的/ude1不断/d变化/gi，/w维护/gi高层/n（/w需求/gi、/w概要设计/gi）/w的/ude1测试/gi文档/gi可以/v，/w更/d低层/n的/ude1测试/gi文档/gi的/ude1成本/n的确/d太大/d了/ule。/w而且/c可/v实时/n验证/v功能/gi正确性/gi的/ude1测试代码/n就是/v对/p代码/gi最好/d的/ude1文档/gi。/w软件开发/nz过程/gi中/f，/w除了/p遵守/v上面/f提到/v的/ude1测试/gi驱动开发/gi的/ude1几个/nz原则/gi外/f，/w一个/mq需要/v注意/v的/ude1问题/gi就是/v，/w谨防/v过度/d设计/gi。/w编写/gi功能/gi代码/gi时/qt应该/v关注/v于/p完成/v当前/t功能/gi点/gi，/w通过/p测试/gi，/w使用/gi最简单/nz、/w直接/ad的/ude1方式/n来/vf编码/gi。/w过多/d的/ude1考虑/v后期/f的/ude1扩展/gi，/w其他/rzv功能/gi的/ude1添加/gi，/w无疑/d增加/v了/ule过多/d的/ude1复杂性/gi，/w容易/ad产生/v问题/gi。/w应该/v等到/v要/v添加/gi这些/rz特性/gi时/qt在/p进行/vn详细/gi的/ude1测试/gi驱动开发/gi。/w到时候/l，/w有/vyou整套/b测试用例/gi做/v基础/gi，/w通过/p不断/d重构/gi很容易/nz添加/gi相关/vn特性/gi