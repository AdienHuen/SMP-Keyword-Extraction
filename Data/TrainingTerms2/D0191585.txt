#Android/gi设计模式/nz―/w策略模式/gi
定义/gi一系列/b算法/gi，/w把/pba他们/rr独立/a封装/gi起来/vf，/w并且/c这些/rz算法/gi之间/f可以/v相互/d替换/v。/w策略模式/gi主要/b是/vshi管理/gi一/nz堆有/v共性/n的/ude1算法/gi，/w客户端/gi可以/v根据/p需要/v，/w很快/d切换/vn这些/rz算法/gi，/w并且/c保持/v可扩展性/gi。/wad/nz：/w1/nz、/w策略模式/gi概念/gi定义/gi一系列/b算法/gi，/w把/pba他们/rr独立/a封装/gi起来/vf，/w并且/c这些/rz算法/gi之间/f可以/v相互/d替换/v。/w策略模式/gi主要/b是/vshi管理/gi一/nz堆有/v共性/n的/ude1算法/gi，/w客户端/gi可以/v根据/p需要/v，/w很快/d切换/vn这些/rz算法/gi，/w并且/c保持/v可扩展性/gi。/w策略模式/gi的/ude1本质/n：/w分离/vi算法/gi，/w选择/gi实现/gi。/w2/nz、/w策略模式/gi实现/gi下面/f针对/gi策略模式/gi说一个/nz小型/b的/ude1实现/gi例子/gi，/w个人/n觉得/v学习/gi设计模式/nz，/w最好/d的/ude1方法/gi是/vshi看看/v设计模式/nz概念/gi，/w然后/c先/d看看/v简单/a的/ude1模式/gi实现/gi的/ude1例子/gi。/w策略模式/gi实现/gi起来/vf，/w主要/b需要/v3/nz部分/n：/w抽象/gi接口/gi、/w实现/gi算法/gi、/w上下文/gi。/w上面/f是/vshi一个/mq最简单/nz的/ude1策略模式/gi的/ude1实现/gi方式/n，/w按照/p功能/gi分为/v3/nz个/q部分/n，/w定义/gi算法/gi抽象/gi接口/gi，/w然后/c根据/p具体/a算法/gi实现/gi这些/rz接口/gi，/w最后/f需要/v定义/gi一个/mq上下文/gi对象/gi。/w这里/rzs的/ude1上下文/gi对象/gi主要/b用来/v切换/vn算法/gi，/w上下文/gi对象/gi里面/f也/d是/vshi针对/gi接口/gi编程/gi，/w具体/a算法/gi实现/gi被/pbei封装/gi了/ule。/w3/nz、/w策略模式/gi的/ude1理解/gi上面/f实现/gi的/ude1只是/d一种/nz最简单/nz的/ude1策略模式/gi的/ude1框架/gi，/w实际/n应用/gi的/ude1时候/n，/w我们/rr可以/v针对/gi不同/a情况/n修改/gi上下文/gi对象/gi和/cc具体/a的/ude1算法/gi实现/gi。/w比如说/vl，/w可以/v增加/v一个/mq抽象类/gi实现/gi作为/p算法/gi模板/gi。/w抽象类/gi里面/f我们/rr可以/v封装/gi一/nz些/q公共/b的/ude1方法/gi。/w这样/rzv实现/gi具体/a的/ude1算法/gi的/ude1时候/n，/w每个/r算法/gi公共/b部分/n就/d被/pbei分离出来/i。/w策略模式/gi的/ude1目的/gi是/vshi把/pba具体/a的/ude1算法/gi抽离/nz出来/vf，/w把/pba每个/r算法/gi独立/a出来/vf。/w形成/v一系列/b有/vyou共同/d作用/gi的/ude1算法/gi组/n，/w然后/c这个/rz算法/gi组/n里面/f的/ude1算法/gi可以/v根据/p实际/n情况/n进行/vn相互/d替换/v。/w策略模式/gi的/ude1中心/gi不是/c如何/ryv实现/gi这些/rz算法/gi，/w而是/c如何/ryv组织/gi和/cc调用/gi这些/rz算法/gi。/w也/d就是/v把/pba我们/rr平时/t写到/v一块/s的/ude1算法/gi解耦/gi出来/vf，/w独立/a成/v一个/mq模块/gi，/w增强/v程序/gi的/ude1扩展性/n。/w策略模式/gi里面/f的/ude1算法/gi通常/d需要/v数据/gi执行/v，/w我们/rr可以/v根据/p实际/n情况/n把/pba数据/gi放在/v不同/a地方/n。/w例如/v可以/v放在/v上下/f文类/n里面/f，/w然后/c每个/r算法/gi都/d可以/v使用/gi这些/rz数据/gi。/w或者/c对接口/n封装/gi一个/mq抽象类/gi，/w在/p抽象类/gi里面/f添加/gi数据/gi。/w这些/rz可以/v根据/p实际/n的/ude1情况/n综合/vn考虑/v。/w设计模式/nz里面/f没有/v一成不变/vl的/ude1万能/b模式/gi，/w每种/r模式/gi都/d有/vyou变化/gi版本/n，/w需要/v根据/p实际/n的/ude1项目/gi进行/vn变通/vi。/w4/nz、/w策略模式/gi优缺点/gi定义/gi一系列/b算法/gi：/w策略模式/gi的/ude1功能/gi就是/v定义/gi一系列/b算法/gi，/w实现/gi让/v这些/rz算法/gi可以/v相互/d替换/v。/w所以/c会/v为/p这/rzv一系列/b算法/gi定义/gi公共/b的/ude1接口/gi，/w以/p约束/gi一系列/b算法/gi要/v实现/gi的/ude1功能/gi。/w如果/c这/rzv一系列/b算法/gi具有/v公共/b功能/gi，/w可以/v把/pba策略/gi接口/gi实现/gi成为/v抽象类/gi，/w把/pba这些/rz公共/b功能/gi实现/gi到/v父类/nz里面/f，/w对于/p这个/rz问题/gi，/w前面/f讲/v了/ule三种/nz处理方法/gi，/w这里/rzs就/d不/d罗嗦/a了/ule。/w避免/v多重/b条件/n语句/gi：/w根据/p前面/f的/ude1示例/gi会/v发现/v，/w策略模式/gi的/ude1一系列/b策略/gi算法/gi是/vshi平等/a的/ude1，/w可以/v互换/v的/ude1，/w写/v在/p一起/s就是/v通过/pif/nz-/nzelse/nz结构/gi来/vf组织/gi，/w如果/c此时/r具体/a的/ude1算法/gi实现/gi里面/f又/d有条件/nz语句/gi，/w就/d构成/v了/ule多重/b条件/n语句/gi，/w使用/gi策略模式/gi能避免/nz这样/rzv的/ude1多重/b条件/n语句/gi。/w更好/d的/ude1扩展性/n：/w在/p策略模式/gi中/f扩展/gi新的/a策略/gi实现/gi非常容易/l，/w只要/c增加/v新的/a策略/gi实现/gi类/gi，/w然后/c在/p选择/gi使用/gi策略/gi的/ude1地方/n选择/gi使用/gi这个/rz新的/a策略/gi实现/gi就/d好/a了/ule。/w客户/n必须/d了解/v每种/r策略/gi的/ude1不同/a：/w策略模式/gi也/d有/vyou缺点/gi，/w比如/v让/v客户/n端来/nz选择/gi具体/a使用/gi哪/ry一个/mq策略/gi，/w这/rzv就/d可能会/nz让/v客户/n需要/v了解/v所有/b的/ude1策略/gi，/w还要/d了解/v各种/rz策略/gi的/ude1功能/gi和/cc不同/a，/w这样/rzv才能/n做出/v正确/a的/ude1选择/gi，/w而且/c这样/rzv也/d暴露/v了/ule策略/gi的/ude1具体/a实现/gi。/w增加/v了/ule对象/gi数目/gi：/w由于/p策略模式/gi把/pba每个/r具体/a的/ude1策略/gi实现/gi都/d单独/d封装/gi成为/v类/gi，/w如果/c备选/nz的/ude1策略/gi很/d多/a的话/udh，/w那么/c对象/gi的/ude1数目/gi就/d会/v很/d可观/a。/w只/d适合/v扁平/gi的/ude1算法/gi结构/gi：/w策略模式/gi的/ude1一系列/b算法/gi地位/n是/vshi平等/a的/ude1，/w是/vshi可以/v相互/d替换/v的/ude1，/w事实上/bl构成/v了/ule一个/mq扁平/gi的/ude1算法/gi结构/gi，/w也/d就是/v在/p一个/mq策略/gi接口/gi下/f，/w有/vyou多/a个/q平等/a的/ude1策略/gi算法/gi，/w就/d相当于/v兄弟/n算法/gi。/w而且/c在/p运行/gi时刻/n只有/c一个/mq算法/gi被/pbei使用/gi，/w这/rzv就/d限制/vn了/ule算法/gi使用/gi的/ude1层级/n，/w使用/gi的/ude1时候/n不能/v嵌套/v使用/gi。/w5/nz、/wandroid/gi中的/v应用/gi下面/f说说/v在/pandroid/gi里面/f的/ude1应用/gi。/w在/pandroid/gi里面/f策略模式/gi的/ude1其中/rz一个/mq典型/n应用/gi就是/vadapter/gi，/w在/p我们/rr平时/t使用/gi的/ude1时候/n，/w一般/ad情况下/nz我们/rr可能/v继承/gibaseadapter/nz，/w然后/c实现/gi不同/a的/ude1view/gi返回/v，/wgetview/nz里面/f实现/gi不同/a的/ude1算法/gi。/w外部/f使用/gi的/ude1时候/n也/d可以/v根据/p不同/a的/ude1数据源/gi，/w切换/vn不同/a的/ude1adapter/gi。/w