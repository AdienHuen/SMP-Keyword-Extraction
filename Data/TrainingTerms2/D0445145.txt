#3/nzSum/nz,/nz /x3/nzSum Closest/nz,/nz /x4/nz Sum/nz
暴力/n拆解/vn的/ude1方法/gi对数/gi组/n进行/vn遍历/gi可以/v找到/v所有/b的/ude1。/w但/c尝试/v之后/f发现/v，/w去/vf重/a是/vshi个/q很/d麻烦/an的/ude1事/n，/w重复/gi的/ude1结果/n很难/d筛掉/nz。/w /x解决/v此/rzs题/n，/w首先/d要/v对数/gi组/n进行/vn排序/gi。/w然后/c固定/a一个数/nz，/w用/p两/nz个/q下边/f从/p数组/gi的/ude1两端/n进行/vn遍历/gi。/w减小/v算法/gi复杂度/gi。/w同时/c，/w还要/d从/p以下/f几个/nz方面/n减小/v算法/gi运行时间/gi。/w /x（/w1/nz）/w原数/nz组/n不够/a3/nz个/q值/n返回/v空/ng。/w /x（/w2/nz）/w固定/a一个/mq值/n。/w遍历/gi的/ude1下标/gi范围/n从/p0/nz到/vnums/nz./nzsize/nz(/nz)/nz-/nz2/nz，/w数组/gi已/d排序/gi，/w所以/c要/v满足/vnums/nz[/nzi/nz]/nz=/nz0。/nz /x（/w3/nz）/w对于/p同一个/b固定值/l。/w要/v考虑/v多/a解/v的/ude1情况/n。/w我们/rr用/p两/nz个/q循环/gi来/vf处理/vn。/w /x（/w4/nz）/w不/d满足条件/l则/d让/v左右/f下标/gi向/p中间/f移动/vn。/w这个/rz问题/gi的/ude1考虑/v方法/gi和/cc3/nzsum/gi一样/uyy。/w还是/c对数/gi组/n进行/vn排序/gi。/w固定/a一个/mq值/n，/w然后/c从/p数组/gi的/ude1两端/n取值/v逼近/v。/w不同之处/l在于/v，/w我们/rr要/v找/v的/ude1是/vshi距离/gitarget/gi最近/t的/ude1值/n，/w因此/c不用/d再/d记录/gi每次/r的/ude1结果/n，/w只/d需要/v保留/v最近/t的/ude1值/n就/d可以/v了/ule。/w当/psum/gi=/nz=/nztarget/gi时/qt，/w已经/d是/vshi最近/t的/ude1结果/n，/w直接/ad返回/v即可/v。/w编码/gi过程/gi中/f，/w有/vyou一个/mq问题/gi是/vshi需要/v注意/v的/ude1，/w就是/vsum/gi的/ude1初始/b取值/v。/w由于/ptarget/gi未知/v，/w不能/v随意/ad给/psum/gi赋一个/nz常数/n，/w因为/c可能/v存在/v初始/b的/ude1sum/gi就/d跟/ptarget/gi相等/vi的/ude1情况/n，/w造成/v算法/gi得出/v错误/gi的/ude1结果/n。/w所以/c。/w我/rr给/psum/gi赋/ng的/ude1初值/n是/vshiwhile/nz循环/gi第一次/nz运行/gi时/qttmp/nz的/ude1值/n。/w这样/rzv以来/f就/d能/v保证/v算法/gi的/ude1正确/a运行/gi。/w4/nz sum/nz的/ude1问题/gi，/w本来/d考虑/v就是/v在/p3/nz sum/nz的/ude1基础上/nz多一层/nz循环/gi，/w固定/a两/nz个数/n，/w然后/c从/p数组/gi两头/n开始/v检索/gi。/w但/c在/p实际/n测试/gi中/f，/w有/vyou个/q问题/gi实在/d头疼/a，/w那/rzv就是/v去/vf重/a！/w！/w！/w加/v一层/nz循环/gi固定/a两/nz个数/n，/w很难/d保证/v这/rzv两/nz个数/n的/ude1组合/gi不会/v出现/v重复/gi。/w期间/f试/v了/ule很/d多方法/nz，/w包括/v设置/gii/nz和/ccj/nz需要/v跳过/v的/ude1情况/n，/w以及/cc与/cc前/f一个/mq插入/gi的/ude1数组/gi比较/gi的/ude1策略/gi，/w都/d不能/v完全/ad保证/v重复/gi数字/gi的/ude1出现/v。/w然后/c又/d尝试/v外层/n固定/a的/ude1两/nz个/q数/n也/d采用/v从/p数组/gi两端/n向/p中间/f压缩/gi的/ude1策略/gi。/w代码/gi重复/gi度/qv很大/d，/w而且/c这种/r方法/gi会/v反过来/d缺少/v一/nz些/q情况/n。/w所以/c，/w最后/f还是/c采用/v了/ule在/p结果/n中/f去/vf重/a，/w重新/d排序/giresult/nz，/w并用/viunique/nz（/w）/w函数/gi去/vf重/a，/w通过/p测试/gi，/w代码/gi如下/vi：/w