#数据结构/gi和/cc算法/gi学习/gi（/w12/nz）/w-堆/nz
堆/gi是/vshi一种树/nz，/w而/cc不是/cjava/gi和/ccc/nz等/udeng提及/v的/ude1内存/gi中的/v“堆/nz”/w前面/f章节/n提到/v的/ude1优先级/n队列/gi可以/v用于/v计算机/gi中的/v任务调度/gi，/w在/p计算机/gi中/f有些/rz程序/gi和/cc活动/gi需要/v比/p其他/rzv的/ude1程序/gi和/cc活动/gi先/d执行/v，/w因此/c要/v分配/gi更高/d的/ude1优先级/n优先级/n队列/gi是/vshi一种/nz抽象数据类型/gi，/w提供/v了/ule删除/gi最大/gm或/c最小/a关键字/gi的/ude1数据项/gi的/ude1方法/gi，/w以及/cc插入/gi数据项/gi的/ude1方法/gi等/udeng在/p第四章/nz中/f优先级/n队列/gi是/vshi用/p有序/gi数组/gi的/ude1形式/gi实现/gi的/ude1，/w这种/r方法/gi的/ude1问题/gi是/vshi尽管/c删除/gi的/ude1时间复杂度/gi为/po/nz(/nz1/nz)/nz，/w但是/c插入/gi的/ude1时间复杂度/gi仍/d是/vshi较长/d的/ude1o/nz（/wn/nz）/w，/w因此/c必须/d要/v移动/vn数字/gi中/f平均/a一般/ad的/ude1数据项/gi以/p插入/gi新的/a数据/gi由/p堆/gi实现/gi的/ude1优先级/n队列/gi的/ude1插入/gi和/cc删除/gi的/ude1时间复杂度/gi都/d是/vshio/nz(/nzlogn/nz)/nz，/w尽管/c删除/gi的/ude1时间/gi慢/a了/ule一点/m，/w但是/c插入/gi的/ude1时间/gi快/a多/a了/ule堆/gi的/ude1介绍/gi堆/gi是/vshi一种/nz特殊/a的/ude1二叉树/gi，/w它/rr的/ude1特点/n如下/vi堆/gi是/vshi完全/ad二叉树/gi。/w也/d就是说/c，/w除了/p树/gi的/ude1最后/f一层/nz节点/gi不/d需要/v是/vshi满/a的/ude1，/w其他/rzv的/ude1每一层/nz从左到右/nz都/d完全/ad是/vshi满/a的/ude1堆常/nz常用/a一个/mq数组/gi实现/gi堆/gi中的/v每一个/nz节点/gi都/d满足/v堆/gi的/ude1条件/n，/w也/d就是说/c每/rz一个/mq节点/gi的/ude1关键字/gi都/d大于/v或/c等于/v这个/rz节点/gi的/ude1子/ng节点/gi关键字/gi下图/n展示/gi了/ule堆/gi与/cc实现/gi他/rr的/ude1数组/gi之间/f的/ude1关系/gi。/w堆/gi在/p存储器/gi中/f表示/v的/ude1数组/gi，/w堆/gi只是/d一个/mq概念/gi上/f的/ude1表示/v，/w需要/v注意/v的/ude1是/vshi，/w树/gi是/vshi完全/ad二叉树/gi，/w并且/c所有/b的/ude1节点/gi都/d满足/v堆/gi的/ude1条件/n弱序/gi堆/gi和/cc二叉搜索树/gi相比/vi是/vshi弱序/gi的/ude1在/p二叉搜索树/gi中/f所有/b节点/gi的/ude1左/f子孙/n的/ude1关键字/gi都/d小于/v右/f子孙/n的/ude1关键字/gi，/w也/d就是说/c，/w二叉搜索树/gi通过/p一个/mq简单/a的/ude1算法/gi就/d可以/v按序/gi遍历/gi节点/gi而/cc在/p堆/gi中/f按序/gi遍历/gi节点/gi是/vshi很/d困难/an的/ude1，/w因为/c堆/gi的/ude1组织/gi规则/gi比/p二叉搜索树/gi的/ude1组织/gi规则/gi要/v弱/a。/w对于/p对/p来说/uls，/w只/d要求/n沿着/p根/n到/v叶子/gi的/ude1每/rz一条路径/nz，/w节点/gi都/d是/vshi按/p降序/nz排列/gi的/ude1由于/p堆/gi是/vshi弱序/gi的/ude1，/w所以/c一/nz些/q操作/gi是/vshi困难/an的/ude1或者/c是/vshi不/d可能/v的/ude1。/w除了/p不/d支持/v便利/an以外/f，/w也/d不能/v在/p堆上/v便利/an的/ude1查找/gi指定/v关键字/gi。/w因为/c在/p查找/gi过程/gi中/f，/w没有/v足够/v的/ude1信息/gi来/vf决定/v选择/gi通过/p节点/gi的/ude1两个子/nz节点/gi中的/v哪/ry一个/mq走向/v下一层/nz，/w他/rr也/d不能/v在/p少/a至/po/nz(/nzlogn/nz)/nz的/ude1时间/gi内/f删除/gi一个/mq指定/v关键字/gi的/ude1节点/gi，/w因为/c没有/v办法/gi能够/v找到/v这个/rz节点/gi。/w因此/c，/w堆/gi的/ude1这种/r组织/gi乎/y非常/d接近/v无需/v。/w不过/c，/w对于/p快速/d一/nz处/n最大/gm节点/gi的/ude1操作/gi以及/cc快速/d插入/gi新/a节点/gi的/ude1操作/gi，/w这种/r顺序/gi已经/d足够/v了/ule。/w移除/v移除/v是/vshi指/v删除/gi关键字/gi最大/gm的/ude1节点/gi。/w这个/rz节点/gi总是/d根/n节点/gi，/w所以/c一/nz处/n是/vshi很容易/nz的/ude1，/w跟/p在/p对数/gi组/n中的/v索引/gi总是/d0/nz然而/c移除/v根/n后/f这/rzv棵树/q就/d不再/d是/vshi完全/ad的/ude1了/ule，/w数组/gi中/fon/nz个/q就/d有/vyou了/ule一个空/nz的/ude1数据/gi单元/n，/w移除/v最大/gm节点/gi的/ude1步骤/gi如下/vi1./nz移走/nz根/n2./nz把/pba最后/f一个/mq节点/gi移动/vn到/v根/n3./nz一直/d向下/vf筛选/v这个/rz节点/gi，/w知道/v他/rr在/p一个/mq大于/v他/rr的/ude1节点/gi之下/f，/w小于/v他/rr的/ude1节点/gi之上/f为止/u如图所示/i注意/v向下/vf筛选/v的/ude1算法/gi要/v检查/gi哪/ry一个子/nz节点/gi更大/d，/w然后/c目标/gi节点/gi和/cc较大/d的/ude1子/ng节点/gi交换/gi位置/gi插入/gi插入/gi节点/gi也/d是/vshi很容易/nz的/ude1。/w插入/gi使用/gi向上/vi筛选/v，/w而/cc不是/c向下/vf筛选/v。/w节点/gi初始/b时/qt插入/gi到/v数组/gi最后/f一个/mq空着/nz的/ude1单元/n中/f，/w数组/gi容量/gi大小/n增/v一/nz插入/gi向上/vi筛选/v新/a节点/gi，/w知道/v他/rr在/p一个/mq大于/v他/rr的/ude1节点/gi之下/f，/w在/p一个/mq小于/v它/rr的/ude1节点/gi之下/f如/v图/gi扩展堆/nz数组/gi在/pjava/gi中/f使用/givector/nz类/gi对象/gi取代/v数组/gi对象/gi，/wvector/nz对象/gi可以/v动态/gi扩展堆/nz操作/gi的/ude1效率/gi二叉树/gi的/ude1层数/nl/nz等于/vlog/gi2/nz(/nzn/nz1/nz)/nz向下/vf或/c向上/vi筛选/v的/ude1循环/gi次数/gi为/pl/nz-/nz1/nz所以/c执行/v时间/gi和/cclog/gi2/nzn/nz成正比/nz综上/nz，/w讨论/gi的/ude1堆/gi操作/gi的/ude1时间复杂度/gi都/d是/vshio/nz(/nzlogn/nz)/nz