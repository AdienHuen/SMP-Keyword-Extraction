#设计模式/nz /x策略模式/gi /x以/pAndroid /nz中/fTextView/nz绘制/v文本/gi、/w颜色/gi为/p背景/n说明/v
先/d来/vf看看/v策略模式/gi的/ude1定义/gi：/w策略模式/gi（/wstrategy pattern/nz）/w：/w策略/gi模式定义/l了/ule一系列/b的/ude1算法/gi，/w并/cc将/d每/rz一个/mq算法/gi封装/gi起来/vf，/w而且/c使/v它们/rr还/d可以/v相互/d替换/v。/w策略模式/gi让/v算法/gi独立/a于/p使用/gi它/rr的/ude1客户/n而/cc独立/a变化/gi。/w类图/gi说明/v：/w上面/f的/ude1定义/gi以及/cc模式/gi的/ude1类图/gi可能/v还是/c比较/gi抽象/gi，/w知道/v个/q大概/d，/w然后/c继续/v读/v下面/f的/ude1文章/gi，/w读完/v以后/f再来/d回味/v，/w效果/gi嘎嘣脆/nz。/w大家/rr应该/v都/d玩/v过/uguo武侠/n角色/gi游戏/gi，/w下面/f就/d以/pandroid/gi中/ftextview/gi绘制/v相关/vn的/ude1文本/gi为/p背景/n，/w为/p大家/rr介绍/gi：/w假设/gi现在/t在/pactivity/gi中/f有/vyou一个/mq文本/gi标签/gitextview/gi，/w需要/v对/p它/rr设置/gi文本/gi内容/gi、/w设置/gi文本/gi大小/n以及/cc设置/gi文本/gi颜色/gi初步/d的/ude1代码/gi（/w不用/d任何/rz模式/gi，/w）/w：/w没/d几/d分钟/qt，/w你/rr写/v好/a了/ule上面/f的/ude1代码/gi /x，/w这时候/rzt /x假设/gi提出/v了/ule新的/a需求/gi，/w存在/v一个/mq自定义/nz控件/gi，/w就是/vview/gi，/w同样/d需要/v在/p它/rr的/ude1上面/f绘制/v文本/gi、/w设置/gi文本/gi的/ude1颜色/gi以及/cc文本/gi的/ude1尺寸/gi的/ude1大小/n。/w这时候/rzt，/w你/rr在/p实际/n的/ude1编写/gi代码/gi的/ude1过程/gi中/f必然/d会/v发现/v，/w代码/gi存在/v的/ude1冗余/n以及/cc结构上/nz的/ude1不合理/nz，/w可读性/n比较/gi差/a。/w那么/c怎样/ryv利用/v策略模式/gi对/p上面/f的/ude1需求/gi进行/vn重新/d编码/gi呢/y？/w看/v下面/f：/w先/d抽象/gi出/vftextview/gi进行/vn操作/gi的/ude1几种/nz行为/n：/w1/nz、/wdrawtextcolorbehavior /nz绘制/v文本/gi颜色/gi的/ude1行为/n2/nz、/wdrawtextcontentbehavior /nz绘制/v文本/gi内容/gi的/ude1行为/n3/nz、/wdrawtextsizebehavior /nz绘制/v文本/gi字体大小/nz的/ude1行为/n既然/c抽象/gi出/vf了/ule上面/f的/ude1三种/nz行为/n，/w我们/rr就/d可以/v抽象/gi出/vf下面/f的/ude1三个/nz接口/gi：/w1/nz、/w绘制/v文本/gi颜色/gi的/ude1接口/gi：/w2/nz、/w绘制/v文本/gi内容/gi的/ude1接口/gi：/w3/nz、/w绘制/v文本/gi字体大小/nz的/ude1接口/gi：/w接下来/vl，/w定义/gi相关/vn的/ude1抽象/gi接口/gi的/ude1实现/gi类/gi：/w1/nz、/w实现/gi绘制/v文本/gi颜色/gi的/ude1接口/gi：/w2/nz、/w实现/gi绘制/v文本/gi内容/gi的/ude1接口/gi：/w3/nz、/w绘制/v文本/gi字体大小/nz的/ude1接口/gi：/w同时/c我们/rr需要/v定义/gi一个/mq整合/gi算法/gi骨架/n的/ude1类/gi：/w最后/f在/pmainactivity/nz中/f进行/vn简单/a的/ude1测试/gi：/w经过/p我们/rr的/ude1修改/gi，/w整体/n的/ude1代码/gi的/ude1目录/gi层次结构/gi清晰/a了/ule很/d多/a。/w当然/d这个/rz例子/gi本身/rz没有/v特别/d大/a的/ude1实用价/nz，/w只是/d起到/v对/p模式/gi的/ude1解释/gi说明/v的/ude1作用/gi。/w最后/f总结/gi一/nz下/foo/nz的/ude1原则/gi：/w1/nz、/w封装/gi变化/gi（/w把/pba可能/v变化/gi的/ude1代码/gi封装/gi起来/vf）/w2/nz、/w多用/b组合/gi，/w少用/n继承/gi（/w我们/rr使用/gi组合/gi的/ude1方式/n，/w为/p客户/n设置/gi了/ule算法/gi）/w3/nz、/w针对/gi接口/gi编程/gi，/w不/d针对/gi实现/gi（/w对于/prole/nz类/gi的/ude1设计/gi完全/ad的/ude1针对/gi角色/gi，/w和/cc技能/gi的/ude1实现/gi没有/v关系/gi）/w