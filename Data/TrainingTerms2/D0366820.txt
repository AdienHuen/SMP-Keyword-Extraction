#Redis/gi之/uzhi利用/v锁/v机制/gi来/vf防止/gi缓存/gi过期/gi产生/v的/ude1惊群/nz现象/n
首先/d，/w所谓/v的/ude1缓存/gi过期/gi引起/v的/ude1“/w惊群/nz”/w现象/n是/vshi指/v，/w在/p大/a并发/gi情况下/nz，/w我们/rr通常/d会用/n缓存/gi来/vf给/p数据库/gi分压/gp，/w但是/c会/v有/vyou这么/rz一种/nz情况/n发生/v，/w那/rzv就是/v当一个/nz缓存数据/n失效/vi之后/f会/v导致/gi同时/c有/vyou多/a个/q并发/gi线程/gi去向/n后端/f数据库/gi发起/v请求/gi去/vf获取/gi同一个/b数据/gi，/w这样/rzv如果/c在/p一段时间/nz内/f同时/c生成/v了/ule大量/m的/ude1缓存/gi，/w然后/c在/p另外/c一段时间/nz内/f又/d有/vyou大量/m的/ude1缓存/gi失效/vi，/w这样/rzv就/d会/v导致/gi后端/f数据库/gi的/ude1压力/n突然/ad增大/v，/w这种/r现象/n就/d可以/v称为/v“/w缓存/gi过期/gi产生/v的/ude1惊群/nz现象/n”/w！/w以下/f代码/gi的/ude1思路/gi，/w就是/v利用/v“锁/nz机制/gi”/w来/vf防止/gi惊群/nz现象/n。/w先/d看/v代码/gi：/w原理/gi就是/v：/w首先/d，/w在/p存储/gi数据/gi的/ude1时候/n，/w设置/gi数据/gi的/ude1过期/gi时间/gi比/p实际/n设置/gi的/ude1过期/gi时间/gi多/a300/nz秒/qt，/w然后/c存储/gi的/ude1数据/gi中/f，/w通过/p一个/mq数组/gi来/vf存储/gi数据/gi，/w数组/gi中/f一个键/nz用来/v存放/v真实/a的/ude1数据/gi，/w另外/c一个键/nz用来/v存放数据/n的/ude1真实/a过期/gi时间/gi，/w这个/rz留到/v后期/f获取数据/l的/ude1时候/n做/v校验/v，/w然后/c把/pba对应/vi这个/rz数据/gi的/ude1“锁/nz”/w删除/gi掉/v。/w这里/rzs这么/rz做/v的/ude1原因/n和/cc读取数据/n的/ude1做法/n相关/vn！/w然后/c，/w在/p读取数据/n的/ude1时候/n，/w依然/d像/v平时/t一样/uyy直接/ad读取/gi，/w如果/c数据/gi已经/d超过/v了/ule有效期/n（/w注意/v：/w这里/rzs的/ude1有效期/n并非/v设置/gi的/ude1有效期/n，/w而是/c更该/v之后/f的/ude1有效期/n）/w，/w那么/c就/d只能/v去/vf读后/n端/v数据库/gi。/w如果/c数据/gi依然/d有效/gi，/w则/d需要/v去/vf判断/gi，/w判断/gi数据“/nz在/p真正/d的/ude1有效期/n内/f是否/v失效/vi”/w，/w如果/c没有/v失效/vi，/w则/d直接/ad返回/v数据/gi！/w重点/n是/vshi，/w假如/c数据“/nz在/p伪造/v的/ude1有效期/n内/f没有/v失效/vi，/w而/cc在/p真正/d的/ude1有效期/n内/f已经/d失效/vi”/w，/w那么/c这时/rzt就/d需要/v去/vf判断/gi“/w数据/gi的/ude1锁”/nz！/w通过/p代码/gi“$/nzlock /nz=/nz /x$/nzthis/nz-/nzredis/gi-/nzincr/nz(/nz$/nzkey /nz./nz /x./nzlock/nz)/nz;/nz”/w可以/v获取数据/l的/ude1锁/v，/w“$/nzlock /nz=/nz=/nz=/nz /x1/nz”/w表示/v数据/gi没有/v锁/v，/w那么/c这/rzv一次/nz请求/gi需要/v发送到/l后端/f数据库/gi去/vf读取/gi最新/a的/ude1数据/gi，/w否则/c的话/udh表示/v该/rz数据/gi已经/d加/v了/ule锁/v，/w也/d就是/v已经/d有/vyou一个/mq线程/gi去/vf后端/f读取数据/n了/ule，/w那么/c后来/t的/ude1线程/gi也/d就/d没有/v权限/gi再/d去/vf后端/f取/v数据/gi，/w需要/v等到/v前面/f的/ude1那个/rz线程/gi执行/v结束/v，/w但是/c这次/r读取/gi就/d只能/v读取/gi“/w旧/a的/ude1数据/gi”/w了/ule！/w通过/p上面/f的/ude1解释/gi也/d就/d明白/v，/w为什么/ryv在/p存储/gi数据/gi的/ude1时候/n需要/v“/w删除/gi数据/gi的/ude1锁”/nz！/w因为/c一旦/d数据/gi被/pbei重新/d存储/gi，/w那么/c说明/v已经/d有/vyou一个/mq线程/gi去/vf后端/f得到/v了/ule最新/a的/ude1数据/gi，/w那么/c该/rz数据/gi的/ude1锁/v就/d可以/v释放/gi，/w然后/c下一个/nz线程/gi在/p获取数据/l的/ude1时候/n如果/c有/vyou需要/v就/d可以/v得到/v这个/rz锁/v，/w然后/c才/d有/vyou权限/gi进入/v到/v后端/f去/vf读取/gi新/a数据/gi！/w