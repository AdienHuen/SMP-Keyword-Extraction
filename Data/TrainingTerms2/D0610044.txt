#hibernate/gi保存/gi对象/gi时/qt你/rr可能/v遇见/v的/ude1棘手/a的/ude1bug/gi
我/rr在/p最近/t工作/gi的/ude1时候/n用/phibernate/gi保存/gi方法/gi的/ude1时候/n遇见/v了/ule这样/rzv的/ude1一个/mq问题/gi，/w执行/v保存/gi方法/gi时/qt某/rz字段/gi为/p“/w0/nz”/w，/wdebug/gi跟/p时/qt显示/gi也/d为/p“/w0/nz”/w，/w但/c全部/m方法/gi执行/v完/vi后/f在/p数据库/gi中/f该/rz字段/gi却/d变成/v了/ule“/w1000/nz”/w，/w在/p日志/gi中/f打印/v出来/vf插入/gi的/ude1也/d是/vshi“/w1000/nz”/w，/w甚是/d费解/a！/w你/rr可能/v也/d会/v遇见/v这样/rzv的/ude1问题/gi，/w然后/c一/nz遍/qv遍/qv的/ude1清理/gi缓存/gi，/w一/nz遍/qv遍/qv的/ude1重启/giide/nz，/w以为/v不是/c代码/gi的/ude1问题/gi。/w之前/f我/rr也/d这么/rz以为/v。/w但是/c后来/t发现/v，/w在/p执行/v保存/gi方法/gi之后/f，/w我/rr另外/c一个/mq方法/gi操作/gi了/ule那个/rz对象/gi，/w并/cc改变/v了/ule。/w所以/c导致/gi了/ule前面/f那个/rz奇怪/v的/ude1bug/gi。/w原来/dhibernate/gi是/vshi在/p最后/f提交/gi事务/gi的/ude1时候/n，/w才/d把/pba执行/v保存/gi方法/gi的/ude1对象/gi的/ude1写入/gi数据库/gi，/w并/cc不是/c在/p执行/v保存/gi方法/gi那一刻/r结束/v就/d把/pba要/v保存/gi的/ude1写入/gi数据库/gi（/w或者/c写入/gi缓存/gi）/w中的/v。/w在/p执行/v保存/gi方法/gi后/f，/w该/rz对象/gi的/ude1依然/d可以/v任意/d改变/v！/w所以/c在/p使用/gihibernate/gi的/ude1时候/n一定/b要/v注意/v对/p对象/gi的/ude1使用/gi，/w对/p相同/a对象/gi进行/vn操作/gi的/ude1时候/n最好/d重新/dnew/nz一个/mq并/cc拷贝/gi之前/f的/ude1数据/gi，/w这样/rzv可以/v防止/gi多/a个/q方法/gi调用/gi一个/mq对象/gi导致/gi的/ude1奇怪/vbug/gi。/w最后/f我/rr也/d是/vshi重新/dnew/nz了/ule一个/mq对象/gi，/w解决/v的/ude1这个/rzbug/gi，/w分享/gi一下/m~/nz鸣谢/v解决/vbug/gi的/ude1组长/nnt航哥/nz~/nz~/nz