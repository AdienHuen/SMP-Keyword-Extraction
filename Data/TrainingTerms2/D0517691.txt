#排序算法/gi―/w―/w冒泡排序/gi
冒泡排序/gi算法/gi的/ude1思想/gi很/d简单/a，/w最/d基本/a的/ude1思想/gi就是/v，/w比较/gi相邻/vi的/ude1两/nz个数/n，/w然后/c依次/d将/d最大/gm（/w或者/c最小/a的/ude1）/w往/p同一个/b方向/gi移动/vn。/w看到/v一个/mq大牛/nz写/v得/ude3很好/ad了/ule，/w我/rr就/d不/d多/a说/v了/ule，/w转载/v过来/vf了/ule（/w感觉/gi好像/v还/d挺/d适合/v练习/v白纸/n写/v程序/gi的/ude1）/w冒泡排序/gi是/vshi非常容易/l理解/gi和/cc实现/gi，/w，/w以/p从小到大/nz排序/gi举例/gi：/w设/v数组/gi长度/gi为/pn/nz。/w1．/nz比较/gi相邻/vi的/ude1前后/f二个/nz数据/gi，/w如果/c前面/f数据/gi大于/v后面/f的/ude1数据/gi，/w就/d将/d二个/nz数据交换/nz。/w2．/nz这样/rzv对数/gi组/n的/ude1第/mq0/nz个/q数据/gi到/vn/nz-/nz1/nz个/q数据/gi进行/vn一次/nz遍历/gi后/f，/w最大/gm的/ude1一个/mq数据/gi就/d“/w沉”/nz到/v数/n组第/nzn/nz-/nz1/nz个/q位置/gi。/w3．/nzn/nz=/nzn/nz-/nz1/nz，/w如果/cn/nz不为/c0/nz就/d重复/gi前面/f二步/nz，/w否则/c排序/gi完成/v。/w按照/p定义/gi很容易/nz写出/v代码/gi：/w下面/f对/p其/rz进行/vn优化/gi，/w设置/gi一个/mq标志/n，/w如果/c这/rzv一/nz趟/qv发生/v了/ule交换/gi，/w则/d为/ptrue/nz，/w否则/c为/pfalse/nz。/w明显/a如果/c有/vyou一/nz趟/qv没有/v发生/v交换/gi，/w说明/v排序/gi已经/d完成/v。/w再/d做/v进一步/d的/ude1优化/gi。/w如果/c有/vyou100/nz个数/n的/ude1数组/gi，/w仅/d前面/f10/nz个/q无序/b，/w后面/f90/nz个/q都/d已/d排好/nz序/n且/c都/d大于/v前面/f10/nz个/q数字/gi，/w那么/c在/p第一/mq趟/qv遍历/gi后/f，/w最后/f发生/v交换/gi的/ude1位置/gi必定/d小于/v10/nz，/w且/c这个/rz位置/gi之后/f的/ude1数据/gi必定/d已经/d有序/gi了/ule，/w记录/gi下/f这/rzv位置/gi，/w第二次/nz只要/c从/p数组/gi头部/n遍历/gi到/v这个/rz位置/gi就/d可以/v了/ule。/w冒泡排序/gi毕竟/d是/vshi一种/nz效率/gi低下/a的/ude1排序/gi方法/gi，/w在/p数据/gi规模/gi很小/a时/qt，/w可以/v采用/v。/w数据/gi规模/gi比较/gi大/a时/qt，/w最好/d用/p其它/rz排序/gi方法/gi。/w（/w第三种/nz方法/gi相对/d第二种/nz，/w就是/v更加/d详细/gi地/ude2记录/gi了/ule交换/gi的/ude1具体位置/nz）/w还有/v一种/nz方法/gi，/w冒泡/vi一次/nz同时/c得到/v最大/gm和/cc最小/a【/w出处/n】/w