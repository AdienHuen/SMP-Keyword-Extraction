#Make /nz命令/gi教程/gi
代码/gi变成/v可执行文件/gi，/w叫做/v编译/gi（/w）/w；/w先/d编译/gi这个/rz，/w还是/c先/d编译/gi那个/rz（/w即/v编译/gi的/ude1安排/v）/w，/w叫做/v构建/gi（/w）/w。/w /x是/vshi最/d常用/a的/ude1构建/gi工具/gi，/w诞生/gi于/p1977/nz年/qt，/w主要/b用于/v语言/gi的/ude1项目/gi。/w但是/c实际上/d /x，/w任何/rz只要/c某个/rz文件/gi有/vyou变化/gi，/w就要/d重新/d构建/gi的/ude1项目/gi，/w都/d可以/v用/p构建/gi。/w /x本文/r介绍/gi命令/gi的/ude1用法/gi，/w从/p简单/a的/ude1讲起/v，/w不/d需要/v任何/rz基础/gi，/w只要/c会/v使用/gi命令行/n，/w就/d能看懂/l。/w我/rr的/ude1参考资料/nz主要/b是/vshi的/ude1《/wmakefile文件/gi教程/gi》/w和/cc《/wgnu make/nz手册/gi》/w。/w一/nz、/wmake/nz的/ude1概念/gi这个/rz词/n，/w英语/nz的/ude1意思/n是/vshi”/w制作/gi”/w。/w命令/gi直接/ad用/p了/ule这个/rz意思/n，/w就是/v要/v做出/v某个/rz文件/gi。/w比如/v，/w要/v做出/v文件/gi，/w就/d可以/v执行/v下面/f的/ude1命令/gi。/w但是/c，/w如果/c你/rr真的/d输入/v这/rzv条/q命令/gi，/w它/rr并/cc不会/v起/vf作用/gi。/w因为/c命令/gi本身/rz并不知道/l，/w如何/ryv做出/v，/w需要/v有人/r告诉/v它/rr，/w如何/ryv调用/gi其他/rzv命令/gi完成/v这个/rz目标/gi。/w /x比如/v，/w假设/gi文件/gi  /x依赖于/v  /x和/cc  /x，/w是/vshi后面/f两/nz个/q文件/gi连接/gi（/w命令/gi）/w的/ude1产物/n。/w那么/c，/w /x需要/v知道/v下面/f的/ude1规则/gi。/w也/d就是说/c，/w /x这/rzv条/q命令/gi的/ude1背后/f，/w实际上/d分成/vi两步/n：/w第一步/nz，/w确认/v  /x和/cc  /x必须/d已经/d存在/v，/w第二步/nz使用/gi  /x命令/gi /x将/d这个/rz两/nz个/q文件/gi合并/gi，/w输出/gi为/p新/a文件/gi。/w /x像/v这样/rzv的/ude1规则/gi，/w都/d写/v在/p一个/mq叫做/v的/ude1文件/gi中/f，/w命令/gi依赖/v这个/rz文件/gi进行/vn构建/gi。/w文件/gi也/d可以/v写/v为/p，/w /x或者/c用/p命令行/n参数/gi指定/v为/p其他/rzv文件名/gi。/w上面/f代码/gi指定/v命令/gi依据/n文件/gi中的/v规则/gi，/w进行/vn构建/gi。/w /x总之/c，/w只是/d一个/mq根据/p指定/v的/ude1命令/gi进行/vn构建/gi的/ude1工具/gi。/w它/rr的/ude1规则/gi很/d简单/a，/w你/rr规定/n要/v构建/gi哪个/ry文件/gi、/w它/rr依赖/v哪些/ry源/ng文件/gi，/w当/p那些/rz文件/gi有/vyou变动/vn时/qt，/w如何/ryv重新/d构建/gi它/rr。/w二/nz、/wmakefile文件/gi的/ude1格式/gi构建/gi规则/gi都/d写/v在/p文件/gi里面/f，/w要/v学会/v如何/ryv命令/gi，/w就/d必须/d学会/v如何/ryv编写/gi文件/gi。/w文件/gi由/p一系列/b规则/gi（/w）/w构成/v。/w每条/d规则/gi的/ude1形式/gi如下/vi。/w上面/f第一行/nz冒号/n前面/f的/ude1部分/n，/w叫做/v”/w目标/gi”/w（/w）/w，/w冒号/n后面/f的/ude1部分/n叫做/v”前置条件/nz”/w（/w）/w；/w第二行/nz必须/d由/p一个键/nz起首/d，/w后面/f跟着/v”/w命令/gi”/w（/w）/w。/w /x“/w目标/gi”/w是/vshi必需/vi的/ude1，/w不可/v省略/v；/w”/w前置条件/gi”/w和/cc”/w命令/gi”/w都/d是/vshi可选/v的/ude1，/w但是/c两者/rzv之中/f必须/d至少/d存在/v一个/mq。/w /x每条/d规则/gi就/d明确/a两件事/nz：/w构建/gi目标/gi的/ude1前置条件/gi是/vshi什么/ry，/w以及/cc如何/ryv构建/gi。/w下面/f就/d详细/gi讲解/gi，/w每条/d规则/gi的/ude1这/rzv三个/nz组成/gi部分/n。/w目标/gi一个/mq目标/gi（/w）/w就/d构成/v一条/nz规则/gi。/w目标/gi通常/d是/vshi文件名/gi，/w指明/v命令/gi所要/b构建/gi的/ude1对象/gi，/w比如/v上文/n的/ude1  /x。/w目标/gi可以/v是/vshi一个/mq文件名/gi，/w也/d可以/v是/vshi多/a个/q文件名/gi，/w之间/f用/p空格/n分隔/vi。/w /x除了/p文件名/gi，/w目标/gi还/d可以/v是/vshi某个/rz操作/gi的/ude1名字/n，/w这/rzv称为/v”伪/nz目标/gi”/w（/w）/w。/w上面/f代码/gi的/ude1目标/gi是/vshi，/w它/rr不是/c文件名/gi，/w而是/c一个/mq操作/gi的/ude1名字/n，/w属于/v”伪/nz目标/gi /x“/w，/w作用/gi是/vshi删除/gi对象/gi文件/gi。/w但是/c，/w如果/c当前目录/gi中/f，/w正好/z有一个/nz文件/gi叫做/v，/w那么/c这个/rz命令/gi不会/v执行/v。/w因为/c发现/vclean/nz文件/gi已经/d存在/v，/w就/d认为/v没有/v必要/a重新/d构建/gi了/ule，/w就/d不会/v执行/v指定/v的/ude1命令/gi。/w /x为了/p避免/v这种/r情况/n，/w可以/v明确/a声明/gi是/vshi”伪/nz目标/gi”/w，/w写法/gi如下/vi。/w声明/gi是/vshi”伪/nz目标/gi”/w之后/f，/w就/d不会/v去/vf检查/gi是否/v存在/v一个/mq叫做/v的/ude1文件/gi，/w而是/c每次/r运行/gi都/d执行/v对应/vi的/ude1命令/gi。/w像/v这样/rzv的/ude1内置/vn目标/gi名/q还有/v不/d少/a，/w可以/v查看/gi手册/gi。/w /x如果/c命令/gi运行/gi时/qt没有/v指定/v目标/gi，/w默认/v会/v执行/v文件/gi的/ude1第一个/gi目标/gi。/w上面/f代码执行/n文件/gi的/ude1第一个/gi目标/gi。/w前置条件/gi前置条件/gi通常/d是/vshi一/nz组/n文件名/gi，/w之间/f用/p空格/n分隔/vi。/w它/rr指定/v了/ule”/w目标/gi”/w是否/v重新/d构建/gi的/ude1判断/gi标准/gi：/w只要/c有/vyou一个/mq前置文件/nz不存在/ns，/w或者/c有/vyou过/uguo更新/gi（/w前置文件/nz的/ude1时间/gi戳/v比/p目标/gi的/ude1时间/gi戳/v新/a）/w，/w”/w目标/gi”/w就/d需要/v重新/d构建/gi。/w上面/f代码/gi中/f，/w构建/gi  /x的/ude1前置条件/gi是/vshi  /x。/w如果/c当前目录/gi中/f，/w /x已经/d存在/v，/w那么/c可以/v正常/a运行/gi，/w否则/c必须/d再写/v一条/nz规则/gi，/w来/vf生成/v  /x。/w上面/f代码/gi中/f，/w后面/f没有/v前置条件/gi，/w就/d意味着/v它/rr跟/p其他/rzv文件/gi都/d无关/v，/w只要/c这个/rz文件/gi还/d不存在/ns，/w每次/r调用/gi，/w它/rr都会/n生成/v。/w上面/f命令/gi连续/gi执行/v两次/nz。/w第一次/nz执行/v会/v先/d新建/v /x，/w然后/c再/d新建/v /x。/w第二次/nz执行/v，/w发现/v  /x没有/v变动/vn（/w时间/gi戳/v晚/tg于/p /x）/w，/w就/d不会/v执行/v任何/rz操作/gi，/w /x也/d不会/v重新/d生成/v。/w /x如果/c需要/v生成/v多/a个/q文件/gi，/w往往/d采用/v下面/f的/ude1写法/gi。/w上面/f代码/gi中/f，/w /x是/vshi一个/mq伪/ag目标/gi，/w只有/c三个/nz前置文件/nz，/w没有/v任何/rz对应/vi的/ude1命令/gi。/w执行命令/n后/f，/w就/d会/v一次性/d生成/v /x，/w，/w /x三个/nz文件/gi。/w这/rzv比/p下面/f的/ude1写法/gi要/v方便/a很/d多/a。/w命令/gi命令/gi（/w）/w表示/v如何/ryv更新/gi目标/gi文件/gi，/w由/p一行/n或/c多/a行/ng的/ude1shell/gi命令/gi组成/gi。/w它/rr是/vshi构建/gi”/w目标/gi”/w的/ude1具体/a指令/gi，/w它/rr的/ude1运行/gi结果/n通常/d就是/v生成/v目标/gi文件/gi。/w /x每行/r命令/gi之前/f必须/d有/vyou一个键/nz。/w如果/c想用/v其他/rzv键/n，/w可以/v用/p内置/vn变量/gi声明/gi。/w上面/f代码/gi用/p指定/v，/w大于/v号/q（/w）/w替代键/nz。/w所以/c，/w每/rz一行/n命令/gi的/ude1起首/d变成/v了/ule大于/v号/q，/w而/cc不是/c键/n。/w /x需要/v注意/v的/ude1是/vshi，/w每行/r命令/gi在/p一个/mq单独/d的/ude1中/f执行/v。/w这些/rz之间/f没有/v继承/gi关系/gi。/w上面/f代码执行/n后/f（/w）/w，/w取/v不到/v的/ude1值/n。/w因为/c两行/nz命令/gi在/p两/nz个/q不同/a的/ude1进程/gi执行/v。/w一个/mq解决办法/n是/vshi将/d两行/nz命令/gi写/v在/p一行/n，/w中间/f用/p分号/n分隔/vi。/w另一个/nz解决办法/n是/vshi在/p换/v行符/nz前/f加/v反/vi斜杠/nz转义/n。/w最后/f一个/mq方法/gi是/vshi加上/v命令/gi。/w  /x目的/gi都/d是/vshi让/v其/rz在/p一个/mq中/f执行/vmakefile文件/gi的/ude1语法/gi注释/gi井/n号/q（/w）/w在/p中/f表示/v注释/gi。/w回声/n（/wechoing/nz）/w正常/a情况下/nz，/w会/v打印/v每条/d命令/gi，/w然后/c再/d执行/v，/w这/rzv就/d叫做/v回声/n（/w）/w。/w执行/v上面/f的/ude1规则/gi，/w会/v得到/v下面/f的/ude1结果/n。/w在/p命令/gi的/ude1前面/f加上/v，/w就/d可以/v关闭/gi回声/n。/w现在/t再/d执行/v，/w就/d不会/v有/vyou任何/rz输出/gi。/w /x由于/p在/p构建/gi过程/gi中/f，/w需要/v了解/v当前/t在/p执行/v哪/ry条/q命令/gi，/w所以/c通常/d只/d在/p注释/gi和/cc纯/a显示/gi的/ude1命令/gi前面/f加上/v。/w通配符/gi通配符/gi（/w）/w用来/v指定/v一/nz组/n符合条件/n的/ude1文件名/gi。/w /x的/ude1通配符/gi与/cc  /x一致/a，/w主要/b有/vyou星号/n（/w？/w[/nz…/w]/nz./nzoo/nz`/nz的/ude1文件/gi。/w模式匹配/gi命令/gi允许/v对/p文件名/gi，/w进行/vn类似/a正则/n运算/gi的/ude1匹配/gi，/w主要/b用/p到/v的/ude1匹配/gi符/v是/vshi。/w比如/v，/w假定/v当前目录/gi下有/v  /x和/cc  /x两/nz个/q源码/gi文件/gi，/w需要/v将/d它们/rr编译/gi为/p对应/vi的/ude1对象/gi文件/gi。/w等同于/vi下面/f的/ude1写法/gi。/w使用/gi匹配符/nz，/w可以/v将/d大量/m同类型/nz的/ude1文件/gi，/w只用/v一条/nz规则/gi就/d完成/v构建/gi。/w变量/gi和/cc赋值/v符/v /x允许/v使用/gi等号/n自定义/nz变量/gi。/w上面/f代码/gi中/f，/w变量/gi  /x等于/v /x。/w调用/gi时/qt，/w变量/gi需要/v放在/v  /x之中/f。/w /x调用/gi变量/gi，/w需要/v在/p美元/q符号/gi前/f，/w再加/nz一个/mq美元/q符号/gi，/w这/rzv是因为/c命令/gi会/v对/p美元/q符号/gi转义/n。/w有时/d，/w变量/gi的/ude1值/n可能/v指向/v另一个/nz变量/gi。/w上面/f代码/gi中/f，/w变量/gi  /x的/ude1值/n是/vshi另一个/nz变量/gi /x。/w这时/rzt会/v产生/v一个/mq问题/gi，/w /x的/ude1值/n到底/d在/p定义/gi时/qt扩展/gi（/w静态/gi扩展/gi）/w，/w还是/c在/p运行/gi时/qt扩展/gi（/w动态/gi扩展/gi）/w？/w如果/c  /x的/ude1值/n是/vshi动态/gi的/ude1，/w这/rzv两/nz种/q扩展/gi方式/n的/ude1结果/n可能会/nz差异/n很大/d。/w /x为了/p解决/v类似/a问题/gi，/w一共/d提供/v了/ule四个赋/nz值/n运算符/gi /x（/w、/w、/w、/w）/w，/w它们/rr的/ude1区别/gi请/v看/v。/w内置/vn变量/gi（/wimplicit variables/nz）/w命令/gi提供/v一系列/b内置/vn变量/gi，/w比如/v，/w /x指向/v当前/t使用/gi的/ude1编译器/gi，/w /x指向/v当前/t使用/gi的/ude1工具/gi。/w这/rzv主要/b是/vshi为了/p跨平台/nz的/ude1兼容性/gi，/w详细/gi的/ude1内置/vn变量/gi清单/n见/v手册/gi。/w自动/d变量/gi（/wautomatic variables/nz）/w命令/gi还/d提供/v一/nz些/q自动/d变量/gi，/w它们/rr的/ude1值/n与/cc当前/t规则/gi有关/vn。/w主要/b有/vyou以下/f几个/nz。/w（/w1/nz）/w指代/n当前/t目标/gi，/w就是/v命令/gi当前/t构建/gi的/ude1那个/rz目标/gi。/w比如/v，/w的/ude1  /x就/d指代/n。/w等同于/vi下面/f的/ude1写法/gi。/w（/w2/nz）/w /x指代/n第一个/gi前置条件/gi。/w比如/v，/w规则/gi为/p /x，/w那么/c /x就/d指代/n。/w等同于/vi下面/f的/ude1写法/gi。/w（/w3/nz）/w /x指代/n比/p目标/gi更新/gi的/ude1所有/b前置条件/gi，/w之间/f以/p空格/n分隔/vi。/w比如/v，/w规则/gi为/p /x，/w其中/rz  /x的/ude1时间/gi戳/v比/p  /x新/a，/w就/d指代/n。/w（/w4/nz）/w /x指代/n所有/b前置条件/gi，/w之间/f以/p空格/n分隔/vi。/w比如/v，/w规则/gi为/p /x，/w那么/c  /x就/d指代/n  /x。/w（/w5/nz）/w /x指代/n匹配/gi符/v  /x匹配/gi的/ude1部分/n，/w /x比如/v /x匹配/gi  /x中的/v /x，/w /x就/d表示/v /x。/w（/w6/nz）/w /x和/cc  /x和/cc  /x分别/d指向/v  /x的/ude1目录名/n和/cc文件名/gi。/w比如/v，/w是/vshi /x，/w那么/c /x的/ude1值/n为/p  /x，/w /x的/ude1值/n为/p /x。/w（/w7/nz）/w /x和/cc  /x和/cc  /x分别/d指向/v  /x的/ude1目录名/n和/cc文件名/gi。/w所有/b的/ude1自动/d变量/gi清单/n，/w请/v看/v手册/gi。/w下面/f是/vshi自动/d变量/gi的/ude1一个/mq例子/gi。/w上面/f代码/gi将/d  /x目录/gi下/f的/ude1  /x文件/gi，/w拷贝到/nz  /x目录/gi下/f。/w首先/d判断/gi  /x目录/gi是否/v存在/v，/w如果/c不存在/ns就/d新建/v，/w然后/c，/w /x指代/n前置/n文件/gi（/w）/w，/w  /x指代/n目标/gi文件/gi（/w）/w。/w判断/gi和/cc循环/gi使用/gi  /x语法/gi，/w完成/v判断/gi和/cc循环/gi。/w上面/f代码/gi判断/gi当前/t编译器/gi是否/v  /x，/w然后/c指定/v不同/a的/ude1库/n文件/gi。/w上面/f代码/gi的/ude1运行/gi结果/n。/w函数/gi /x还/d可以/v使用/gi函数/gi，/w格式/gi如下/vi。/w提供/v了/ule许多/m内置/vn函数/gi，/w可供/v调用/gi。/w下面/f是/vshi几/d个/q常用/a的/ude1内置/vn函数/gi。/w（/w1/nz）/w /x函数/gi /x函数/gi用来/v执行/v  /x命令/gi（/w2/nz）/w /x函数/gi /x函数/gi用来/v在/p  /x中/f，/w替换/v  /x的/ude1通配符/gi。/w（/w3/nz）/w替换/v函数/gi替换/v函数/gi的/ude1写法/gi是/vshi：/w变量名/v /x+/nz /x冒号/n /x+/nz /x替换/v规则/gi。/w上面/f代码/gi的/ude1意思/n是/vshi，/w将/d变量/gi中的/v  /x全部/m替换成/i  /x。/wmakefile /nz的/ude1实例/gi（/w1/nz）/w执行/v多/a个/q目标/gi上面/f代码/gi可以/v调用/gi不同/a目标/gi，/w删除/gi不同/a后缀名/nz的/ude1文件/gi，/w也/d可以/v调用/gi一个/mq目标/gi（/w）/w，/w删除/gi所有/b指定/v类型/gi的/ude1文件/gi。/w（/w2/nz）/w编译/gi语言/gi项目/gi