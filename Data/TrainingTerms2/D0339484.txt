#单例模式/gi及/ccC++/gi实现代码/gi
单例模式/gi单例模式/gi，/w可以/v说/v设计模式/nz中/f最常/d应用/gi的/ude1一种/nz模式/gi了/ule，/w据说/v也/d是/vshi面试官/nz最喜欢/nz的/ude1题目/gi。/w但是/c如果/c没有/v学/v过/uguo设计模式/nz的/ude1人/n，/w可能/v不会/v想到/v要/v去/vf应用/gi单例模式/gi，/w面对/v单例模式/gi适用/vi的/ude1情况/n，/w可能会/nz优先/vd考虑/v使用/gi全局/n或者/c静态/gi变量/gi的/ude1方式/n，/w这样/rzv比较简单/l，/w也/d是/vshi没学/l过/uguo设计模式/nz的/ude1人/n所能/v想到/v的/ude1最简单/nz的/ude1方式/n了/ule。/w一般/ad情况下/nz，/w我们/rr建立/gi的/ude1一/nz些/q类/gi是/vshi属于/v工具/gi性质/n的/ude1，/w基本/a不用/d存储/gi太多/ad的/ude1跟/p自身/rr有关/vn的/ude1数据/gi，/w在/p这种/r情况下/nz，/w每次/r都/d去/vfnew/nz一个/mq对象/gi，/w即/v增加/v了/ule开销/n，/w也/d使得/vi代码/gi更加/d臃肿/a。/w其实/d，/w我们/rr只/d需要/v一个/mq实例/gi对象/gi就/d可以/v。/w如果/c采用/v全局/n或者/c静态/gi变量/gi的/ude1方式/n，/w会/v影响/gi封装性/nz，/w难以/d保证/v别的/rzv代码/gi不会/v对/p全局变量/gi造成/v影响/gi。/w考虑到/v这些/rz需要/v，/w我们/rr将/d默认/v的/ude1构造函数/gi声明/gi为/p私有/gi的/ude1，/w这样/rzv就/d不会/v被/pbei外部/f所/usuonew/nz了/ule，/w甚至/d可以/v将/d析构函数/gi也/d声明/gi为/p私有/gi的/ude1，/w这样/rzv就/d只有/c自己/rr能够/v删除/gi自己/rr了/ule。/w在/pjava/gi和/ccc#/gi这样/rzv纯/a的/ude1面向对象/gi的/ude1语言/gi中/f，/w单例模式/gi非常/d好/a实现/gi，/w直接/ad就/d可以/v在/p静态区/nz初始化/vinstance/gi，/w然后/c通过/pgetinstance/nz返回/v，/w这种/r就/d被/pbei称为/v饿汉式单例/gi类/gi。/w也/d有些/rz写法/gi是/vshi在/pgetinstance/nz中/fnew instance/nz然后/c返回/v，/w这种/r就/d被/pbei称为/v懒汉式/gi单例/gi类/gi，/w但/c这/rzv涉及/v到/v第一次/nzgetinstance/nz的/ude1一个/mq判断/gi问题/gi。/w下面/f的/ude1代码/gi只是/d表示/v一下/m，/w跟/p具体/a哪种/ry语言/gi没有/v关系/gi。/w单线程/gi中/f：/w这样/rzv就/d可以/v了/ule，/w保证/v只/d取得/v了/ule一个/mq实例/gi。/w但是/c在/p多线程/gi的/ude1环境/n下/f却/d不行/a了/ule，/w因为/c很可能/nz两/nz个/q线程/gi同时/c运行/gi到/vif /nz(/nzinstance /nz=/nz=/nz null/nz)/nz这/rzv一句/nz，/w导致/gi可能会/nz产生/v两/nz个/q实例/gi。/w于是/cc就要/d在/p代码/gi中/f加锁/gi。/w多线程/gi中/f：/w但/c这样/rzv写/v的话/udh，/w会/v稍稍/d影响/gi性能/gi，/w因为/c每次/r判断/gi是否/v为/p空/ng都/d需要/v被/pbei锁定/v，/w如果/c有/vyou很/d多线程/gi的话/udh，/w就/d爱/v会/v造成/v大/a量/n线程/gi的/ude1阻塞/vn。/w于是/cc大神/nz们/k又/d想出/vf了/ule双重/b检查/gi锁定/v。/w这样/rzv只够/v极低/d的/ude1几率/n下/f，/w通过/p越过/v了/uleif /nz(/nzinstance /nz=/nz=/nz null/nz)/nz的/ude1线程/gi才/d会/v有/vyou进入/v锁定/v临界区/nz的/ude1可能性/gi，/w这种/r几率/n还是/c比较/gi低/a的/ude1，/w不会/v阻塞/vn太多/ad的/ude1线程/gi，/w但/c为了/p防止/gi一个/mq线程/gi进入/v临界区/nz创建/gi实例/gi，/w另外/c的/ude1线程/gi也/d进去/vf临界区/nz创建/gi实例/gi，/w又/d加上/v了/ule一道/d防御/giif /nz(/nzinstance /nz=/nz=/nz null/nz)/nz，/w这样/rzv就/d确保/v不会/v重复/gi创建/gi了/ule。/w常用/a的/ude1场景/gi单例模式/gi常常/d与/cc工厂模式/gi结合/v使用/gi，/w因为/c工厂/gi只/d需要/v创建/gi产品/gi实例/gi就/d可以/v了/ule，/w在/p多线程/gi的/ude1环境/n下/f也/d不会/v造成/v任何/rz的/ude1冲突/gi，/w因此/c只/d需要/v一个/mq工厂/gi实例/gi就/d可以/v了/ule。/w优点/gi1./nz减少/v了/ule时间/gi和/cc空间/n的/ude1开销/n（/wnew/nz实例/gi的/ude1开销/n）/w。/w2./nz提高/v了/ule封装性/nz，/w使得/vi外部/f不易/ad改动/vn实例/gi。/w缺点/gi1./nz懒汉式/gi是/vshi以/p时间/gi换/v空间/n的/ude1方式/n。/w2./nz饿汉式/gi是/vshi以/p空间/n换/v时间/gi的/ude1方式/n。/wc/nz实现代码/gi，/w示例/gi：/wg /nz-/nzo client singleton/nz./nzcpp client/nz./nzcpp/nz运行/gi结果/n：/wsingleton/gi1/nz=/nz=/nzsingleton/gi2/nz