#排序算法/gi之/uzhi冒泡排序/gi
从/p今天/t开始/v，/w希望/v能/v将/d几/d种/q排序算法/gi一一/d展现/v，/w也/d算是/v对/p自己/rr学习/gi的/ude1一个/mq总结/gi，/w先/d从/p冒泡排序/gi开始/v。/w冒泡排序/gi可能/v是/vshi我们/rr最先/d接触/v的/ude1排序算法/gi，/w至少/d大学/gi里/f我/rr学/v的/ude1第一/mq种/q算法/gi就是/v它/rr，/w话/n不/d多/a说/v，/w让/v我们/rr看看/v冒泡排序/gi。/w冒泡排序/gi：/w在/p要/v排序/gi的/ude1一/nz组/n数/n中/f，/w对/p当前/t还/d未/d排好/nz序/n的/ude1范围内/nz的/ude1全部/m数/n，/w自上而下/al对/p相邻/vi的/ude1两/nz个/q数/n依次/d进行/vn比较/gi和/cc调整/vn，/w让/v较大/d的/ude1数/n往下沉/v，/w较小/d的/ude1往/p上/f冒/v。/w即/v：/w每当/p两/nz相邻/vi的/ude1数/n比较/gi后/f发现/v它们/rr的/ude1排序/gi与/cc排序/gi要求/n相反/vi时/qt，/w就/d将/d它们/rr互换/v。/w这/rzv就是/v冒泡排序/gi的/ude1基本/a思想/gi，/w总之/c，/w每次/r排序/gi之后/f就/d将/d最大/gm(/nz或/c最小/a)/nz的/ude1数/n放在/v最后/f，/w而且/c对于/pn/nz个数/n来说/uls，/w每一次/d，/w我们/rr需要/vn/nz-/nz1/nz次/qv排序/gi实现代码/gi：/w从/p实现代码/gi上/f来看/u，/w我们/rr可以/v得知/v，/w冒泡排序/gi属于/v交换排序/gi。/w在/p内存/gi中/f，/w除了/pn/nz个数/n组/n本身/rz占用/v的/ude1空间/n外/f，/w不再/d占用/v其他/rzv空间/n(/nz变量/gi除外/vi)/nz，/w所以/c冒泡排序/gi的/ude1空间/n复杂度/gi为/po/nz(/nzn/nz)/nz。/w在/p最好/d的/ude1情况下/nz，/w即/v内部/f循环体/n(/nz即/vif/nz语/ng句块/nz中的/v代码/gi)/nz一次/nz也/d不/d执行/v，/w此时/r只/d执行/v外部/f循环体/n代码/gin/nz-/nz1/nz次/qv，/w所以/c冒泡排序/gi在/p最好/d的/ude1情况下/nz，/w其/rz时间复杂度/gi为/po/nz(/nzn/nz)/nz。/w在/p最坏/gi的/ude1情况下/nz，/w即/v内部/f循环体/n每次/r都会/n执行/v(/nz例如/v将/d倒序/nz的/ude1数组/gi转为/gi正/d序/n)/nz，/w外部/f第一次/nz循环/gi，/w内部/f将/d执行/vn/nz-/nz1/nz次/qv；/w外部/f第二次/nz循环/gi，/w内部/f执行/vn/nz-/nz2/nz次/qv；/w.../w./nz./nz外部第/nzn/nz-/nz1/nz次/qv循环/gi，/w内部/f执行/v1/nz次/qv。/w所以/c结果/n是/vshin/nz-/nz1/nz  n/nz-/nz2/nz  /x.../w  /x1。/nz等差数列/gm，/w结果/n为/p(/nzn/nz-/nz1/nz)/nzn/nz=/nzn/nz^/nz2/nz-/nzn/nz。/w所以/c最坏/gi的/ude1情况下/nz冒泡排序/gi的/ude1时间复杂度/gi为/po/nz(/nzn/nz^/nz2/nz)/nz。/w平均/a复杂度/gi为/po/nz(/nzn/nz^/nz2/nz)/nz。/w测试代码/n：/w