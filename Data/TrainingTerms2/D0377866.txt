#读书/vi笔记-/nz2/nzjava/gi虚拟机/gi的/ude1可达性/gi算法/gi与/ccfinalize/nz方法/gi
java/gi通过/p可达性/gi分析/gi算法/gi来/vf确定/v堆/gi中/f哪些/ry对象/gi是/vshi应该/v被/pbei回收/vn的/ude1。/w很/d多/a人/n包括/v我/rr以前/f在/p不/d了解/v的/ude1时候/n总以为/l是/vshi通过/p引用/gi计数器/gi来/vf判断/gi某个/rz对象/gi是否/v应该/v被/pbei回收/vn但是/c后来/t想/v了/ule想/v包括/v查阅/v一/nz些/q资料/gi发现/v不是/c这样/rzv的/ude1，/w因为/c如果/c采用/v引用/gi计数器/gi的/ude1方式/n没有/v办法/gi解决/v循环/gi引用/gi的/ude1问题/gi。/w关于/p可达性/gi分析/gi算法/gi，/w在/pjvm/nz中/f有/vyou个/qgc root set /nz,/nz里面/f有/vyou不/d确定/v个数/n的/ude1gc root /nz。/w可以/v作为/pgc root/nz的/ude1对象/gi有/vyou以下/f几种/nz1./nz虚拟/gi机栈/nz中的/v引用/gi对象/gi2./nz方法/gi区/n中/f类/gi静态/gi属性/gi引用/gi的/ude1对象/gi3./nz方法/gi区/n中的/v常量/gi引用/gi的/ude1对象/gi4./nz本/rz地方/n法栈/nz中/fjni/nz引用/gi的/ude1对象/gijvm/nz就是/v通过/p这些/rzgc root/nz来/vf判定/gi对象/gi是否/v还/d存活/vi的/ude1，/w该/rz算法/gi的/ude1基本/a思想/gi是/vshi通过/p一系列/b的/ude1gc root /nz做为/v起始/gi点/gi向下/vf搜索/gi，/w搜索/gi走过/gi的/ude1路径/gi称为/v引用/gi链/ng，/w当/p一个/mq对象/gi到/vgc root/nz没有/v任何/rz引用/gi链/ng的/ude1时候/n，/w就/d说明/v该/rz对象/gi是/vshi不可/v引用/gi的/ude1，/w此时/r不可/v被/pbei引用/gi的/ude1对象/gi便是/v可以/v回收/vn的/ude1对象/gi。/w图/gi中/fobject/nz5/nz /x6/nz /x7/nz都/d是/vshi可以/v回收/vn的/ude1虽然/c是/vshi可以/v回收/vn的/ude1，/w这里/rzs还/d涉及/v到/v了/ule是否/v一定会/nz被/pbei回收/vn。/w当/p对象/gi无法/v与/ccgc root/nz相连/vi时/qt，/w判定/gi对象/gi是/vshi可以/v回收/vn的当/a对象/gi被判/v定为/v可以/v回收/vn的/ude1时候/n，/w判断/gi其/rz时候/n一定/b要/v被/pbei回收/vn在/p1/nz,/nz2/nz两/nz个/q条件/n满足/v的/ude1情况下/nz，/w当/p对象/gi没有/v覆盖/gifinalize/nz方法/gi，/w或者/cfinaze/nz方法/gi被/pbei执行/v过/uguo虚拟机/gi将/d判定/gi该/rz对象/gi没有/v必要/a执行/vfinalize/nz方法/gi如果/c被判/v定为/v没有/v必要/a执行/vfinalize/nz方法/gi，/w那么/c将/d会/v把/pba对象/gi放到/v一个/mqf/nz-/nzqueue/nz（/wfinalize queue /nz:/w释放/gi队列/gi）/w中/f，/w最后/f将/d由/p虚拟机/gi建立/gi一个/mq低优先级/l的/ude1finalizer/nz线程/gi去/vf释放/gif/nz-/nzqueue/nz中的/v对象/gi在/p释放/gi过程/gi中/f对象/gi还/d可以/v完成/v一次/nz自救/vn，/w自救/vn的/ude1方法/gi就是/v让/v自己/rr与/ccgc root/nz关联/vn起来/vf就/d可以/v了/ule例如/v在/p对象/gi的/ude1finalize/nz方法/gi中/f把/pba自己/rr也/d就是/vthis/nz赋/ng给/p一个一个/nz其他/rzv对象/gi的/ude1变量/gi类型/gi是/vshi当前/t对象/gi的/ude1类型/gi属性/gi（/w但是/c如果/c这个/rz其他/rzv对象/gi也/d是/vshi在/pf/nz-/nzqueue/nz中的/v就/d不能/v完成/v自救/vn，/w原因/n就是/v这个/rz其他/rzv对象/gi本省/r并/cc不能/v与/ccgc root/nz相关联/l）/w，/w但是/c因为/c任何/rz一个/mq对象/gi的/ude1finalizer/nz方法/gi只能/v由/p虚拟机/gi执行/v一次/nz，/w所以/c任何/rz一个/mq需要/v被/pbei回收/vn的/ude1对象/gi，/w也/d只能/v完成/v一次/nz自救/vn。/w后/f记/v：/wfinalize/nz这个/rz方法/gi建议/gi大家/rr平时/t不要/d用/p，/w这个/rz方法/gi完全/ad是/vshi当时/tjava/gi诞生/gi的/ude1时候/n为了/p照顾/vc/nz程序员/gi做出/v的/ude1一种/nz妥协/vi，/w正常/a开发/gi过程/gi中/f完全/ad可以/v忘记/v有/vyou这个/rz方法/gi。/w作者/nnt:/w北京/gi小明/nzqq/gi:/w645707787/nzphone/nz:/w18311276689/nz如果/c有/vyou哪里/rys不/d正确/a的/ude1地方/n,/nz欢迎/v指正/v。/w