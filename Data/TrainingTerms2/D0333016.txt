#《/w机器学习/gi实战/gi》/w之/uzhi二分/giK/nz-均值/nz聚类算法/gi的/ude1python/gi实现/gi
《/w机器学习/gi实战/gi》/w之/uzhi二分/gik/nz-均值/nz聚类算法/gi的/ude1python/gi实现/gi上面/f介绍/gi了/ulek/nz-均值/nz聚类算法/gi及其/cc用/ppython/gi实现/gi，/w上篇/b博文/nz中的/v两/nz张/q截图/vn，/w我们/rr可以/v看到/v，/w由于/pk/nz-均值/nz聚类算法/gi中/f由于/p初始/b质心/gm的/ude1选取/gi，/w会/v造成/v聚类/gi的/ude1局部/n最优/ad，/w并/cc不是/c全局/n最优/ad，/w因此/c，/w会/v造成/v聚类/gi的/ude1效果/gi并不/d理想/n，/w为/p克服/vk/nz-均值/nz算法/gi收敛/gi于/p局部/n最小值/gm的/ude1问题/gi，/w就/d有/vyou了/ule二分/gik/nz-均值/nz算法/gi。/w二分/gik/nz-均值/nz聚类算法/gi二分/gik/nz均值/gi算法/gi是/vshi基本/ak/nz均值/gi算法/gi的/ude1直接/ad扩充/v，/w其/rz基本/a思想/gi是/vshi：/w为了/p得到/vk/nz个/q簇/q，/w首先/d将/d所有/b点/gi的/ude1集合/gi分裂/vi成/v两/nz个/q簇/q，/w然后/c从/p这些/rz簇/q中/f选取/gi一个/mq继续/v分裂/vi，/w迭代/gi直到/v产生/vk/nz个/q簇/q；/w二分/gik/nz均值/gi的/ude1关键/n是/vshi如何/ryv选择/gi待/vi分裂簇/nz，/w选择/gi策略/gi主要/b有/vyou两/nz种/q，/w一是/nz选择/gi包含/v矢量/n个数/n最多/ad的/ude1簇/q进行/vn分裂/vi，/w二是/nz选择/gi具有/v最大/gmsse/nz（/w误差/gi的/ude1平方/q和/cc）/w的/ude1簇/q分裂/vi。/w二分/gik/nz均值/gi算法/gi的/ude1伪代码/nz如下/vi：/w  /x将/d所有/b数据点/nz看成/v一个簇/nz   /x当/p簇/q数目/gi小于/vk/nz时/qt                    /x对/p每一个/nz簇/q                                   /x计算/gi总误差/nz                                     /x在/p给定/gi的/ude1簇/q上面/f进行/vnk/nz-均值/nz聚类/gi（/wk/nz=/nz2/nz）/w                                      /x计算/gi将/d该/rz簇/q一分为/nz二后/nz的/ude1总误差/nz                        /x选择/gi使得/vi误差/gi最小/a的/ude1那个/rz簇/q进行/vn划分/v操作/gi另一种/nz做法/n是/vshi选择/gisse/nz最大/gm的/ude1簇/q进行/vn划分/v，/w直到/v簇/q数目/gi达到/v用户/gi指定/v的/ude1数目/gi为止/u。/wpython/gi实现/gi如下/vi  /x环境/n：/wpython /nz3.4/nz  /x使用/gi的/ude1库/n：/wnumpy/nz、/wmatplotlibbikmeans/nz./nzpy/nz:/w此/rzs文件/gi中的/vkmeans/nz算法/gi与/cc上篇/b博文/nz中的/v代码/gi一致/a，/w在/p上/f一/nz篇/q博文/nz中/f注释/gi写/v的/ude1比较/gi详细/gi，/w这里/rzs就/d没有/v在/p详细/gi注释/gi，/w若/c需要/v看/v注释/gi，/w可以/v看上/v一篇/nz测试/gi文件/gitest/nz./nzpy/nz:/w与/cck/nz均值/gi聚类/gi中的/v代码/gi相同/a，/w这里/rzs也/d就/d没有/v再/d注释/gi运行/gi结果/n截图/vn如下/vi：/w   /x是/vshi乃/v遗憾/gi，/w运行/gi的/ude1结果/n也/d不是/c我们/rr想象/v的/ude1那样/rzv，/w聚类/gi的/ude1结果/n也/d是/vshi随机/b的/ude1，/w不是/c那么/c的/ude1理想/n，/w但是/c，/w按照/p《/w机器学习/gi实战/gi》/w这/rzv本书/gi上面/f提供/v的/ude1二分/gik/nz-均值/nz聚类算法/gi的/ude1思想/gi：/w找到/v分解/gi使得/vi总的/bsse/nz最小/a（/w即/v找到/v那个/rz簇/q使得/vi分解/gi后/f能够/v最大/gm的/ude1降低/vsse/nz）/w）/w来看/u，/w应该/v是/vshi不会/v出现/v上面/f的/ude1问题/gi的/ude1，/w但是/c今天/t无论是/c我/rr参考/gi《/w机器学习/gi实战/gi》/w这/rzv本书/gi上面/f的/ude1源代码/gi，/w还是/c这/rzv篇/q中的/v源码/gi，/w都/d不能/v解决/v这个/rz问题/gi。/w由于/p在/p参考/gi《/w数据挖掘/gi导论/gi》/w这/rzv本书/gi上面/f的/ude1二分/gik/nz均值/gi聚类/gi时/qt看到/v如下/vi的/ude1伪代码/nz。/w因此/c，/w按照/p上面/f的/ude1思路/gi，/w我/rr在/p《/w机器学习/gi实战/gi》/w上面/f的/ude1源码/gi中/f添加/gi了/ule如下/vi代码/gi。/w发现/v，/w依然/d还是/c没有/v办法/gi解决/v这个/rz问题/gi。/w马上/d就要/d去/vf跑步/vi了/ule，/w今天/t就/d思考/gi到/v这里/rzs，/w明天/t我/rr将/d会/v换/v一种/nz方法/gi来/vf解决/v这个/rz问题/gi：/w通过/p找到/v最大/gm的/ude1sse/nz的/ude1那个/rz簇/q，/w然后/c将/d其/rz分解/gi；/w按照/p这样/rzv一个/mq思路/gi我/rr相信/v应该/v可以/v解决/v这个/rz问题/gi。/w源码/gi和/cc测试数据/gi在/p这里/rzs可以/v身体/gi是/vshi自己/rr的/ude1，/w科研/gi是/vshi老板/gi的/ude1，/w哈哈/o /x跑步/vi去/vf了/ule