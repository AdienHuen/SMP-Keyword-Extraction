#Java /nz中/f设计模式/nz /x（/w单例模式/gi）/w /x介绍/gi
需求/gi /x：/w保证/v了/ule一个/mq类/gi在/p内存/gi中/f只能/v有/vyou一个/mq对象/gi思路/gi：/w1/nz、/w如果/c其他/rzv程序/gi能够/v随意/ad用/pnew/nz创建/gi该类/r对象/gi，/w那么/c就/d无法控制/nz个数/n。/w因此/c，/w不让/v其他/rzv程序/gi用/pnew/nz创建/gi该类/r的/ude1对象/gi。/w /x2/nz、/w既然/c不让/v其他/rzv程序/ginew/nz该类/r对象/gi，/w那么/c该类/r在/p自己/rr内部/f就要/d创建/gi一个/mq对象/gi，/w否则/c该类/r就/d永远/d无法/v创建对象/n了/ule。/w /x3/nz、/w该类/r将/d创建/gi的/ude1对象/gi对外/vn(/nz整个/b系统/gi)/nz提供/v，/w让/v其他/rzv程序/gi获取/gi并/cc使用/gi。/w解决/v步骤/gi：/w1/nz、/w /x将/d该类/r中的/v构造函数/gi私有化/vn。/w2/nz、/w在/p本类/r中/f创建/gi一个/mq本类/r对象/gi。/w  /x3/nz、/w定义/gi一个/mq方法/gi，/w返回/v类型/gi是/vshi本类/r类型/gi。/w让/v其他/rzv程序/gi通过/p该/rz方法/gi就/d可以/v获取/gi到/v该类/r对象/gi。/w单例/gi的/ude1设计模式/nz包括/v：/w饿汉式/gi懒汉式/gi饿汉式/gi /x介绍/gi：/w在/p开始/v时/qt就/d new /nz对象/gi简单/a代码实现/gi  /x懒汉式/gi：/w和/cc饿汉式/gi不同/a，/w再/d调用/gi的/ude1时候/n进行/vn判断/gi new/nz对象/gi；/w在/p判断/gi时候/n需要/v将/d其/rz上锁/nz，/w不然/c会/v出现/v问题/gi（/w本人/rr清测/nz）/w线程/gia/nz希望/v使用/gisingletonclass/nz，/w调用/gigetinstance/nz(/nz)/nz方法/gi。/w因为/c是/vshi第一次/nz调用/gi，/wa/nz就/d发现/vinstance/gi是/vshinull/gi的/ude1，/w于是/cc它/rr开始/v创建/gi实例/gi，/w就/d在/p这个/rz时候/n，/wcpu/gi发生/v时间/gi片/q切换/vn，/w线程/gib/nz开始/v执行/v，/w它/rr要/v使用/gisingletonclass/nz，/w调用/gigetinstance/nz(/nz)/nz方法/gi，/w同样/d检测/gi到/vinstance/gi是/vshinull/gi―/w―/w注意/v，/w这/rzv是/vshi在/pa/nz检测/gi完/vi之后/f切换/vn的/ude1，/w也/d就是说/ca/nz并/cc没有/v来得及/v创建对象/n―/w―/w因此/cb/nz开始/v创建/gi。/wb/nz创建/gi完成/v后/f，/w切换/vn到/va/nz继续执行/n，/w因为/c它/rr已经/d检测/gi完了/vi，/w所以/ca/nz不会/v再/d检测/gi一/nz遍/qv，/w它/rr会/v直接/ad创建对象/n。/w这样/rzv，/w线程/gia/nz和/ccb/nz各自/rr拥有/v一个/mqsingletonclass/nz的/ude1对象/gi―/w―/w单例/gi失败/vi！/w设计/gi思想/gi高深/a，/w这个/rz只是/d简单/a的/ude1用/p代码/gi稍微/d的/ude1演示/gi下/f，/w下面/f是/vshi调用/gi上面/f的/ude1测试程序/gi  /x