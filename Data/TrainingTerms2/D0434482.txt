#起泡/vi排序/gi（/w冒泡排序/gi）/w新/a理解/gi
以前/f学/v起泡/vi排序/gi的/ude1时候/n只是/d知道/v它/rr的/ude1思路/gi及/cc实现/gi，/w并/cc没有/v好好/d总结/gi归纳/v一下/m，/w那么/c现在/t就/d来/vf补充/vn一下/m。/w首先/d假设/gi初始/b键序/nz列为/v /x[/nz50/nz /x13/nz /x55/nz /x97/nz /x27/nz /x38/nz /x49/nz /x65/nz]/nz第一/mq趟/qv排序/gi结果/n为/p /x[/nz13/nz /x50/nz /x55/nz /x27/nz /x38/nz /x49/nz /x65/nz]/nz /x97/nz第二趟/nz排序/gi结果/n为/p /x[/nz13/nz /x50/nz /x27/nz /x38/nz /x49/nz]/nz /x55/nz /x65/nz /x97/nz第三趟/nz排序/gi结果/n为/p /x[/nz13/nz /x27/nz /x38/nz /x49/nz]/nz /x50/nz /x55/nz  /x65/nz /x97/nz第四趟/nz排序/gi结果/n为/p /x13/nz /x27/nz /x38/nz /x49/nz /x50/nz /x55/nz /x65/nz /x97/nz那么/c我们/rr整个/b待/vi排序列/nz是/vshi分为/v了/ule有序/gi区/n和/cc无序区/nz（/w右边/f和/cc左边/f）/w：/w有序/gi区/n是/vshi没有/v被/pbei方括/nz号括/nz着/uzhe的/ude1，/w无序/b区/n是/vshi被/pbei方括/nz号括/nz着/uzhe的/ude1，/w一/nz开始/v没有/v排序/gi，/w所以/c初始/b有序/gi区/n为/p空/ng，/w因为/c冒泡排序/gi每次/r都/d是/vshi两/nz两/nz比较/gi，/w大/a的/ude1一方像/nz起泡/vi一样/uyy不断/d向右/d移/v，/w只要/c后面/f的/ude1数/n比/p它/rr小/a，/w那么/c每/rz一/nz轮/qv必然/d会/v从/p无序/b区/n选出/v最大/gm的/ude1数/n那么/c我们/rr首先/d用/p一般/ad的/ude1思路/gi来/vf实现/gi它/rr首先/d第一次/nz排序/gi的/ude1区间/gi是/vshi[/nz1/nz,/nza/nz./nzlength/nz]/nz,/nz那么/c随着/p不断/d排序/gi，/w有序/gi区/n元素/gi增加/v，/w那么/c有序/gi区/n的/ude1元素/gi我们/rr是/vshi不用/d排/v的/ude1，/w我们/rr只需/v排列/gi无序区/nz，/w而/cc我们/rr一般/ad思路/gi的/ude1排序/gi就是/v每次/r排列/gi[/nz1/nz,/nza/nz./nzlength/nz--/nz]/nz,/nz这个/rz区域/n的/ude1数/n，/w因为/c每次/r会/v排出/v最大/gm的/ude1数/n到/v有序/gi区/n，/w所以/c为/pa/nz./nzlength/nz--,/nz /x那么/c这/rzv是/vshi一般/ad实现/gi然后/c第二/mq点/gi我/rr想/v说/v的/ude1是/vshi，/w既然/c可以/v采用/v这种/r不断/d冒泡/vi每次/r选出/v较大/d的/ude1数/n，/w那么/c相反/vi也/d可以/v利用/v这种/r思想/gi每次/r选出/v最小/a的/ude1数/n，/w这个/rz比较/gi好/a实现/gi，/w所以/c这里/rzs就/d不想/v谈/v了/ule最后/f主要/b想/v说/v的/ude1是/vshi我们/rr如何/ryv优化/gi这种/r算法/gi，/w而且/c我们/rr上面/f每/rz趟/qv的/ude1结果/n实际/n是/vshi算法/gi优化/gi后/f的/ude1结果/n，/w如果/c没有/v优化/gi的话/udh，/w数组/gi有/vyou多少/ry个/q元素/gi就/d会/v有/vyou多少/ry趟/qv，/w但是/c这样/rzv算法/gi就/d不够/a好/a了/ule，/w所以/c这里/rzs写/v一下/m优化/gi的/ude1算法/gi这里/rzs我/rr简单/a说/v一/nz下/f优化/gi算法/gi的/ude1思路/gi，/w引入/vexchange/gi这个/rz暂存/nz变量/gi是/vshi为了/p记录/gi每次/r交换/gi的/ude1位置/gi，/w这/rzv是/vshi我们/rr为了/p避免/v像/v上面/f第二趟/nz排序/gi的/ude1时候/n，/w65/nz在/p原地不动/l这种/r情况/n。/w我们/rr每次/r只有/c在/p有/vyou大小/n存在/v是/vshi数/n要/v移动/vn时/qt才/d记录/giexchange/gi，/w否则/c不/d记录/gi，/w则/d我们/rr不/d移动/vn，/w也/d就是/v存在/v像/v65/nz在/p原地不动/l的/ude1这种/r情况/n。/w上面/fexchange/gi=/nz0/nz是/vshi为了/p终止/vwhile/nz循环/gi，/w否则/c将/d一直/d循环/gi下去/vf。/w /x