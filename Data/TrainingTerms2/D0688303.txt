#std/gi:/w:/wsort函数/gi中的/v陷阱/gi
前/f几天/nz收到/v游戏/gi中/f一个/mq很/d严重/a的/ude1bug/gi，/w执行/v某项/r操作/gi的/ude1时候/n会/v出现/v卡/n死/v的/ude1现象/n。/w最后/f调试/gi的/ude1时候/n定位/gi到/vstd/gi的/ude1sort函数/gi，/w发现/v一/nz进/vf这个/rz函数/gi就/d出不来/v了/ule，/w很可能/nz在/p里面/f出现/v了/ule死循环/nz。/w刚开始/nz，/w我/rr还是/c很/d诧异/a。/w大名鼎鼎/vl，/w久经考验/vl的/ude1的/ude1stl/gi算法/gi也/d会/v出现/v死循环/nz？/w于是/ccbaidu/nz了/ule一下/m，/w果然/d在/p网上/s也/d发现/v不/d少/a人/n碰到/v过/uguo类/gi情况/n。/w出现/v死循环/nz大多/d是/vshi由于/p在/psort函数/gi中的/v比较/gi函数/gi里面/f相等/vi元素/gi返回/v了/uletrue/nz。/wstd/gi的/ude1sort函数/gi用/p的/ude1是/vshiquicksort/gi算法/gi，/w采用/v分段/vd递归/gi排序/gi。/w很可能/nz是/vshi在/p递归/gi的/ude1时候/n出现/v问题/gi，/w导致/gi无限/b递归/gi循环/gi。/w后来/t看到/veffecitvestl/nz中第/nz21/nz条/q：/w永远/d让/v比较/gi函数/gi对/p相同/a元素/gi返回/vfalse/nz。/w /x不过/c也/d有/vyou一个/mq更/d保险/n的/ude1方法/gi就是/v使用/gistable/nz_/nzsort函数/gi，/w这个/rz函数/gi是/vshi稳定/an排序算法/gi，/w当/p两/nz个/q元素/gi相等/vi的/ude1时候/n会/v保持/v次序/gi。/w经验证/nz，/w不管/c任何/rz情况/n，/w该/rz函数/gi都/d不会/v引起/v死循环/nz。/w不过/c该/rz函数/gi比起/vsort函数/gi来/vf开销会/nz大一点/nz。/w