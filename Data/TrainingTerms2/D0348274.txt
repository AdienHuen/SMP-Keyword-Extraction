#基于/p唯一状态/gi的/ude1前端/gi组件/gi开发/gi
facebook/nz的/ude1react/nz的/ude1框架/gi提出/v了/ule一个/mq基于/p唯一状态/gi来/vf渲染/gi前端/gi组件/gi的/ude1想法/gi，/w什么/ry是/vshi唯一状态/gi，/w采用/v唯一状态/gi渲染/gi到底/d有/vyou什么/ry好处/gi。/w希望/v大家/rr看到/v这/rzv篇文章/n以后/f不用/d任何/rz框架/gi也/d可以/v写出/v基于/p唯一状态/gi渲染/gi的/ude1前端/gi组件/gi。/w基于/p唯一状态/gi的/ude1组件/gi的/ude1开发模式/gi就是/v组件/gi内部/f永远/d只/d存在/v一份/nz数据/gi来/vf表示/v组件/gi的/ude1状态/gi，/w并且/c更新/gi组件/gi时/qt只/d只/d使用/gi这/rzv一份/nz数据/gi。/w这种/r开发模式/gi的/ude1好处/gi，/w主要/b体现/v在/p以下/f两/nz个/q方面/n减少/v事件/gi与/ccdom/gi元素/gi的/ude1联系/gi便于/v保存/gi和/cc恢复/gi组件/gi的/ude1状态/gi减少/v事件/gi与/ccdom/gi元素/gi的/ude1联系/gi我们/rr先/d来看/u一段/nz传统开发/gi页面/gi交互/gi逻辑/n时/qt写/v的/ude1代码/gi:/w如果/c我们/rr采用/v基于/p唯一状态/gi的/ude1组件/gi开发模式/gi以后/f的/ude1代码/gi通过/p这个/rz比较简单/l的/ude1事例/n我们/rr可以/v看出/v代码/gi已经/d简洁/gi了/ule很/d多/a。/w但是/c这样/rzv写/v到底/d有/vyou什么/ry好处/gi呢/y，/w我们/rr通过/p图形/gi的/ude1方式/n来/vf比较/gi下第一/nz种/q方式/n的/ude1图例/gi第二种/nz方式/n的/ude1图例/gi通过/p这个/rz简单/a的/ude1事例/n，/w感觉/gi好处/gi不是/c太/d明显/a；/w但是/c我们/rr在/p平常/a的/ude1业务/gi大部分/n时候/n要/v比/p这/rzv复杂/a的/ude1多/a，/w会/v有/vyou很/d多/a的/ude1event/nz和/cc很/d多/a的/ude1element/nz,/nz我们/rr如果/c采用/v第一种/nz方式/n的/ude1写法/gi，/w图例/gi如下/vi但是/c如果/c我们/rr采用/v第二种/nz方式/n的/ude1写法/gi，/w图例/gi如下/vi假如/c我们/rr有/vyoum/nz个/qevent/nz,/nz有/vyoun/nz个/qelement/nz，/w如果/c采用/v第一种/nz方式/n的/ude1写法/gi，/w一共/d会/v有/vyou(/nzm/nz*/nzn/nz)/nz中/f连接/gi；/w如果/c我们/rr采用/v第二种/nz方式/n的/ude1写法/gi，/w在/pevent/nz这里/rzs会/v有/vyoum/nz个/qstate/gi的/ude1连接/gi，/w从/pstate/gi到/velement/nz会/v有/vyoun/nz个/q链接/gi，/w一共/d的/ude1会/v有/vyou(/nzm/nz+/nzn/nz)/nz个/q链接/gi；/w这样/rzv写/v是不是/v简化/gi了/ule很/d多/a。/w便于/v记录/gi和/cc恢复/gi组件/gi的/ude1状态/gi我们/rr在/p开发/gi复杂/a表单/gi应用/gi,/nz或者/c操作/gi状态/gi比较/gi多/a的/ude1场景/gi，/w页面/gi刷新/v时/qt需要/v把/pba当前/t的/ude1状态/gi保存/gi到/vlocalstorate/nz，/w服务器端/gi或者/c文件/gi中/f，/w都/d需要/v把/pba当前/t页面/gi作为/p一个/mq唯一状态/gi保存起来/l。/w上面/f的/ude1这样/rzv一个/mq界面/gi，/w当/p我们/rr与/cc页面/gi交互/gi时/qt,/nz点击/v添加/gi，/w上/f一条/nz，/w下/f一条/nz这些/rz按钮/n时/qt，/w所/usuo需要/v做/v的/ude1就是/v更新/gi这个/rz唯一状态/gi，/w保存/gi当前/t状态/gi，/w重新/d更新/gi红色/gi的/ude1区域/n，/w再次/d刷新/v页面/gi时/qt还/d会/v恢复/gi原来/d的/ude1状态/gi，/w像/v下面/f的/ude1代码/gi这样/rzv更新/gi状态/gi保存/gi状态/gi把/pbastate/gi序列/gi化为/v字符串/gi后/f，/w保存/gi到/vlocalstorage/nz中/f渲染/gi组件/gi获取/gi最新/a的/ude1state/gi，/w拼装/nzhtml/gi字符串/gi,/nz然后/c使用/giinnerhtml/nz重绘/nz整个/b组件/gi采用/vinnerhtml/nz重绘/nz组件/gi，/w每次/r交互/gi时/qt都会/n重新/d渲染/gi整块/nz区域/n[/nz没有/v更新/gi的/ude1部分/n也/d会/v重新/d渲染/gi]/nz，/w使得/vi页面/gi的/ude1reflow/nz,/nzrepaint/nz的/ude1次数/gi急剧/d增加/v，/w这样/rzv就/d会/v造成/v的/ude1页面/gi你/rr的/ude1性能/gi下降/vi。/w有/vyou没有/v办法/gi解决/v这个/rz问题/gi呢/y？/w答案/gi当然/d是/vshi有的/rz，/w下篇/n文章/gi中/f我们/rr会/v重点/n分析/gi解决/v这个/rz问题/gi。/w