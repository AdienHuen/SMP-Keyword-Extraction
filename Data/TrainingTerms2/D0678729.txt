#策略模式/gi（/wStrategy/nz）/w
策略模式/gi：/w它/rr定义/gi了/ule算法/gi家族/gi，/w分别/d封装/gi起来/vf，/w让/v他们/rr之间/f可以/v互相/d替换/v，/w此/rzs模式/gi让/v算法/gi的/ude1变化/gi，/w不会/v影响/gi到/v使用/gi算法/gi的/ude1可会/v。/w[/nzdp/gi]/nz /x策略模式/gi是/vshi一种/nz定义/gi一系列/b算法/gi的/ude1方法/gi，/w从/p概念/gi上/f来看/u，/w所有/b这些/rz算法/gi完成/v的/ude1都/d是/vshi相同/a的/ude1工作/gi，/w只是/d实现/gi不同/a，/w它/rr可以/v以/p相同/a的/ude1方式/n调用/gi所有/b的/ude1算法/gi，/w减少/v了/ule各种/rz算法/gi类/gi与/cc使用/gi算法/gi类/gi之间/f的/ude1耦合/vn[/nzdpe/nz]/nz。/w策略模式/gi的/ude1strategy/gi类/gi层次/n为/pcontext/nz定义/gi了/ule一系列/b的/ude1可供/v重用/gi的/ude1算法/gi或/c行为/n。/w继承/gi有助于/v析/vg取出/v这些/rz算法/gi中的/v公共/b功/n[/nzdp/gi]/nz。/w策略模式/gi的/ude1优点/gi简化/gi了/ule单元测试/gi，/w因为/c每个/r算法/gi都/d有/vyou自己/rr的/ude1类/gi，/w可以/v通过/p自己/rr的/ude1接口/gi单独/d测试/gi[/nzdpe/nz]/nz。/w策略模式/gi是/vshi用来/v封装/gi算法/gi的/ude1，/w但/c在实践中/n，/w我们/rr发现/v可以/v用/p它/rr来/vf封装/gi几乎/d任何/rz类型/gi的/ude1规则/gi，/w只要/c在/p分析/gi过程/gi中/f听到/v需要/v在/p不同/a时间/gi引用/gi不同/a的/ude1业务/gi规则/gi，/w就/d可以/v考虑/v使用/gi策略模式/gi处理/vn这种/r变化/gi的/ude1可能性/gi[/nzdpe/nz]/nz。/w