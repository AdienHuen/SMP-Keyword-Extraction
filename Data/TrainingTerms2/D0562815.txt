#java/gi桌面/gi程序/gi中/f使用/gi联动菜单/gi遇到/v与/cc解决/v的/ude1问题/gi
最近/t在/p做/v一个/mq小小的/z系统/gi，/w想/v实现/gi联动菜单/gi，/w故/c尝试/v了/ule几/d种/q方法/gi。/w1/nz、/w想/v通过/p一个/mq线程/gi来/vf监控/gi下拉菜单/nz的/ude1变化/gi，/w从而/c控制/vn从/p菜单/gi。/w遇到/v的/ude1问题/gi：/w①/nz：/w开始/v，/w我/rr是/vshi用/p一个/mq外部/f线程/gi类/gi，/w不过/c我/rr要/v通过/p外部/f线程/gi类/gi来/vf改变/v主/ag窗口/s的/ude1下拉菜单/nz，/w②/nz：/w所以/c，/w就/d需要/v一个/mq传递/v一个/mq类/gi参数/gi才能/n引用/gi，/w③/nz：/w我/rr在/p主/ag窗口/s中/f调用/gi线程/gi类/gi。/w④/nz：/w由于/p我/rr需要/v把/pba从/p数据/gi中/f得来/v的/ude1数据/gi在线/vn程类/nz中/f使用/gi，/w所以/c就/d需要/v在线/vn程类/nz中/f使用/gi数据库/gi连接/gi当然/d不是/c在/prun/nz方法/gi中/f使用/gi，/w而是/c在/p最/d开始/v定义数据/n时/qt就/d初始化/v赋/ng好/a。/w⑤/nz：/w我/rr以为/v，/w在/p最/d开始/v使用/gi数据库/gi连接/gi，/w就/d连/ulian一次/nz，/w应该/v没事/vi。/w⑥/nz：/w接着/c，/w运行时/nz报错/nz，/w应该/v是/vshi数据库/gi连接/gi太多/ad，/w溢出/gi吧/y。/w⑦/nz：/w就/ddebug/gi，/w发现/v一道/d主线/n程/n的/ude1ir /nz=/nz new itemrun/nz(/nz)/nz;/nz这里/rzs就/d报错/nz，/w也/d就是/v，/w初始化/v对象/gi是/vshi就/d有/vyou问题/gi，/w也/d就是/v其/rz构造/n时/qt就/d有/vyou问题/gi。/w⑧/nz：/w想/v了/ule好/a久/a，/w应该/v想通/nz了/ule：/w当/p主线/n程调/nz用/p线程/gi类/gi，/w而/cc线程/gi类/gi中/f又/d有/vyou主线/n程/n，/w继而/c在线/vn程类/nz中/f再/d调用/gi主线/n程构造/nz方法/gi（/w我/rr的/ude1线程/gi类/gi初始化/v在/p主线/n程构造/nz方法/gi中/f）/w，/w这样/rzv就/d会/v产生/v无限/b的/ude1循环/gi，/w一层/nz掉一层/nz，/w有点像/v递归/gi。/w2/nz、/w利用/v事件/gi来/vf监控/gi①/nz：/w所以/c多线程/gi不能/v用/p了/ule，/w突然/ad想到/v了/ule事件/gi监控②/nz：/w通过/p监控/gijcombobox/nz，/w从而/c得到/v它/rr被/pbei选择/gi的/ude1item/nz，/w来/vf改变/v从/p菜单/gi的/ude1items/nz。/w③/nz：/w最终/d成功/a了/ule。/w