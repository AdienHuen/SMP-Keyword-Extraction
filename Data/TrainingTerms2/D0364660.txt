#黑马/n程序员----单/nz例/n设计模式/nz
------、/nz期待/v与/cc您/rr交流/gi！/w /x-------/nzjava设计模式/gi设计模式/nz：/w解决/v某/rz一类/b问题/gi最/d行之有效/vl的/ude1方法/gi一个/mq程序员/gi对/p设计模式/nz的/ude1理解/gi：/w“/w不懂/v”/w为什么/ryv要/v把/pba很/d简单/a的/ude1东西/n搞得/v那么/c复杂/a。/w后来/t随着/p软件开发/nz经验/gi的/ude1增加/v才/d开始/v明白/v我/rr所/usuo看到/v的/ude1“/w复杂/a”/w恰恰/d就是/v设计模式/nz的/ude1精髓/n所在/n，/w我/rr所/usuo理解/gi的/ude1“/w简单/a”/w就是/v一把/nz钥匙/n开/v一把锁/nz的/ude1模式/gi，/w目的/gi仅仅/d是/vshi着/uzhe于/p解决/v现在/t的/ude1问题/gi，/w而/cc设计模式/nz的/ude1“/w复杂/a”/w就/d在于/v它/rr是/vshi构造/n一个/mq“/w万能/b钥匙”/nz，/w目的/gi是/vshi提出/v一种/nz对/p所有/b锁/v的/ude1开锁/nz方案/gi。/w在/p真正/d理解/gi设计模式/nz之前/f我/rr一直/d在/p编写/gi“/w简单/a”/w的/ude1代码/gi。/w这个/rz“/w简单/a”/w不是/c功能/gi的/ude1简单/a，/w二是/nz设计/gi的/ude1简单/a。/w简单/a的/ude1设计/gi意味着/v缺少/v灵活性/gi，/w代码/gi很/d钢硬/nz，/w只/d在/p这个/rz项目/gi里/f有/vyou用/p，/w拿到/v其它/rz的/ude1项目/gi中/f就是/v垃圾/n，/w我/rr将/d其/rz称为/v“/w一次性/d代码/gi”/w。/w要使/c代码/gi可/v被/pbei反复/d使用/gi，/w就/d需要/v使用/gi“/w设计模式/nz”/w对/p代码/gi进行/vn设计/gi。/w设计原则/gi（/w重要/a）/w：/w1./nz /x逻辑/n代码/gi独立/a到/v单独/d的/ude1方法/gi中/f，/w注重/v封装/gi性-易/nz读/v，/w易/ad复用/gi。/w不要/d在/p一个/mq方法/gi中/f，/w写下/v上/f百行/nz的/ude1逻辑/n代码/gi。/w把/pba各/rz小/a逻辑/n代码/gi独立/a出来/vf，/w写/v于/p其他/rzv方法/gi中/f，/w易/ad读/v其/rz可/v重复/gi调用/gi。/w2./nz /x写类/nz，/w写/v方法/gi，/w写/v功能/gi时/qt，/w应/v考虑/v其/rz移植性/n，/w复用性/nz：/w防止/gi一次性/d代码/gi。/w是否/v可以/v拿到/v其他/rzv同类/n事物/n中/f应用/gi？/w是否/v可以/v拿到/v其他/rzv系统/gi中/f应用/gi？/w3./nz /x熟练/a运用/v继承/gi的/ude1思想/gi：/w找出/v应用/gi中/f相同之处/nz，/w且/c不/d容易/ad发生变化/l的/ude1东西/n，/w把/pba他们/rr抽取/v到/v抽象类/gi中/f，/w让子/nz类/gi去/vf继承/gi他们/rr；/w4./nz /x熟练/a运用/v接口/gi的/ude1思想/gi：/w找出/v应用/gi中/f可能/v需要/v变化/gi之处/r，/w把/pba他们/rr独立/a出来/vf，/w不要/d和/cc那些/rz不/d需要/v变化/gi的/ude1代码/gi混/v在/p一起/s。/w单例模式/gi：/w解决/v一个/mq类/gi在/p内存/gi中/f只/d存在/v一个/mq对象/gi想要/v保证/v对象/gi唯一/b：/w1./nz /x为了/p避免/v其他/rzv程序/gi过多/d建立/gi该类/r对象/gi。/w先/d禁止/v其他/rzv程序/gi建立/gi该/rz对象/gi。/w2./nz /x为了/p让/v其他/rzv程序/gi可以/v访问/gi到/v该类/r对象/gi，/w只好/d在/p本类/r中/f，/w自定义/nz一个/mq对象/gi。/w3./nz /x为了/p方便/a其他/rzv程序/gi对/p自定义/nz对象/gi的/ude1访问/gi，/w可以/v对外/vn提供/v一/nz些/q访问/gi方式/n。/w这/rzv三步/nz如何/ryv用/p代码/gi体现/v？/w1./nz /x将/d构造函数/gi私有化/vn2./nz /x在/p类/gi中/f创建/gi一个/mq本类/r对象/gi3./nz /x提供/v一个/mq方法/gi可以/v获取/gi到/v该/rz对象/gi当/p需要/v将/d该/rz事物/n的/ude1对象/gi保证/v在/p内存/gi中/f唯一/b时/qt，/w就/d将/d以上/f的/ude1三步/nz加上/v即可/v。/w饿汉式/gi：/w /x内部/f的/ude1引用/gi：/w在/p定义/gi时/qt，/w就/d直接/ad实例化/gi；/w懒汉式/gi：/w1./nz在/p定义/gi变量/gi时/qt，/w不/d实例化/gi对象/gi；/w*/nz /x2./nz在/p公/ng有/vyou方法/gi内/f，/w先/d判断/gi对象/gi是否/v为/pnull/gi，/w如果/c是/vshi，/w再/d实例化/gi；/w