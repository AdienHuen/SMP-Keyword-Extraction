#设计模式/nz笔记/gi―/w―/w策略模式/gi
一直/d想/v对/p看过/v的/ude1―/w―/whead first/nz设计模式/nz做/v一/nz些/q自己/rr的/ude1总结/gi，/w现在/t终于/d能/v静下来/l写点/n东西/n了/ule。/w设计模式/nz主要/b是/vshi告诉/v我们/rr如何/ryv组织/gi类/gi和/cc对象/gi来/vf解决/v某种/rz问题/gi。/wjava/gi的/ude1类库/gi中/f很/d多/a都/d遵循/gi设计模式/nz的/ude1要求/n，/w比如/vio/gi库/n运用/v到/v了/ule装饰者模式/gi。/w今天/t先/d总结/gi下/f―/w―/w策略模式/gi，/w定义/gi：/w策略/gi模式定义/l了/ule算法族/nz，/w分别/d封装/gi起来/vf，/w让/v它们/rr之间/f可以/v互相/d替换/v，/w此/rzs模式/gi让/v算法/gi的/ude1变化/gi独立/a于/p使用/gi算法/gi的/ude1客户/n。/w原则/gi一/nz：/w如果/c新的/a需求/gi一/nz来/vf，/w我们/rr就/d需要/v更改/gi代码/gi的/ude1某/rz一/nz部分/n，/w那么/c这/rzv部分/n代码/gi需要/v被/pbei独立/a出来/vf，/w以便/d和/cc稳定/an的/ude1代码/gi有所区别/nz。/w相当于/v把/pba变化/gi的/ude1部分/n“/w封装/gi”/w起来/vf，/w好/a让/v其他/rzv部分/n不受/v影响/gi。/w原则二/nz：/w针对/gi接口/gi编程/gi，/w而/cc不是/c针对/gi实现/gi编程/gi。/w当/p超类/nza/nz中/f包含/v某/rz一些子/nz类/gi共有/v的/ude1行为/n时/qt，/w把/pba此/rzs行为/n抽象/gi为/p一个/mq接口/gi，/w为此/bl接口/gi写/v特定/b的/ude1类/gi来/vf实现/gi功能/gi，/w然后/c把/pba实现/gi接口/gi的/ude1类/gi赋/ng给/p类/gia/nz。/w原则三/nz：/w多用/b组合/gi，/w少用/n继承/gi。/w