#中断机制/gi的/ude1引入/v
在/p前面/f的/ude1文章/gi中/f，/w我们/rr理解/gi到/v为了/p让/v灵活/a的/ude1软件/gi来/vf控制/vn计算机/gi，/w我们/rr有/vyou了/ule很/d多/a精巧/a的/ude1设计/gi。/wcpu/gi可以/v解析/gi执行/v一些列/nz指令/gi，/w指令/gi的/ude1组合/gi组成/gi程序/gi。/w程序/gi装入/v内存/gi中/f，/w由/pcpu /nz自动/d一条一条/nz的/ude1解析/gi执行/v，/w而且/c巧妙/a的/ude1实现/gi了/ule指令/gi的/ude1跳转/vi。/w同时/c，/w巧妙/a的/ude1引入/v了/ule设备/gi控制器/n（/w设备/gi适配器/n）/w来/vf控制/vn设备/gi，/wcpu/gi与/cc设备/gi控制器/n之间/f通过/p桥/n和/cc总线/n连接/gi在/p一起/s，/w通过/p总/b线/n协议/gi进行/vn交互/gi。/wcpu/gi通过/p与/cc设备/gi管理器/nz的/ude1交互/gi实现/gi对/p设备/gi的/ude1读写/gi和/cc控制/vn。/w这样/rzv看起来/v已/d很/d完美/a，/w在/p这种/r机制/gi下/f，/w我们/rr可以/v写出/v千变万化/vl的/ude1软件/gi来/vf使用/gi我们/rr的/ude1硬件/gi功能/gi。/w但是/c，/w这/rzv里面/f还/d隐藏/v着/uzhe一/nz些/q问题/gi。/w为什么/ryv需要/v中断机制/gi如果/c我们/rr的/ude1软件/gi执行/v过程/gi中/f，/w不用/d与/cc外部/f交互/gi，/w程序/gi永远/d按部就班/vl执行/v，/w不/d需要/v干预/vn，/w不/d需要/v人机交互/gi，/w那/rzv确实/ad有/vyou前面/f的/ude1机制/gi就/d够/v了/ule。/w但是/c我们/rr在/p使用/gi过程/gi中/f发现/v，/w我们/rr的/ude1需求/gi不止/v这些/rz。/w如/v我们/rr开机/gi之后/f，/w有时/d想/v上网/v，/w有时/d像/v听歌/v，/w有时/d写写/v博客/gi，/w这种/r想法/gi是/vshi随机/b的/ude1突发/gi的/ude1，/w程序/gi不/d可能/v预先/d知道/v。/w针对/gi这样/rzv的/ude1需求/gi，/w我们/rr必须/d提供/v人机交互/gi手段/n。/w比如/v在/p软件/gi执行/v过程/gi中/f有人/r动态/gi的/ude1通知/gi软件/gi现在/t需要/v帮/v我/rr干什么/vi活/v。/w人机交互/gi如何/ryv实现/gi呢/y，/w经典/gi配置/gi是/vshi键盘/gi和/cc鼠标/gi等/udeng输入/v设备/gi的/ude1引入/v和/cc显示器/n等/udeng输出设备/gi的/ude1引入/v。/w也许/d有人/r会/v问/v，/w引入/v这类/r设备/gi的/ude1设备/gi管理器/nzio/gi控制/vn，/wcpu/gi不/d就/d可以/v控制/vn他们/rr了/ule吗/y，/w有/vyou什么/ry不/d一样/uyy的/ude1吗/y？/w还/d真/a有点/d不同/a。/w以前/f的/ude1那种/r方式/n适合于/v随时/d都/d可以/v对/p设备/gi进行/vn读写/gi，/w而/cc对于/p键盘/gi和/cc鼠标/gi，/w只能/v读/v，/w而且/c并/cc不是/c每次/r读/v都/d有/vyou，/w只有/c在/p人/n偶尔/d兴起/v的/ude1时候/n“写/nz”入/nz了/ule，/w才/d有的/rz读/v。/w当然/d，/w我们/rr可以/v隔/v一段时间/nz就/d去/vf读/v一次/nz，/w这样/rzv确实/ad能/v起到/v效果/gi，/w但是/c效率/gi是不是/v有点/d低/a呢/y？/w所以/c，/w对于/p这类/r设备/gi的/ude1控制/vn，/w我们/rr引入/v了/ule中断/gi控制/vn的/ude1思想/gi。/w设备/gi的/ude1接口/gi上有/v一条线/nz是/vshi中断请求/gi线/n。/w当/p键盘/gi点击/v事件/gi发生/v后/f，/w硬件/gi会/v自动/d触发/gi中断请求/gi信号/gi。/w这个/rz请求/gi信号/gi会通/n到/vcpu/gi,/nz cpu/nz在/p执行/v完/vi每/rz一条/nz指令/gi后/f，/w会/v“/w感应/n”/w下/f中断请求/gi信号/gi，/w如果/c有/vyou，/w就/d会/v触发/gi中断/gi处理/vn流程/gi。/w大致/d是/vshi这样/rzv的/ude1，/w首先/d对/p当前/t运行/gi环境/n进行/vn保存/gi，/w然后/c由/p硬件/gi机制/gi获取/gi是/vshi谁/ry申请/v的/ude1中断/gi，/w获取/gi中断/gi号/q，/w根据/p中断/gi号/q找到/v对应/vi的/ude1中断/gi处理程序/n即/v软件/gi部分/n，/w然后/c将/d执行权/n交给/v中断/gi处理程序/n去/vf执行/v。/w执行/v完/vi后/f恢复/gi以前/f的/ude1运行/gi环境/n。/w键盘/gi中断/gi为/p例/n以/p键盘/gi使用/gi为/p例/n，/w我们/rr可以/v这样/rzv进行/vn控制/vn。/w首先/d系统/gi应该/v准备/v有/vyou键盘/gi中断/gi处理程序/n，/w每当/p按键/n事件/gi触发/gi后/f，/w键盘/gi中断/gi处理程序/n会/v将/d按键/n事件/gi存入/v到/v内存/gi缓冲区/gi中/f。/w同时/c在/p程序/gi中/f，/w需要/v获取/gi按键/n信息/gi时/qt，/w则/d查询/gi那个/rz缓冲区/gi，/w看有/v没有/v按键/n信息/gi，/w不断/d轮询/nz，/w直到/v有/vyou按键/n信息/gi。/w我们/rr发现/v这里/rzs也/d是/vshi要/v轮询/nz的/ude1，/w而且/c还/d多/a了/ule个/q中断/gi处理/vn流程/gi，/w有/vyou意义/n吗/y？/w当然/d有/vyou。/w以前/f轮询/nz的/ude1是/vshi设备/gi控制器/n的/ude1io/gi空间/n，/w每次/r查询/gi需要/v占用/v总线/n，/w消耗/gi资源/gi多/a而且/c慢/a，/w现在/t轮询/nz的/ude1是/vshi内存空间/nz，/w速度快/nz且/c不/d占用/vio/gi总线/n，/w减轻/v了/ule系统/gi的/ude1负担/n。/w通过/p这/rzv篇文章/n，/w我们/rr应该/v对/p中断机制/gi有/vyou一个/mq初步/d的/ude1了解/v，/w至于/p软件/gi部分/n如何/ryv利用/v硬件/gi中断机制/gi来/vf为/p应用程序/nz服务/gi，/w那/rzv就/d属于/v软件架构/gi考虑/v的/ude1范畴/n了/ule。/w同时/c我们/rr可以/v感受一下/l计算机/gi设计/gi之/uzhi美/b