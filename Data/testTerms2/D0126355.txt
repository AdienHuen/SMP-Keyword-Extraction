#游戏/gi任务/gi剧情/n布局/gi系统分析/gi
游戏/gi任务/gi剧情/n布局/gi系统分析/gi：/w　　/nz任务/gi系统分/nz主线/n任务/gi、/w日常/b任务/gi和/cc悬赏/v任务/gi：/w主线/n任务/gi的/ude1特点/n：/w“/w所有/b任务/gi分成/vin/nz条/q主线/n，/w每条/d主线/n上/f一个/mq任务/gi完成/v了/ule，/w即使/c不/d领奖/vi也/d可以/v完成/v下一个/nz任务/gi，/w每条/d线/n没有/v尽头/f”/w；/w日常/b任务/gi的/ude1特点/n：/w“/w每天/r0/nz点/gi重置/n，/w共有/vn/nz个/q任务/gi，/w完成/v一个/mq则/d可/v领奖/vi，/w领奖/vi后/f此/rzs任务/gi消失/vi”/w；/w悬赏/v任务/gi的/ude1特点/n：/w比较复杂/l“/w每天/r有/vyou3/nz次/qv刷新/v机会/gi，/w每次/r刷新/v出/vf5/nz个/q任务/gi，/w任务/gi完成/v领奖/vi后/f消失/vi。/w任务/gi分/qt1/nz-/nz5/nz星/n，/w生星/nz规则/gi根据/p主角/nnt等级/n和/cc星级/b概率/gi动态/gi生成/v。/w”/w；/w刚开始/nz做/v的/ude1时候/n打算/gi用/p一个/mq统一/vn的/ude1类/gi包装/n所有/b的/ude1任务/gi，/w对外/vn提供/v生成/v任务/gi和/cc任务/gi领奖/vi的/ude1接口/gi就行了/l，/w结果/n做完/v之后/f发现/v这/rzv三种/nz任务/gi的/ude1不同点/n多于/v共同点/n，/w放在/v一个/mq类/gi里面/f用/p三种/nz结构/gi处理/vn，/w还是/c得用/v类型/gi区分/v的/ude1，/w倒不如/v分开/vi处理/vn更/d直接/ad。/w实际上/d这三类/l任务/gi除了/p“/w生成/v任务/gi”/w和/cc“/w更新/gi任务/gi状态/gi”/w、/w“/w完成/v任务/gi领奖/vi”/w这/rzv三个/nz共同/d接口/gi，/w其他/rzv操作/gi完全/ad没有/v关系/gi。/w如果/c继承/gi也/d只能/v继承/gi自/p一个/mq抽象类/gi，/w而/cc这个/rz抽象类/gi不能/v覆盖/gi对外/vn的/ude1全部/m接口/gi（/w比如/v“/w刷新/v任务/gi”/w只有/c悬赏/v任务/gi才/d有/vyou）/w，/w所以/c我/rr决定/v把/pba这/rzv三个类/nz完全/ad独立/a开/v，/w包括/v协议/gi、/w存储/gi、/w实现/gi。/w他们/rr共有/v的/ude1逻辑/n是/vshi任务/gi完成/v的/ude1条件/n，/w以及/cc对/p完成/v条件/n的/ude1检查/gi。/w　/nz　“/nz任务/gi完成/v条件/n”/w是/vshi譬如/v“/w杀死/vn/nz只/d独角兽/n”/w、/w“/w收集/vn/nz个/qx/nz物品/gi”/w、/w“通/nz关第/nzx/nz关卡/n”/w之类/rz的/ude1判定/gi条件/n。/w稍作/v总结/gi就/d发现/v其本质/n就是/v对/p某种/rz特定/b事件/gi的/ude1计数/vi，/w像/v“/w等级/n到达/v20/nz级/q”/w就是/v对/p级别/n的/ude1计数/vi，/w或者/c是/vshi“/w等级/n到达/v20/nz级/q1/nz次/qv”/w这个/rz事件/gi的/ude1计数/vi，/w由于/p等级/n、/w关卡/n这种/r主要/b计数/vi都/d是/vshi已经/d存在/v的/ude1，/w就/d不必/d单独/d计数/vi了/ule，/w直接/ad拿/v过来/vf判断/gi即可/v。/w当时/t对/p任务/gi完成/v条件/n的/ude1计数/vi如何/ryv存储/gi如何/ryv更新/gi有/vyou过/uguo激烈/a的/ude1思想斗争/l，/w我/rr大概/d想/v过/uguo这些/rz方案/gi：/wa/nz)/nz方案/gi一/nz：/w每个/r任务/gi完成/v条件/n是/vshi一个/mq对象/gi，/w这个/rz对象/gi接收/gi输入/v（/w玩家/n的/ude1指针/gi或/c数据/gi）/w，/w输出/gi完成/v结果/n。/w在/p配表/nz的/ude1时候/n把/pba所有/b任务/gi的/ude1完成/v条件/n都/d预先/d初始化/v完毕/vi，/w运行/gi时/qt传入/gi玩家/n指针/gi判断/gi是否/v完成/v此/rzs任务/gi。/w这样/rzv做/v有/vyou2/nz个/q缺点/gi，/w1/nz任务/gi完成/v条件/n不是/c按/p任务/gi完成/v条件/n类型/gi分/qt的/ude1，/w而是/c按/p实现/gi一一/d初始化/v的/ude1，/w导致/gi内存/gi浪费/gi。/w2/nz由于/p无法/v预先/d知道/v有/vyou多少/ry对象/gi，/w需要/v动态分配/l内存/gi。/wb/nz)/nz方案/gi二/nz：/w每个/r任务/gi完成/v条件/n是/vshi一个/mq函数/gi，/w这个/rz函数/gi是/vshi按/p任务/gi完成/v条件/n的/ude1类型/gi分/qt的/ude1，/w所以/c函数/gi个数/n是/vshi固定/a的/ude1。/w还有/v一个/mq分配器/n，/w负责/v运行/gi时/qt根据/p任务/giid/nz去/vf配置/gi表取/nz完成/v条件/n，/w从/p完成/v条件/n里面/f取出/v类型/gi，/w再/d根据/p类型/gi找/v处理函数/n，/w把/pba配置/gi的/ude1参数/gi和/cc玩家/n指针/gi传入/gi，/w输出/gi完成/v结果/n。/w优点/gi是/vshi节省/v了/ule内存/gi，/w简化/gi了/ule实现/gi。/w缺点/gi是/vshi每次/r要/v去/vf配表/nz找/v完成/v条件/n的/ude1参数/gi。/wc/nz)/nz方案三/nz：/w任务/gi完成/v条件/n按照/p类型/gi分为/vn/nz个/q函数/gi，/w每日/r任务/gi记录/gi5/nz个/q计数/vi，/w悬赏/v任务/gi记录/gi5/nz个/q计数/vi，/w主线/n任务/gi记录/gi10/nz个/q计数/vi。/w任务/gi完成/v领奖/vi的/ude1时候/n，/w判断/gi是否/v完成/v，/w比较/gi计数/vi和/cc配表/nz。/wd/nz)/nz方案/gi四/nz：/w目前/t的/ude1做法/n。/w任务/gi完成/v条件/n是/vshi用于/v判定/gi的/ude1数据/gi，/w作为/p任务/gi的/ude1一个/mq属性/gi。/w在/p所有/b任务/gi完成/v动作/gi的/ude1地方/n触发/gi计数/vi，/w客户端/gi请求/gi任务/gi状态/gi的/ude1时候/n，/w服务器/gi遍历/gi任务/gi完成/v条件/n，/w设置/gi完成/v状态/gi判定/gi是否/v完成/v。/w　　/nz最后/f一个/mq方案/gi就是/v目前/t的/ude1做法/n，/w相当于/v把/pba任务/gi完成/v条件/n作为/p每个/r任务/gi的/ude1一个/mq附加/vn数据项/gi（/w一个/mq任务/gi可能/v有/vyou多/a个/q完成/v条件/n）/w，/w任务/gi完成/v条件/n作为/p一个/mq结构/gi存在/v：/w{/nz完成/v类型/gi，/w参数/gi1/nz，/w参数/gi2/nz，/w.../w}/nz。/w一旦/d生成/v了/ule一个/mq任务/gi（/w生成/v了/ule就/d等于/v接收/gi了/ule任务/gi）/w，/w这个/rz任务/gi就/d按照/p配表/nz初始化/v自己/rr的/ude1任务/gi完成/v条件/n。/w　　/nz剩下/v的/ude1问题/gi就是/v：/w每个/r任务/gi的/ude1计数/vi在/p哪里/rys更新/gi？/w我/rr曾/d想/v过/uguo既然/c某个/rz任务/gi完成/v条件/n存在/v，/w必然/d要/v依赖/v其他/rzv逻辑/n模块/gi计数/vi，/w如果/c其他/rzv模块/gi把/pba我/rr要/v计数/vi的/ude1都/d给/p我/rr记/v着/uzhe，/w我/rr拿/v过来/vf用/p不/d就行了/l？/w但是/c我/rr想到/v了/ule一个/mq坑/n，/w悬赏/v任务/gi的/ude1坑/n：/w不能/v在/p每个/r逻辑/n模块/gi对/p要/v计数/vi的/ude1变量/gi计数/vi，/w比如/v两/nz个/q悬赏/v任务/gi都/d是/vshi强化/v武器/n，/w一个/mq30/nz次/qv一个/mq40/nz次/qv，/w就/d有/vyou两/nz个/q计数/vi，/w逻辑/n模块/gi不/d知道/v有/vyou几/d个/q计数/vi。/wso/nz，/w计数/vi只能/v放在/v每个/r任务/gi单元/n中/f，/w其他/rzv逻辑/n模块/gi引用/gi计数/vi变量/gi的/ude1地址/gi计数/vi。/w　　/nz问题/gi又/d来/vf了/ule，/w我/rr想要/v的/ude1计数/vi，/w其他/rzv模块/gi未必/d直接/ad提供/v给/p我/rr了/ule。/w比如/v通过/p第/mq3/nz关/n2/nz次/qv，/w显然/ad我/rr既/c不能/v要求/n关卡/n模块/gi给/p我/rr这个/rz接口/gi，/w也/d不能/v要求/n他/rr在/p第三关/nz的/ude1时候/n调用/gi我/rr的/ude1接口/gi，/w只能/v是/vshi在/p通过/p每/rz一/nz关/n的/ude1时候/n调用/gi我/rr的/ude1一个/mq“/w和/cc通关/vn有关/vn”/w的/ude1接口/gi，/w然后/c把/pba第/mq3/nz关/n作为/p参数/gi传给/v我/rr。/w另外/c，/w我/rr可能/v同时/c有/vyou多/a个/q任务/gi都/d和/cc通关/vn有关/vn，/w于是/cc我/rr的/ude1任务/gi系统/gi和/cc关卡/n系统/gi之间/f需要/v一个/mq适配器/n来/vf协调/gi，/w适配器/n知道/v我/rr哪些/ry任务/gi和/cc通关/vn有关/vn，/w然后/c提供/v一个/mq统一/vn的/ude1接口/gi给/p关卡/n系统/gi调用/gi，/w当/p通关/vn的/ude1时候/n，/w适配器/n把/pba所有/b和/cc通关/vn有关/vn的/ude1任务/gi计数/vi更新/gi。/w那么/c，/w任务/gi系统/gi和/cc任务/gi完成/v适配器/n之间/f要/v怎么/ryv配合/v呢/y？/w显然/ad，/w生成/v任务/gi的/ude1时候/n，/w要/v把/pba任务/gi通知/gi给/p适配器/n，/w适配器/n给/p我/rr按/p完成/v条件/n归类/vi；/w完成/v任务/gi的/ude1时候/n，/w要/v通知/gi适配器/n检查/gi是否/v已经/d完成/v任务/gi，/w如果/c完成/v就/d删除/gi这个/rz任务/gi的/ude1计数/vi。/w　　/nz我/rr画/v了/ule一个/mq示意图/gi，/w用来/v表示/v这个/rz静态/gi结构/gi关系/gi：/w第一层/nz是/vshi任务/giid/nz和/cc任务/gi单元/n的/ude1一个/mqmap/nz表/n，/w第二层/nz是/vshi每个/r任务/gi单元/n的/ude1实体/nlist/gi，/w第三层/nz是/vshi任务/gi完成/v条件/n的/ude1管理器/nz，/w也/d就是/v那个/rz和/cc其他/rzv模块/gi配合/v的/ude1适配器/n，/w里面/f维护/gi着/uzhe多/a个/q链表/gi，/w每个/r链表/gi代表/nnt一种/nz完成/v条件/na/nz，/w每个/r链表/gi存储/gi着/uzhe某个/rz任务/gi的/ude1id/nz和/cc这个/rz任务/gi的/ude1完成/v条件/n(/nz属于/va/nz类型/gi的/ude1完成/v条件/n)/nz，/w存/vid/nz是/vshi为了/p删除/gi的/ude1时候/n方便/a。/w途中/s的/ude1每个/r方块/gi代表/nnt一个/mq任务/gi完成/v条件/n的/ude1结构/gi，/w每个/r任务/gi单元/n有/vyou多/a个/q完成/v条件/n，/w每种/r完成/v条件/n类型/gi对应/vi一种/nz颜色/gi。/w　　/nz如此/rzv，/w就/d解决/v了/ule整个/b任务/gi的/ude1生成-计数-完成-删除/nz的/ude1生命周期管理/gi。/w目前/t的/ude1方案/gi不足/an的/ude1地方/n就是/v：/w如果/c要/v增加/v一种/nz完成/v条件/n，/w就要/d在/p适配器/n中/f增加/v对应/vi的/ude1代码/gi。/w理想/n的/ude1情况/n是/vshi无论/c完成/v条件/n是/vshi什么/ry，/w也/d只不过/d是/vshi一种/nz类型/gi和/cc参数/gi的/ude1组合/gi，/w我/rr只/d需要/v根据/p类型/gi给/p他/rr指定/v计数/vi方案/gi（/w就是/v在/p任务/gi完成/v条件/n适配器/n中的/v位置/gi）/w，/w无需/v增加/v代码/gi就/d能/v被/pbei归类/vi管理/gi起来/vf。/w当然/d，/w前提/n是/vshi适配器/n与/cc其他/rzv模块/gi的/ude1接口/gi稳定/an且/c健全/v，/w新增/v的/ude1功能/gi是/vshi必然/d要/v增加/v接口/gi的/ude1。/w