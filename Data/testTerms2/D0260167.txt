#浅析/gi设计模式/nz之/uzhi工厂方法模式/gi及/cc一/nz篇/q相关/vn翻译/gi
浅析/gi设计模式/nz之/uzhi工厂模式/gi及/cc一/nz篇/q相关/vn翻译/gi  /x翻译/gi资料/gi来源/gi:/w /x工厂方法/gi设计模式/nz目的/gi为/p创建对象/n的/ude1方法/gi定义/gi接口/gi，/w但是/c让子/nz类/gi决定/v要/v实例化/gi的/ude1类/gi。/w工厂方法/gi将/d一个/mq类/gi的/ude1实例化/gi交给/v子类/gm去/vf施行/v定义/gi“/w虚拟”/nz的/ude1构造器/gi操作/gi符/v’/wnew/nz’/w被/pbei认为/v不利于/v代码复用/gi问题/gi框架/gi需要/v标准化/vn一系列/b应用/gi的/ude1架构/gi模型/gi，/w但是/c却/d允许/v单一/gi的/ude1应用程序/nz定义/gi它们/rr自己/rr的/ude1对象/gi域/ng，/w并且/c提供/v这些/rz对象/gi的/ude1实例/gi讨论/gi工厂方法/gi就/d像/v执行/v算法/gi提供/v对象/gi的/ude1模板方法/gi。/w一个/mq父类/nz定义/gi了/ule所有/b方法/gi标准/gi与/cc泛型/gi（/w使用/gi占位/v符/v）/w，/w然后/c继承/gi并/cc实现/gi方法/gi的/ude1细节/gi，/w提供/v给/p用户/gi使用/gi工厂方法/gi使/v软件设计/nz更加/d自定义/nz，/w并且/c相对/d起来/vf只/d复杂/a一/nz点点/v。/w其它/rz的/ude1设计模式/nz需要/v新的/a类/gi，/w然而/c工厂方法/gi只/d需要/v新的/a操作/gi程序员/gi们/k经常/d使用/gi工厂方法/gi作为/p创造/v对象/gi的/ude1标准方法/gi，/w但是/c以下/f情况下/nz它/rr并不/d适合/v使用/gi:/w这个/rz类/gi被/pbei实例化/gi后/f不再/d需要/v改变/v了/ule，/w或者/c这个/rz类/gi的/ude1子类/gm可以/v将/d它/rr替代/v掉/v工厂方法模式/gi与/cc抽象/gi方法/gi模式/gi相似/a，/w但/c它/rr并不/d强调/v工厂/gi家族/gi工厂方法/gi经常/d被/pbei各种/rz设计/gi框架/gi使用/gi，/w然后/c被/pbei使用/gi框架/gi的/ude1用户/gi执行/v结构/gi工厂方法/gi的/ude1实现/gi大部分/n与/cc抽象工厂/gi重合/vi。/w工厂方法/gi比较/gi广泛/a的/ude1定义/gi是/vshi：/w一个/mq返回/v所需/nz对象/gi的/ude1静态方法/gi。/w但是/c与/cc构造器/gi不同/a，/w实际/n返回/v的/ude1是/vshi子类/gm的/ude1对象/gi实例/gi；/w已/d存在/v的/ude1对象/gi可以/v被/pbei重用/gi而/cc不是/c重新/d创建/gi一个/mq对象/gi；/w工厂方法/gi有着/v更多/ad的/ude1具有/v描述/gi性/ng的/ude1名字/n。/wclient/nz被/pbei完全/ad的/ude1从/p类/gi的/ude1执行/v细节/gi中/f解耦/gi，/w多态/gi转换/gi变成/v可能/v示例/gi工厂方法/gi定义/gi了/ule创造/v对象/gi的/ude1接口/gi，/w但是/c让子/nz类/gi决定/v他/rr那些/rz类/gi需要/v被/pbei实例化/gi。/w模型/gi打印/v与/cc这个/rz模式/gi相似/a。/w橡皮/n玩具/n的/ude1基础设施/gi处理/vn橡皮/n模型/gi粉末/n，/w并且/c将/d粉末/n注入/gi模型/gi获取/gi想要/v的/ude1形状/n。/w玩具/n类/gi由/p模型/gi决定/v清单/n如果/c你/rr遇到/v需要/v多态/gi的/ude1继承/gi结构/gi，/w尝试/v利用/v多态/gi定义/gi一个/mq静态/gi的/ude1工厂方法/gi。/w设计/gi传入/gi工厂方法/gi的/ude1参数/gi。/w考虑/v使/v所有/b的/ude1构造器/gi的/ude1修饰/v符/v为/pprivate/nz或/cprotected/nz首要/b原则/gi抽象工厂/gi类/gi通常/d需要/v实现/gi工厂方法/gi，/w但是/c它们/rr都/d可以/v通过/p属性/gi实现/gi工厂方法/gi通常/d被/pbei称为/v嵌入/v模板方法/gi工厂方法/gi：/w通过/p继承/gi实现/gi   /x属性/gi：/w通过/p代理/gi实现/gi通常/d，/w设计/gi从/p工厂方法/gi开始/v（/w更/d简单/a，/w更/d灵活/a，/w子类/gm剧增/vi）/w，/w慢慢/d转化成/l了/ule抽象工厂/gi，/wprototype/gi或者/cbuilder/gi(/nz更/d复杂/a，/w更/d灵活/a)/nz。/w它们/rr的/ude1选择/gi根据/p程序员/gi的/ude1实际/n需求/gi选择/giprototype/gi不/d需要/v继承/gi的/ude1子类/gm，/w但是/c它/rr需要/v初始化/v的/ude1操作/gi。/w工厂方法/gi需要/v继承/gi的/ude1子类/gm，/w但是/c不/d需要/v初始化/v的/ude1操作/gi工厂方法/gi的/ude1好处/gi在于/v它/rr可以/v返回/v同样/d的/ude1实例/gi多/a次/qv，/w或者/c可以/v返回/v它/rr的/ude1子类/gm而/cc不是/c这个/rz类/gi的/ude1对象/gi一/nz些/q工厂方法/gi倡导/v构造器/gi需要/vprivate/nz或者/cprotected/nz。/w它/rr产生/v新的/a对象/gi或者/c回收/vn旧/a的/ude1对象/gi与/cc其它/rz类/gi无关/v‘/wnew/nz’/w修饰/v符/v被/pbei认为/v对/p代码复用/gi有害/a。/w请求/gi一个/mq对象/gi与/cc创造/v一个/mq对象/gi有着/v差别/n。/w‘/wnew/nz’/w修饰/v符/v通常/d创建/gi一个/mq对象/gi，/w工厂方法/gi强制/vd封装/gi，/w并且/c返回/v一个/mq对象/gi而/cc不用/d创建/gi工厂模式/gi的/ude1个人见解/l工厂方法/gi封装/gi了/ule返回/v一个/mq对象/gi的/ude1方法/gi，/w返回/v的/ude1对象/gi由/p程序员/gi通过/p参数/gi传入/gi进行/vn判断/gi。/w实例/gi当/p工厂/gi的/ude1类/gi增加/v时/qt，/w就/d需要/v将/d工厂方法模式/gi转换/gi为/p抽象工厂模式/gi抽象工厂/gi需要/v两/nz个/q父类/nz，/w一个/mq工厂/gi父类/nz，/w一个/mq产品/gi父类/nz工厂方法/gi需要/v一个/mq产品/gi父类/nz