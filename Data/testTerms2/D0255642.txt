#java/gi进阶/gi（/w一/nz）/w--控制/nz反转/gmIoC/nz
控制/vn反转/gm（/winversion of control/nz，/w英文/nz缩写/n为/pioc/gi）/w，/w亦/d称为/v /x“/w依赖/v倒置/vi原理/gi”/w(/nzdependency inversion principle/nz)/nz，/w是/vshi一个/mq重要/a的/ude1的/ude1法则/gi来/vf削减/v计算机程序/gi的/ude1耦合/vn问题/gi，/w也/d是/vshi轻量级/gi的/ude1spring/gi框架/gi的/ude1核心/n。/w /x控制/vn反转/gm一般/ad分为/v两/nz种/q类型/gi，/w依赖/v注入/gi（/wdependency injection/nz，/w简称/v）/w和/cc依赖/v查找/gi（/wdependency lookup/nz）/w。/w依赖/v注入/gi应用/gi比较/gi广泛/a，/w依赖/v注入/gi之所以/c更/d流行/v是因为/c它/rr是/vshi一种/nz更/d可取/a的/ude1方式/n：/w让/v容器/gi全权负责/l依赖/v查询/gi，/w受管/nz组件/gi只/d需要/v暴露/vjavabean/nz的/ude1setter/nz方法/gi或者/c带/v参数/gi的/ude1构造子/nz或者/c接口/gi，/w使/v容器/gi可以/v在/p初始化/v时/qt组装/vn对象/gi的/ude1依赖/v关系/gi。/w其/rz与/cc依赖/v查找/gi方式/n相比/vi，/w主要/b优势/gi为/p：/w1/nz查找/gi定位/gi操作/gi与/cc应用/gi代码/gi完全/ad无关/v。/w2/nz不/d依赖于/v容器/gi的/ude1api/gi，/w可以/v很容易/nz地/ude2在/p任何/rz容器/gi以外/f使用/gi应用/gi对象/gi。/w3/nz不/d需要/v特殊/a的/ude1接口/gi，/w绝大/nz多数/a对象/gi可以/v做到/v完全/ad不必/d依赖/v容器/gi。/w。/w许多非凡/nz的/ude1应用/gi（/w企业级/nz的/ude1大型软件/l）/w都/d是/vshi由/p两/nz个/q或/c是/vshi更多/ad的/ude1类/gi通过/p彼此/rr的/ude1合作/vn来/vf实现/gi业务逻辑/gi，/w这/rzv使得/vi每个/r对象/gi都/d需要/v，/w与/cc其/rz合作/vn的/ude1对象/gi（/w也/d就是/v它/rr所/usuo依赖/v的/ude1对象/gi）/w的/ude1引用/gi。/w如果/c这个/rz获取/gi过程/gi要/v靠/v自身/rr实现/gi，/w那么/c如/v你/rr所见/c，/w这/rzv将/d导致/gi代码/gi高度/d耦合/vn并且/c难以/d测试/gi。/w应用/gi控制/vn反转/gm，/w对象/gi在/p被/pbei创建/gi的/ude1时候/n，/w由/p一个/mq调控/vn系统/gi内/f所有/b对象/gi的/ude1外界/n实体/n将/d其/rz所/usuo依赖/v的/ude1对象/gi的/ude1引用/gi传递/v给/p它/rr。/w也/d可以/v说/v，/w依赖/v被/pbei注入/gi到/v对象/gi中/f。/w所以/c，/w控制/vn反转/gm是/vshi，/w关于/p一个/mq对象/gi如何/ryv获取/gi他/rr所/usuo依赖/v的/ude1对象/gi的/ude1引用/gi，/w这个/rz责任/n的/ude1反转/gm。/wioc/gi个人/n认为/v是/vshi已经/d是/vshi一种/nz全新/b的/ude1设计模式/nz，/w本来/d我/rr也/d想/v把/pba这/rzv篇文章/n放到/vjava设计模式/gi分类目录/n下/f，/w但是/c想想/v又/d觉得/v不/d合适/a，/w因为/c其/rz理论/gi和/cc时间/gi成熟/a相对/d较晚/d，/w所以/c在/p中/f并/cc没有/v包含/v该/rz设计模式/nz，/w同时/c大家/rr普遍/ad认同/vn的/ude123/nz种/q设计模式/nz中/f（/w如果/c还/d不/d知道/v23/nz种/q设计模式/nz包含/v哪些/ry，/w请/v猛/a戳/v这里-/nz）/w，/w也/d没有/v该/rz设计模式/nz，/w所以/c我/rr就/d干脆/d重新/d开了个/n分类--/nzjava/gi进阶/gi废话/n不/d多/a说/v，/w看/v代码/gi，/w在/p还/d没有/vioc/gi之前/f，/w我们/rr的/ude1代码/gi是/vshi，/w如果/c需要/v在/pa/nz对象/gi里面/f，/w使用/gi到/vb/nz对象/gi的/ude1相关/vn方法/gi，/w就/d需要/vnew/nz出/vf一个/mqb/nz对象/gi来/vf，/w如下/vi所示/nz：/w聪明/a的/ude1人类/gi总是/d一直/d在/p不断/d的/ude1进步/vn，/w工业革命/n来/vf啦/y，/w工厂模式/gi的/ude1出现/v，/w我们/rr就/d把/pba构造/n对象/gi实例/gi的/ude1工作/gi交给/v工厂/gi来/vf处理/vn啦/y：/w表面/n上/f工厂模式/gi是/vshi在/p一定/b程度/n上/f缓解/v了/ule第一个/gi程序/gi的/ude1问题/gi，/w但/c实质上/nz这种/r代码/gi耦合/vn并/cc没有/v改变/v。/w通过/pioc/gi模式/gi可以/v彻底解决/nz这种/r耦合/vn，/w它/rr把/pba耦合/vn从/p代码/gi中/f移出去/v，/w放到/v统一/vn的/ude1xml /nz文件/gi中/f，/w通过/p一个/mq容器/gi在/p需要/v的/ude1时候/n把/pba这个/rz依赖/v关系/gi形成/v，/w即/v把/pba需要/v的/ude1接口/gi实现/gi注入/gi到/v需要/v它/rr的/ude1类/gi中/f，/w这/rzv可能/v就是/v“/w依赖/v注入/gi”/w说法/n的/ude1来源/gi了/ule。/wioc/gi模式/gi，/w系统/gi中/f通过/p引入/v实现/gi了/uleioc/gi模式/gi的/ude1ioc/gi容器/gi，/w即可/v由/pioc/gi容器/gi来/vf管理对象/n的/ude1生命周期/nz、/w依赖/v关系/gi等/udeng，/w从而/c使得/vi应用程序/nz的/ude1配置/gi和/cc依赖性/n规范/gi与/cc实际/n的/ude1应用程序/nz代码/gi分开/vi。/w其中/rz一个/mq特点/n就是/v通过/p文本/gi的/ude1配置文件/gi进行/vn应用程序/nz组件/gi间/f相互关系/l的/ude1配置/gi，/w而/cc不用/d重新/d修改/gi并/cc编译/gi具体/a的/ude1代码/gi，/w下面/f以/p运用/v了/ulespring/gi的/ude1代码/gi为/p例/n：/w对象/gihelloworld/nz：/w对象/gimain/gi：/wbean/nz文件/gi：/w从/p上面/f两/nz个/q程序/gi可以/v看出/v，/wioc/gi模式/gi看做/v是/vshi工厂模式/gi的/ude1升华/vi，/w可以/v把/pbaioc/gi看作/v是/vshi一个/mq大/a工厂/gi，/w只不过/d这个/rz大/a工厂/gi里/f要/v生成/v的/ude1对象/gi都/d是/vshi在/pxml/nz文件/gi中/f给出/v定义/gi的/ude1，/w然后/c利用/vjava /nz的/ude1“反射/nz”/w编程/gi，/w根据/pxml/nz中/f给出/v的/ude1类名/n生成/v相应/vi的/ude1对象/gi。/w从/p实现/gi来看/u，/wioc/gi是/vshi把/pba以前/f在/p工厂方法/gi里/f写死/nz的/ude1对象/gi生成/v代码/gi，/w改变/v为/p由/pxml/nz文件/gi来/vf定义/gi，/w也/d就是/v把/pba工厂/gi和/cc对象/gi生成/v这/rzv两者/rzv独立/a分隔/vi开来/v，/w目的/gi就是/v提高/v灵活性/gi和/cc可维护性/gi。/w