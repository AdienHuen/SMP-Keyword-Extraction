#内联函数/gi：/wstatic inline /nz和/cc extern inline /nz的/ude1区别/gi
inline/nz函数/gi程序执行/n时/qt，/w处理器/gi从/pmemory/gi中/f读取/gi代码执行/n。/w当/p程序/gi中/f调用/gi一个/mq函数/gi时/qt，/w程序/gi跳到/vf存储器/gi中/f保存/gi函数/gi的/ude1位置/gi开始/v读取/gi代码执行/n，/w执行/v完/vi后/f再/d返回/v。/w为了/p提高/v速度/n，/wc/nz定义/gi了/uleinline/nz函数/gi，/w告诉/v编译器/gi把/pba函数/gi代码/gi在/p编译/gi时/qt直接/ad拷/vg到/v程序/gi中/f，/w这样/rzv就/d不用/d执行/v时/qt另外/c读取/gi函数/gi代码/gi。/winline static/nz函数/gistatic/gi函数/gi告诉/v编译器/gi其他/rzv文件/gi看不到/v这个/rz函数/gi，/w因此/c该/rz函数/gi只能/v在/p当前/t文件/gi中/f被/pbei调用/gi。/winline static/nz函数/gi只能/v在/p当前/t文件/gi中/f被/pbei调用/gi，/w同时/c执行/v速度快/nz，/w几/d个/q文件/gi中都/ns可以/v使用/gi同样/d的/ude1函数/gi名/q。/w仔细/ad想想/v：/w1/nz、/w首先/d，/winline/nz函数/gi是/vshi不能/v想/v传统/n的/ude1函数/gi那样/rzv放在/v./nzc/nz中/f然后/c在/p./nzh/nz中/f给出/v接口/gi在/p其余/rz文件/gi中/f调用/gi的/ude1,/nz因为/cinline/nz函数/gi其实/d是/vshi跟/p宏定义/nz类/gi，/w不存在/ns所谓/v的/ude1函数/gi入口/n。/w2/nz、/w因为/c第一点/nz，/w会/v出现/v一个/mq问题/gi，/w就是说/c如果/cinline/nz函数/gi在/p两/nz个/q不同/a的/ude1文件/gi中/f出现/v，/w也/d就是说/c一个/mq./nzh/nz被/pbei两/nz个/q不同/a的/ude1文件/gi包含/v，/w则/d会/v出现/v重名/a，/w链接/gi失败/vi所以/cstatic inline /nz的/ude1用法/gi就/d能/v很好/ad的/ude1解决/v这个/rz问题/gi，/w使用/gistatic/gi修饰/v符/v，/w函数/gi仅/d在/p文件/gi内部/f可见/c，/w不会/v污染/vn命名/v空间/n。/w可以/v理解/gi为/p一个/mqinline/nz在/p不同/a的/ude1./nzc/nz里面/f生成/v了/ule不同/a的/ude1实例/gi，/w而且/c名字/n是/vshi完全相同/nz的/ude1。/w    /x内联函数/gi有些/rz类/gi于/p宏/nz。/w内联函数/gi的/ude1代码/gi会/v被/pbei直接/ad嵌入/v在/p它/rr被/pbei调用/gi的/ude1地方/n，/w调用/gi几次/nz就/d嵌入几次/nz，/w没有/v使用/gicall/nz指令/gi。/w这样/rzv省去/v了/ule函数调用/gi时/qt的/ude1一/nz些/q额外/b开销/n，/w比如/v保存/gi和/cc恢复/gi函数/gi返回/v地址/gi等/udeng，/w可以/v加快速度/n。/w不过/c调用/gi次数/gi多/a的话/udh，/w会/v使/v可执行文件/gi变大/v，/w这样/rzv会/v降低/v速度/n。/w相比/vi起宏/nz来说/uls，/w内核/gi开发者/gi一般/ad更喜欢/nz使用/gi内联函数/gi。/w因为/c内联函数/gi没有/v长度/gi限制/vn，/w式/k限制/vn。/w编译器/gi还/d可以/v检查/gi函数调用/gi方式/n，/w以/p防止/gi其/rz被/pbei误用/v。/w    static inline/nz的/ude1内联函数/gi，/w一般/ad情况下/nz不会/v产生/v函数/gi本身/rz的/ude1代码/gi，/w而是/c全部/m被/pbei嵌入/v在/p被/pbei调用/gi的/ude1地方/n。/w如果/c不加/vstatic/gi，/w则/d表示/v该/rz函数/gi有可能会/nz被/pbei其他/rzv编译/gi单元/n所/usuo调用/gi，/w所以/c一定会/nz产生/v函数/gi本身/rz的/ude1代码/gi。/w所以/c加/v了/ulestatic/gi，/w一般/ad可/v令/v可执行文件/gi变小/d。/w内核/gi里/f一般/ad见/v不到/v只用/vinline/nz的/ude1情况/n，/w而/cc都/d是/vshi使用/gistatic inline/nz。/wextern inline/nz表示/v该/rz函数/gi是/vshi已/d声明/gi过/uguo的/ude1了/ule./nz由于/p函数/gi本身/rz可以/v声明/gi多/a次/qv,/nz所以/cextern/gi对/p函数/gi的/ude1影响/gi仅仅/d把/pba函数/gi的/ude1隐藏/v属性/gi显式/nz化/v了/ule./nzextern /nz对于/p非函数/nz的/ude1对象/gi是/vshi有/vyou用/p的/ude1,/nz因为/c对象/gi声明/gi时会/n带来/v内存/gi的/ude1分配/gi,/nz而/cc用/p extern/nz就/d表示/v该/rz对象/gi已经/d声明/gi过/uguo了/ule,/nz不用/d再/d分配内存/n./nzstatic/gi是/vshi以前/fc/nz的/ude1用法/gi./nz目的/gi是/vshi让/v该/rz关键字/gi标识/n的/ude1函数/gi只/d在/p本地/gi文件/gi可见/c,/nz同一个/b程序/gi的/ude1其它/rz文件/gi是/vshi不/d可见/c该/rz函数/gi的/ude1./nz换句话说/c,/nz就算/d你/rr其它/rz文件/gi里/f包含/v了/ule同名/vn同参数/n表/n的/ude1函数/gi定义/gi的话/udh,/nz也/d是/vshi不会/v引起/v函数/gi重复/gi定义/gi的/ude1错误/gi的/ude1./nz因为/cstatic/gi是/vshi仅/d在/p当前/t文件/gi可见/c./nz