#MongoDB Data Models /nz数据结构/gi设计/gi
1/nz /x数据/gi建模/gi介绍/gimongodb/gi的/ude1数据结构/gi很/d灵活/a,/nz不/d强制/vd要求/n数据结构/gi./nz但是/c通常/d一个/mq集合/gi内部/f使用/gi相同/a的/ude1结构/gi./nz数据/gi建模/gi的/ude1关键/n是/vshi平衡/a应用/gi的/ude1需求/gi和/cc数据库/gi执行/v和/cc数据检索/nz模型/gi的/ude1性能/gi./nz设计/gi数据模型/gg时/qt,/nz要/v考虑/v数据/gi的/ude1使用/gi情况/n和/cc数据/gi自身/rr的/ude1结构/gi1.1/nz /x文档/gi结构设计/nzmongodb/gi应用/gi的/ude1数据模型/gg的/ude1关键在于/n文档/gi结构/gi和/cc应用程序/nz如何/ryv表示/v数据/gi之间/f的/ude1关系/gi,/nz这/rzv有/vyou两/nz种/q工具/gi允许/v应用程序/nz来/vf表示/v这些/rz关系/gi:/w引用/gi和/cc嵌入/v型/k文档/gi./nz1.1.1/nz /x引用/gi:/w类/gi关系型数据库/gi中的/v外键/gi的/ude1引用/gi,/nz通常/d不同/a的/ude1集合/gi中/f互相/d引用/gi_/nzid/nz字段/gi1.1.2/nz /x内嵌/v数据/gi:/w某个/rz字段/gi的/ude1为/pbson/nz或者/c某个/rz字段/gi为数/n组/n,/nz数组/gi中的/v每个/r为/pbson/nz1.2/nz写/v操作/gi的/ude1原子性/nzmongodb/gi在/p文档/gi级别/n的/ude1写/v操作/gi是/vshi原子性/nz的/ude1,/nz没有/v任何/rz单个/b修改/gi多/a条文/n档/ng,/nz或者/c多/a个/q集合/gi的/ude1操作/gi是/vshi原子性/nz的/ude1./nz包含/v嵌入/v型/k数据/gi的/ude1非/b标准化/vn数据/gi将/d其/rz所/usuo表示/v的/ude1实体/n的/ude1所有/b的/ude1相关/vn数据/gi在/p单个/b文档/gi中/f保存/gi,/nz这/rzv使得/vi对/p这个/rz实体/n的/ude1操作/gi变为/v对/p这个/rz文档/gi的/ude1原子性/nz操作/gi./nz标准化/vn数据/gi的/ude1过程/gi将/d数据/gi跨/v多/a个/q集合/gi存储/gi,/nz这/rzv使得/vi每次/r对/p实体/n的/ude1修改/gi需要/v多/a次/qv写/v操作/gi,/nz并且/c多/a次/qv写/v操作/gi不是/c原子性/nz的/ude1./nz然而/c,/nz方便/a原子/gi操作/gi的/ude1结构/gi也许/d会/v限制/vn应用程序/nz使用/gi数据/gi或者/c限制/vn修改/gi应用程序/nz./nz1.3/nz文档/gi增长/gi一/nz些/q更新/gi操作/gi,/nz比如/v向/p数组/gi中/f追加/v元素/gi或者/c向/p文档/gi中/f添加/gi字段/gi,/nz都会/n导致/gi文档/gi大小/n增加/v./nz如果/c文档/gi大小/n超过/v了/ule分配/gi给/p它/rr的/ude1空间/n,/nzmongodb/gi将/d重新/d在/p硬盘/gi上/f为/p其/rz分配/gi空间/n./nz这种/r增长/gi将/d影响/gi你/rr选择/gi使用/gi标准化/vn数据/gi还是/c非标准化/nz数据/gi1.4/nz数据/gi的/ude1使用/gi和/cc性能/gi当/p设计/gi数据模型/gg的/ude1时候/n,/nz考虑/v应用程序/nz将/d怎样/ryv使用/gi你/rr的/ude1数据库/gi./nz比如说/vl:/w如果/c你/rr的/ude1应用程序/nz只是/d使用/gi最近/t插入/gi的/ude1文档/gi,/nz考虑/v使用/gicapped collections/nz,/nz或者/c你/rr的/ude1应用程序/nz主要/b是/vshi读取/gi操作/gi,/nz为/p常用/a的/ude1查询/gi添加索/nz引来/v改善/v性能/gi./nz2/nz数据/gi建模/gi概念/gi2.1/nz数据模型/gg设计/gi高效/b的/ude1数据模型/gg迎合/v应用程序/nz的/ude1需求/gi./nz文档/gi结构/gi考虑/v的/ude1关键因素/nz是/vshi使用/gi嵌入/v型/k文档/gi还是/c使用/gi引用/gi2.1.1/nz嵌入/v型/k数据模型/gg嵌入/v型/k文档/gi允许/v一个/mq文档/gi中/f保存/gi多/a条/q相关/vn信息/gi应用程序/nz可以/v执行/v更少/d的/ude1查询/gi和/cc更新/gi操作/gi./nz以下/f情况/n使用/gi嵌入/v型/k文档/gi:/w1./nz实体/n间/f有/vyou包含/v的/ude1关系/gi2./nz实体/n间/f有/vyou一/nz对/p多/a的/ude1关系/gi./nz在/p这种/r关系/gi中/f,/nz多/a的/ude1一方/nz总是/d在/p一/nz的/ude1一方/nz作为/p上下文/gi或者/c作为/p父/ng文档/gi的/ude1时候/n出现/v./nz嵌入/v型/k文档/gi读/v操作/gi性能/gi较好/d,/nz单一/gi数据库/gi的/ude1时候/n检索/gi数据/gi快/a./nzupdate/gi相关/vn数据/gi的/ude1操作/gi是/vshi原子性/nz的/ude1./nz缺点/gi:/w嵌入/v型/k文档/gi导致/gi文档/gi创建/gi后/f大小/n的/ude1增长/gi./nz进一步/d说/v,/nz文档/gi必须/d小于/vbson/nz文档/gi的/ude1最大/gm限制/vn与/cc嵌入/v型/k文档/gi进行/vn交互/gi,/nz需要/v使用/gi./nz操作/gi符来/nz访问/gi嵌入/v型/k文档/gi2.1.2/nz标准化/vn数据模型/gg标准化/vn数据/gi使用/gi引用/gi来/vf描述/gi文档/gi间/f的/ude1关系/gi以下/f情况/n使用/gi标准化/vn数据模型/gg:/w1./nz嵌入/v型/k文档/gi模型/gi导致/gi数据/gi重复/gi的/ude1同时/c,/nz查询/gi性能/gi优势/gi不能/v弥补/v数据/gi重复/gi带来/v的/ude1不足/an的/ude1时候/n2./nz用以/d表示/v更加/d复杂/a的/ude1多/a对/p多/a的/ude1关系/gi3./nz用以/d建模/gi多/a层/gi的/ude1数据/gi集/q引用/gi比/p嵌入/v更加/d灵活/a./nz然而/c随之而来/vl的/ude1是/vshi应用程序/nz需要/v查询/gi并/cc解析/gi相关/vn的/ude1引用/gi./nz换句话说/c,/nz标准化/vn数据模型/gg会/v导致/gi程序/gi和/ccmongodb/gi之间/f更多/ad的/ude1通信/gi./nz2.2/nz操作/gi的/ude1因素/gi和/cc数据模型/gg需要/v权衡/v考虑/v数据/gi自身/rr和/cc数据库/gi./nz2.2.1/nz /x文档/gi增长/gi数组/gi的/ude1push/nz操作/gi,/nz和/cc增加/v新的/a /x字段/gi将/d会/v导致/gi文档/gi大小/n的/ude1增长/gi./nz超过/v文档/gi已/d分配/gi的/ude1空间/n大小/n的/ude1时候/n,/nzmongodb/gi将/d会/v为/p其/rz重新分配/l空间/n,/nz这/rzv将/d导致/gi比/p原地/n更新/gi花费/v更多/ad的/ude1时间/gi,/nz同时/c也/d会/v导致/gi碎片化/nz存储/gi./nz虽然/cmongodb/gi自动/d会/v在/p文档/gi之间/f添加/gi空隙/n以/p减少/v类/gi的/ude1重新分配/l,/nz建立/gi模型/gi的/ude1时候/n需要/v尽可能/d的/ude1避免/v文档/gi增长/gi2.2.2/nz /x原子/gi操作/gi上面/f已有/v介绍/gi,/nz略/d2.2.3/nz shardingmongodb/nz使用/gisharding/nz技术/gi来/vf提供/v水平/n的/ude1缩放/gi./nz这些/rz集群/gi支持/v大/a数据集/nz的/ude1开发/gi和/cc高/a吞吐量/gi的/ude1操作/gi./nzsharding/nz允许/v用户/gi将/d一个/mq数据库/gi内/f的/ude1一个/mq集合/gi,/nz通过/pmongod/nz的/ude1实例/gi或者/cshards/nz的/ude1标号/n,/nz分散/a到/v多/a个/q集合/gi文档/gi中/f2.2.4/nz /x索引/gi使用/gi索引/gi来/vf改善/v查询/gi性能/gi./nz在/p某些/rz字段/gi上/f建立/gi索引/gi,/nz通常/d是/vshi在/p这些/rz字段/gi上/f的/ude1查询/gi返回/v排序/gi的/ude1结果/n的/ude1时候/n./nzmongodb/gi自动/d在/p_/nzid/nz字段/gi上/f建立/gi索引/gi./nz建立/gi索引/gi时/qt要/v考虑/v以下内容/nz:/w1./nz每个/r索引/gi需要/v至少/d8/nzkb/nz的/ude1空间/n2./nz建立/gi索引/gi会/v对/p写/v操作/gi有/vyou负面影响/nz,/nz对于/p写/v操作/gi很/d多/a的/ude1集合/gi来说/uls,/nz索引/gi的/ude1所/usuo花费/v的/ude1代价/gi很高/d因为/c每次/r插入/gi的/ude1操作/gi都/d必须/d更新/gi所有/b的/ude1索引/gi3./nz对于/p读/v操作/gi较多/d的/ude1集合/gi来说/uls,/nz索引/gi通常/d是/vshi有益/a的/ude1./nz索引/gi不/d影响/gi没有/v建立/gi索引/gi的/ude1读/v操作/gi./nz4./nz当/p激活/gi的/ude1时候/n,/nz每个/r索引/gi都会/n消耗/gi硬盘/gi和/cc内存空间/nz./nz这些/rz开销/n对于/p容量/gi计划/gi,/nz特别/d是/vshi超过/v工作/gi集/q的/ude1大小/n的/ude1考虑/v,/nz是/vshi极为/d关键/n的/ude1,/nz应该/v追踪/gi的/ude1./nz2.2.5/nz /x大量/m的/ude1集合/gi在/p某些/rz情况下/nz,/nz需要/v选择/gi将/d相关/vn的/ude1信息/gi存储/gi字/n多/a个/q集合/gi中/f而/cc不是/c一个/mq集合/gi中/f,/nz比如/v不同/a的/ude1log/gi内容/gi存储/gi在/p不同/a的/ude1log/gi集合/gi中/f通常/d大量/m的/ude1集合/gi没有/v性能/gi的/ude1减弱/v而是/c性能/gi的/ude1优化/gi./nz不同/a的/ude1集合/gi对于/p高/a吞吐量/gi的/ude1批处理/gi进程/gi是/vshi非常/d重要/a的/ude1./nz当/p使用/gi有/vyou大量/m集合/gi的/ude1数据模型/gg的/ude1时候/n,/nz考虑/v以下内容/nz:/w1./nz每个/r集合/gi至少/d需要/v即/vk/nz空间/n2./nz每个/r索引/gi,/nz包括/v_/nzid/nz上/f的/ude1索引/gi,/nz需要/v至少/d8/nzkb/nz空间/n3./nz对于/p数据库/gi来说/uls,/nz一个/mq,/nz命名/v空间/n文件/gi存储/gi着/uzhe该/rz数据库/gi所有/b的/ude1元数据/gi,/nz每个/r索引/gi和/cc集合/gi在/p这个/rz命名/v空间/n文件/gi中/f有/vyou其/rz自己/rr的/ude1入口/n./nz4./nzmongodb/gi对于/p命名/v空间/n的/ude1数量/n有/vyou限制/vn./nz你/rr也许/d想/v知道/v当前/t的/ude1命名/v空间/n数/n,/nz以/p决定/v数据库/gi还/d可以/v支持/v多少/ry额外/b的/ude1 /x命名/v空间/n,/nz查询/gi当前/t命名/v空间/n的/ude1数量/n,/nz在/pmongo/gi的/ude1shell/gi中/f运行/gi:/wdb/nz./nzsystem/nz./nznamespaces/nz./nzcount/nz(/nz)/nz2.2.6/nz /x数据生命周期/gi管理/gi数据/gi建模/gi的/ude1时候/n应该/v考虑/v数据/gi的/ude1生命周期管理/gi./nz如果/c你/rr的/ude1应用程序/nz需要/v使用/gi限定/v时间段/gi内/f的/ude1数据/gi,/nz考虑/v使用/gittl/nz属性/gi./nz另外/c,/nz如果/c你/rr的/ude1应用程序/nz仅仅/d使用/gi最近/t插入/gi的/ude1文档/gi,/nz考虑/v使用/gicapped collections/nz./nz它/rr提供/v了/ule对于/p文档/gi的/ude1fifo/gi(/nz也/d就是/v队列式/nz)/nz的/ude1管理/gi,/nz有效/gi的/ude1支持/v哪些/ry依赖于/v插入/gi顺序/gi的/ude1插入/gi和/cc读取/gi操作/gi./nz2.3/nzgridfsgridfs/nz是/vshi对于/p超过/vbson/nz文档/gi大小/n限制/vn16/nzm/nz的/ude1文档/gi存储/gi和/cc检索/gi的/ude1规范/gi./nz不是/c将/d文件/gi存储/gi在/p单个/b文档/gi中/f,/nzgridfs/nz将/d文件/gi分割/gi为/p多/a个/q部分/n,/nz或者/c数据库/gi,/nz将/d每个/r数据/gi块/q作为/p单独/d的/ude1文档/gi进行/vn存储/gi./nz默认/v的/ude1gridfs/nz限制/vn数据/gi块/q大小/n为/p255/nzk/nz./nzgridfs/nz使用/gi两/nz个/q集合/gi来/vf存储/gi文件/gi./nz一个/mq结合/v存储/gi文件/gi的/ude1数据/gi块/q,/nz另一个/nz存储/gi文件/gi的/ude1元数据/gi信息/gi./nz当/p你/rr查询/gigridfs/nz存储/gi的/ude1文件/gi的/ude1时候/n,/nz驱动/gi,/nz或者/c客户端/gi将/d重新/d组装/vn你/rr需要/v的/ude1数据/gi块/q./nz你/rr可以/v对/p存储/gi在/pgridfs/nz中的/v文件/gi执行/v多/a种/q查询/gi./nz你/rr也/d可以/v获取/gi文件/gi的/ude1某/rz一块/s的/ude1信息/gi,/nz这/rzv使得/vi你/rr可以/v跳到/vf视频/gi或者/c音频/gi的/ude1中间/f部分/n./nzgridfs/nz不仅仅/d对于/p存储/gi大小/n超过/v16/nzm/nz的/ude1文件/gi有/vyou用/p,/nz它/rr可以/v用于/v存储/gi任何/rz你/rr在/p访问/gi时/qt不想/v将/d整个/b文件/gi加载/gi到/v内存/gi中的/v文件/gi