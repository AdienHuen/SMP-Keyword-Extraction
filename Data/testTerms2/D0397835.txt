#关于/phashcode/gi(/nz)/nz的/ude1作用/gi
原文/n的/ude1地址/gi：/w另一个/nz关于/phashcode/gi(/nz)/nz的/ude1博客地址/nz：/w有/vyou许多人/nz学/v了/ule很长/d时间/gi的/ude1java/gi，/w但/c一直/d不/d明白/vhashcode/gi方法/gi的/ude1作用/gi，/w我/rr来/vf解释一下/i吧/y。/w首先/d，/w想要/v明白/vhashcode/gi的/ude1作用/gi，/w你/rr必须/d要/v先/d知道/vjava/gi中的/v集合/gi。/w　　/nz总的/b来说/uls，/wjava/gi中的/v集合/gi（/wcollection/nz）/w有/vyou两/nz类/gi，/w一类/b是/vshilist/gi，/w再/d有/vyou一类/b是/vshiset/nz。/w你/rr知道/v它们/rr的/ude1区别/gi吗/y？/w前者/rzv集合/gi内/f的/ude1元素/gi是/vshi有序/gi的/ude1，/w元素/gi可以/v重复/gi；/w后者/rzv元素/gi无序/b，/w但/c元素/gi不可/v重复/gi。/w那么/c这里/rzs就/d有/vyou一个/mq比较严重/n的/ude1问题/gi了/ule：/w要/v想/v保证/v元素/gi不/d重复/gi，/w可/v两/nz个/q元素/gi是否/v重复/gi应该/v依据/n什么/ry来/vf判断/gi呢/y？/w这/rzv就是/vobject/nz./nzequals/nz方法/gi了/ule。/w但是/c，/w如果/c每/rz增加/v一个/mq元素/gi就/d检查/gi一次/nz，/w那么/c当/p元素/gi很/d多/a时/qt，/w后/f添加/gi到/v集合/gi中的/v元素/gi比较/gi的/ude1次数/gi就/d非常/d多/a了/ule。/w也/d就是说/c，/w如果/c集合/gi中/f现在/t已经/d有/vyou1000/nz个/q元素/gi，/w那么第/nz1001/nz个/q元素/gi加入/v集合/gi时/qt，/w它/rr就要/d调用/gi1000/nz次/qvequals/nz方法/gi。/w这/rzv显然/ad会/v大大降低/n效率/gi。/w于是/cc，/wjava/gi采用/v了/ule哈希表/nz的/ude1原理/gi。/w哈希/nrf（/whash/gi）/w实际上/d是/vshi个人/n名/q，/w由于/p他/rr提出/v一哈希/nz算法/gi的/ude1概念/gi，/w所以/c就/d以/p他/rr的/ude1名字/n命名/v了/ule。/w哈希算法/gi也/d称为/v散列/nz算法/gi，/w是/vshi将/d数据/gi依/v特定/b算法/gi直接/ad指定/v到/v一个/mq地址/gi上/f。/w如果/c详细/gi讲解/gi哈希算法/gi，/w那/rzv需要/v更多/ad的/ude1文章/gi篇幅/n，/w我/rr在/p这里/rzs就/d不/d介绍/gi了/ule。/w初学者/gi可以/v这样/rzv理解/gi，/whashcode/gi方法/gi实际上/d返回/v的/ude1就是/v对象/gi存储/gi的/ude1物理地址/gi（/w实际/n可能/v并/cc不是/c）/w。/w这样一来/dl，/w当/p集合/gi要/v添加/gi新的/a元素/gi时/qt，/w先/d调用/gi这个/rz元素/gi的/ude1hashcode/gi方法/gi，/w就/d一/nz下子/n能/v定位/gi到/v它/rr应该/v放置/gi的/ude1物理位置/nz上/f。/w如果/c这个/rz位置/gi上/f没有/v元素/gi，/w它/rr就/d可以/v直接/ad存储/gi在/p这个/rz位置/gi上/f，/w不用/d再/d进行/vn任何/rz比较/gi了/ule；/w如果/c这个/rz位置/gi上/f已经/d有/vyou元素/gi了/ule，/w就/d调用/gi它/rr的/ude1equals/nz方法/gi与/cc新元素/nz进行/vn比较/gi，/w相同/a的话/udh就/d不存/v了/ule，/w不/d相同/a就/d散列/nz其它/rz的/ude1地址/gi。/w所以/c这里/rzs存在/v一个/mq冲突/gi解决/v的/ude1问题/gi。/w这样一来/dl实际/n调用/giequals/nz方法/gi的/ude1次数/gi就/d大大降低/n了/ule，/w几乎/d只/d需要/v一/nz两/nz次/qv。/w所以/c，/wjava/gi对于/peqauls/nz方法/gi和/cchashcode/gi方法/gi是/vshi这样/rzv规定/n的/ude1：/w1/nz、/w如果/c两/nz个/q对象/gi相同/a，/w那么/c它们/rr的/ude1hashcode/gi一定/b要/v相同/a；/w2/nz、/w如果/c两/nz个/q对象/gi的/ude1hashcode/gi相同/a，/w它们/rr并不一定/d相同/a /x上面/f说/v的/ude1对象/gi相同/a指/v的/ude1是/vshi用/peqauls/nz方法/gi比较/gi。/w你/rr当然/d可以/v不/d按/p要求/n去/vf做/v了/ule，/w但/c你/rr会/v发现/v，/w相同/a的/ude1对象/gi可以/v出现/v在/pset/nz集合/gi中/f。/w同时/c，/w增加/v新元素/nz的/ude1效率/gi会/v大大/d下降/vi。/w