#Java/gi设计模式/nz―/w―/w工厂模式/gi
编程/gi是/vshi一/nz门/n技术/gi，/w更是/d一门/nz艺术/n简单工厂模式/gi简介/gi简单工厂模式/gi在于/v工厂/gi类/gi中/f包含/v了/ule必要/a逻辑/n判断/gi，/w根据/p客户端/gi的/ude1选择/gi动态/gi实例化/gi相关/vn的/ude1类/gi，/w对于/p客户端/gi来说/uls去除/v了/ule与/cc具体/a产品/gi相关/vn的/ude1依赖/v。/w实现/gi一个/mq计算器/gi使用/gi简单工厂模式/gi下/f，/w需要/v在/p工厂/gi类/gi中/f进行/vn逻辑/n的/ude1判断/gi，/w是/vshi加法/gi返回/vadd/nz实例/gi，/w减法/n返回/vsub/nz实例/gi。/w但是/c这时候/rzt我/rr添加/gi新的/a计算/gi的/ude1时候/n，/w首先/d创建/gi一个/mq对应/vi类/gi继承/gi运算/gi父/ng接口/gi，/w然后/c需要/v修改/gi工厂/gi类/gi中的/v逻辑/n。/w这时/rzt简单工厂模式/gi的/ude1应用/gi。/w工厂模式/gi简单工厂模式/gi的/ude1问题/gi在于/v，/w如果/c我/rr添加/gi新的/a功能/gi需要/v修改/gi工厂/gi类/gi，/w这样/rzv不仅/c对/p扩展/gi开放/gi了/ule而且/c对/p修改/gi开放/gi了/ule，/w这样/rzv就/d违背/v了/ule开放-封闭/nz原则/gi了/ule。/w而/cc工厂模式/gi就是/v定义/gi一个/mq接口/gi，/w让子/nz类/gi决定/v实例化/gi哪/ry一个/mq类/gi。/w工厂方法/gi将/d使/v一个/mq类/gi的/ude1实例化/gi延迟/v到/v子类/gm。/w这样/rzv整个/b工厂/gi和/cc产品/gi就/d只有/c扩展/gi变化/gi，/w没有/v修改/gi变化/gi了/ule，/w符合/v了/ule开放-封闭/nz原则/gi。/w工厂模式/gi就是/v克服/v了/ule简单工厂模式/gi的/ude1开放-封闭/nz原则/gi的/ude1缺点/gi，/w保留/v了/ule封装/gi对象创建/gi过程/gi的/ude1优点/gi。/w明天/t在/p继续/v抽象工厂模式/gi的/ude1干活/vi吧/y！/w！/w！/w