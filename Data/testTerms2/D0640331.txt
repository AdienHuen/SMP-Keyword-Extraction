#Moq /nz单元测试/gi的/ude1意义/n
 /x单元测试/gi是/vshi开发人员/n对/p代码/gi逻辑/n进行/vn的/ude1测试/gi，/w需要/v写/v单元测试/gi代码/gi来/vf实现/gi。/w单元测试/gi里面/f是/vshi调用函数/n，/w根据/p返回/v的/ude1结果/n去/vf判断/gi代码/gi逻辑/n是否/v正确/a。/w通常/d的/ude1操作/gi是/vshicrud/nz，/w除了/p查询/gi之外/f的/ude1操作/gi都/d是/vshi要/v与/cc数据库/gi打交道/vi的/ude1。/w比如/v删除/gi记录/gi的/ude1函数/gi在/p单元测试/gi中/f被/pbei调用/gi，/w记录/gi就/d会/v被/pbei删掉/v，/w而/cc此时/r开发人员/n很/d有可能/nz需要/v这/rzv条/q记录/gi来/vf测试/gi自己/rr开发/gi的/ude1功能/gi是否/v正确/a，/w这样/rzv开发/gi和/cc测试/gi就/d发生/v了/ule冲突/gi。/w /x单元测试/gi时/qt可以/v使用/gimstest/nz，/w通过/ppowershell/nz的/ude1脚本/gi调用/gi来/vf跑/v的/ude1，/w很/d多/a团队/gi使用/gi自动/d化脚/nz本来/d跑/v测试/gi收集/v结果/n。/w数据库/gi里/f的/ude1数据/gi时刻/n都/d在/p变化/gi，/w对于/p开发/gi是/vshi很/d不利/a的/ude1，/w有/vyou没有/v一种/nz机制/gi能够/v把/pba开发/gi和/cc测试/gi分开/vi呢/y，/w让/v做/v单元测试/gi的/ude1时候/n不/d影响/gi数据库/gi。/w moq/nz就是/v这样/rzv一种/nz机制/gi。/wmoq/nz需要/v一个/mq虚拟化/gi对象/gi，/w所以/c，/w被/pbei测试/gi的/ude1实例/gi需要/v继承/gi一个/mq接口/gi或者/c抽象类/gi。/w接口/gi（/wisqlhelper/nz）/w：/w类/gi（/wsqlhelper/nz）/w单元测试/gi：/w测试/gi结果/n：/w这时候/rzt我们/rr发现/v数据库/gi中/f并/cc没有/v真正/d插入/gi数据/gi，/w但是/c单元测试/gi已经/d通过/p了/ule。/w