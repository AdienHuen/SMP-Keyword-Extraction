#C++/gi虚表/gi函数/gi解析/gi
本文/r转载/v：/w《/wc++/gi /x虚函数表/gi解析/gi》/w陈皓/nz /x前言/gic++/gi中的/v虚函数/nz的/ude1作用/gi主要/b是/vshi实现/gi了/ule多态/gi的/ude1机制/gi。/w关于/p多态/gi，/w简而言之/vl就是/v用/p父/ng类型/gi别的/rzv指针/gi指向/v其子/r类/gi的/ude1实例/gi，/w然后/c通过/p父类/nz的/ude1指针/gi调用/gi实际/n子类/gm的/ude1成员/nnt函数/gi。/w这种/r技术/gi可以/v让/v父类/nz的/ude1指针/gi有/vyou“/w多/a种/q形态/n”/w，/w这/rzv是/vshi一种/nz泛型/gi技术/gi。/w所谓/v泛型/gi技术/gi，/w说白了/l就是/v试图/v使用/gi不变/nz的/ude1代码/gi来/vf实现/gi可变/vn的/ude1算法/gi。/w比如/v：/w模板/gi技术/gi，/wrtti/nz技术/gi，/w虚函数/nz技术/gi，/w要么/c是/vshi试图/v做到/v在/p编译/gi时/qt决议/n，/w要么/c试图/v做到/v运行/gi时/qt决议/n。/w关于/p虚函数/nz的/ude1使用/gi方法/gi，/w我/rr在/p这里/rzs不/d做/v过多/d的/ude1阐述/v。/w大家/rr可以/v看看/v相关/vn的/ude1c++/gi的/ude1书籍/gi。/w在/p这/rzv篇文章/n中/f，/w我/rr只想/v从/p虚函数/nz的/ude1实现/gi机制/gi上面/f为/p大家/rr /x一个/mq清晰/a的/ude1剖析/gi。/w当然/d，/w相同/a的/ude1文章/gi在/p网上/s也/d出现/v过/uguo一/nz些/q了/ule，/w但/c我/rr总/b感觉/gi这些/rz文章/gi不是/c很容易/nz阅读/gi，/w大段/n大段/n的/ude1代码/gi，/w没有/v图片/gi，/w没有/v详细/gi的/ude1说明/v，/w没有/v比较/gi，/w没有/v举一反三/vl。/w不利于/v学习/gi和/cc阅读/gi，/w所以/c这/rzv是/vshi我/rr想/v写下/v这/rzv篇文章/n的/ude1原因/n。/w也/d希望/v大家/rr多/a给/p我/rr提意见/nz。/w言归正传/vl，/w让/v我们/rr一起/s进入/v虚函数/nz的/ude1世界/gi。/w虚函数表/gi对/pc++/gi /x了解/v的/ude1人/n都/d应该/v知道/v虚函数/nz（/wvirtual function/nz）/w是/vshi通过/p一/nz张虚函数/nz表/n（/wvirtual table/nz）/w来/vf实现/gi的/ude1。/w简称/v为/pv/nz-/nztable/nz。/w在/p这个/rz表/n中/f，/w主/ag是/vshi要/v一个/mq类/gi的/ude1虚函数/nz的/ude1地址/gi表/n，/w这/rzv张/q表/n解决/v了/ule继承/gi、/w覆盖/gi的/ude1问题/gi，/w保证/v其/rz容/v真实/a反应/vn实际/n的/ude1函数/gi。/w这样/rzv，/w在/p有/vyou虚函数/nz的/ude1类/gi的/ude1实例/gi中/f这个/rz表/n被/pbei分配/gi在/p了/ule这个/rz实例/gi的/ude1内存/gi中/f，/w所以/c，/w当/p我们/rr用/p父类/nz的/ude1指针/gi来/vf操作/gi一个子/nz类/gi的/ude1时候/n，/w这/rzv张/q虚函数表/gi就/d显得/v由/p为/p重要/a了/ule，/w它/rr就/d像/v一个/mq地图/n一样/uyy，/w指明/v了/ule实际/n所/usuo应该/v调用/gi的/ude1函数/gi。/w这里/rzs我们/rr着重/vd看/v一/nz下/f这/rzv张/q虚函数表/gi。/wc++/gi的/ude1编译器/gi应该/v是/vshi保证/v虚函数表/gi的/ude1指针/gi存在/v于/p对象/gi实例/gi中/f最/d前面/f的/ude1位置/gi（/w这/rzv是/vshi为了/p保证/v取到/v虚函数表/gi的/ude1有/vyou最高/a的/ude1性能/gi―/w―/w如果/c有/vyou多/a层/gi继承/gi或/c是/vshi多重/b继承/gi的/ude1情况下/nz）/w。/w /x这/rzv意味着/v我们/rr通过/p对象/gi实例/gi的/ude1地址/gi得到/v这/rzv张/q虚函数表/gi，/w然后/c就/d可以/v遍历/gi其中/rz函数指针/nz，/w并/cc调用/gi相应/vi的/ude1函数/gi。/w听/v我/rr扯/v了/ule那么/c多/a，/w我/rr可以/v感觉/gi出来/vf你/rr现在/t可能/v比/p以前/f更加/d晕头转向/al了/ule。/w /x没关系/vl，/w下面/f就是/v实际/n的/ude1例子/gi，/w相信/v聪明/a的/ude1你/rr一/nz看/v就/d明白/v了/ule。/w假设/gi我们/rr有/vyou这样/rzv的/ude1一个/mq类/gi：/w按照/p上面/f的/ude1说法/n，/w我们/rr可以/v通过/pbase/nz的/ude1实例/gi来/vf得到/v虚函数表/gi。/w /x下面/f是/vshi实际/n例程/gi：/w实际/n运行/gi经果/nz如下/vi：/w(/nzwindows xp/nz+/nzvs/nz2003/nz,/nz  linux /nz2.6.22/nz /x+/nz gcc /nz4.1.3/nz)/nz通过/p这个/rz示例/gi，/w我们/rr可以/v看到/v，/w我们/rr可以/v通过/p强行/d把/pbab/nz转成/vint /nz，/w取得/v虚函数表/gi的/ude1地址/gi，/w然后/c，/w再次/d取址/nz就/d可以/v得到/v第一个/gi虚函数/nz的/ude1地址/gi了/ule，/w也/d就是/vbase/nz:/w:/wf/nz(/nz)/nz，/w这/rzv在/p上面/f的/ude1程序/gi中/f得到/v了/ule验证/v（/w把/pbaint /nz强制/vd转成/v了/ule函数指针/nz）/w。/w通过/p这个/rz示例/gi，/w我们/rr就/d可以/v知道/v如果/c要/v调用/gibase/nz:/w:/wg/nz(/nz)/nz和/ccbase/nz:/w:/wh/nz(/nz)/nz，/w其/rz代码/gi如下/vi：/w这个/rz时候/n你/rr应该/v懂/v了/ule吧/y。/w什么/ry？/w还是/c有点/d晕/vi。/w也/d是/vshi，/w这样/rzv的/ude1代码/gi看着/v太/d乱/d了/ule。/w没问题/nz，/w让/v我/rr画/v个/q图/gi解释一下/i。/w如下/vi所示/nz：/w /x注意/v：/w在/p上面/f这个/rz图/gi中/f，/w我/rr在/p虚函数表/gi的/ude1最后/f多/a加/v了/ule一个/mq结点/gm，/w这/rzv是/vshi虚函数表/gi的/ude1结束/v结点/gm，/w就/d像/v字符串/gi的/ude1结束/v符“/nz//nz0/nz”/w一样/uyy，/w其/rz标志/n了/ule虚函数表/gi的/ude1结束/v。/w这个/rz结束/v标志/n的/ude1值/n在/p不同/a的/ude1编译器/gi下/f是/vshi不同/a的/ude1。/w在/pwinxp/nz+/nzvs/nz2003/nz下/f，/w这个/rz值/n是/vshinull/gi。/w而/cc在/pubuntu /nz7.10/nz /x+/nz linux /nz2.6.22/nz /x+/nz gcc /nz4.1.3/nz下/f，/w这个/rz值/n是/vshi如果/c1/nz，/w表示/v还有/v下一个/nz虚函数表/gi，/w如果/c值/n是/vshi0/nz，/w表示/v是/vshi最后/f一个/mq虚函数表/gi。/w下面/f，/w我/rr将/d分别/d说明/v“/w无/v覆盖/gi”/w和/cc“/w有/vyou覆盖/gi”/w时/qt的/ude1虚函数表/gi的/ude1样子/n。/w没有/v覆盖/gi父类/nz的/ude1虚函数/nz是/vshi毫无意义/nz的/ude1。/w我/rr之所以/c要/v讲述/v没有/v覆盖/gi的/ude1情况/n，/w主要/b目的/gi是/vshi为了/p给/p一个/mq对比/gi。/w在/p比较/gi之下/f，/w我们/rr可以/v更加/d清楚/a地/ude2知道/v其/rz内部/f的/ude1具体/a实现/gi。/w一般/ad继承/gi（/w无/v虚函数/nz覆盖/gi）/w下面/f，/w再/d让/v我们/rr来/vf看看/v继承/gi时/qt的/ude1虚函数表/gi是/vshi什么样/ryv的/ude1。/w假设/gi有/vyou如下/vi所示/nz的/ude1一个/mq继承/gi关系/gi：/w请注意/nz，/w在/p这个/rz继承/gi关系/gi中/f，/w子类/gm没有/v重载/vn任何/rz父/ng类/gi的/ude1函数/gi。/w那么/c，/w在/p派生类/n的/ude1实例/gi中/f，/w其/rz虚函数表/gi如下/vi所示/nz：/w   /x对于/p实例/gi：/wderive d/nz;/nz /x的/ude1虚函数表/gi如下/vi：/w我们/rr可以/v看到/v下面/f几点/nz：/w /x1/nz）/w虚函数/nz按照/p其/rz声明/gi顺序/gi放于/v表/n中/f。/w /x2/nz）/w父类/nz的/ude1虚函数/nz在/p子类/gm的/ude1虚函数/nz前面/f。/w我/rr相信/v聪明/a的/ude1你/rr一定/b可以/v参考/gi前面/f的/ude1那个/rz程序/gi，/w来/vf编写/gi一段/nz程序/gi来/vf验证/v。/w一般/ad继承/gi（/w有/vyou虚函数/nz覆盖/gi）/w覆盖/gi父类/nz的/ude1虚函数/nz是/vshi很/d显然/ad的/ude1事情/n，/w不然/c，/w虚函数/nz就/d变得/vi毫无意义/nz。/w下面/f，/w我们/rr来看/u一/nz下/f，/w如果/c子类/gm中/f有/vyou虚函数/nz重载/vn了/ule父类/nz的/ude1虚函数/nz，/w会/v是/vshi一个/mq什么/ry样子/n？/w假设/gi，/w我们/rr有/vyou下面/f这样/rzv的/ude1一个/mq继承/gi关系/gi。/w为了/p让/v大家/rr看到/v被/pbei继承/gi过后/v的/ude1效果/gi，/w在/p这个/rz类/gi的/ude1设计/gi中/f，/w我/rr只/d覆盖/gi了/ule父类/nz的/ude1一个/mq函数/gi：/wf/nz(/nz)/nz。/w那么/c，/w对于/p派生类/n的/ude1实例/gi，/w其/rz虚函数表/gi会/v是/vshi下面/f的/ude1一个/mq样子/n：/w我们/rr从/p表/n中/f可以/v看到/v下面/f几点/nz，/w /x1/nz）/w覆盖/gi的/ude1f/nz(/nz)/nz函数/gi被/pbei放到/v了/ule虚表/gi中/f原来/d父类/nz虚函数/nz的/ude1位置/gi。/w /x2/nz）/w没有/v被/pbei覆盖/gi的/ude1函数/gi依旧/z。/w这样/rzv，/w我们/rr就/d可以/v看到/v对于/p下面/f这样/rzv的/ude1程序/gi，/w由/pb/nz所指/n的/ude1内存/gi中的/v虚函数表/gi的/ude1f/nz(/nz)/nz的/ude1位置/gi已经/d被/pbeiderive/nz:/w:/wf/nz(/nz)/nz函数/gi地址/gi所/usuo取代/v，/w于是/cc在/p实际/n调用/gi发生/v时/qt，/w是/vshiderive/nz:/w:/wf/nz(/nz)/nz被/pbei调用/gi了/ule。/w这/rzv就/d实现/gi了/ule多态/gi。/w多重/b继承/gi（/w无/v虚函数/nz覆盖/gi）/w下面/f，/w再/d让/v我们/rr来/vf看看/v多重/b继承/gi中的/v情况/n，/w假设/gi有/vyou下面/f这样/rzv一个/mq类/gi的/ude1继承/gi关系/gi。/w注意/v：/w子类/gm并/cc没有/v覆盖/gi父类/nz的/ude1函数/gi。/w对于/p子类/gm实例/gi中的/v虚函数表/gi，/w是/vshi下面/f这个/rz样子/n：/w /x我们/rr可以/v看到/v：/w /x1/nz）/w  /x每个/r父类/nz都/d有/vyou自己/rr的/ude1虚表/gi。/w /x2/nz）/w  /x子类/gm的/ude1成员/nnt函数/gi被/pbei放到/v了/ule第一个/gi父类/nz的/ude1表/n中/f。/w（/w所谓/v的/ude1第一个/gi父类/nz是/vshi按照/p声明/gi顺序/gi来/vf判断/gi的/ude1）/w这样/rzv做/v就是/v为了/p解决/v不同/a的/ude1父类/nz类型/gi的/ude1指针/gi指向/v同一个子/nz类/gi实例/gi，/w而/cc能够/v调用/gi到/v实际/n的/ude1函数/gi。/w多重/b继承/gi（/w有/vyou虚函数/nz覆盖/gi）/w下面/f我们/rr再来/d看看/v，/w如果/c发生/v虚函数/nz覆盖/gi的/ude1情况/n。/w下图/n中/f，/w我们/rr在/p子类/gm中/f覆盖/gi了/ule父类/nz的/ude1f/nz(/nz)/nz函数/gi。/w下面/f是/vshi对于/p子类/gm实例/gi中的/v虚函数表/gi的/ude1图/gi：/w我们/rr可以/v看见/v，/w三个父/nz类/gi虚函数表/gi中的/vf/nz(/nz)/nz的/ude1位置/gi被/pbei替换成/i了/ule子类/gm的/ude1函数指针/nz。/w这样/rzv，/w我们/rr就/d可以/v任一/r静态/gi类型/gi的/ude1父类/nz来/vf指向/v子类/gm，/w并/cc调用/gi子类/gm的/ude1f/nz(/nz)/nz了/ule。/w如/v：/w安全性/gi每次/r写/vc++/gi的/ude1文章/gi，/w总/b免不了/v要/v批判/vn一下/mc++/gi。/w这/rzv篇文章/n也/d不/d例外/vi。/w通过/p上面/f的/ude1讲述/v，/w相信/v我们/rr对/p虚函数表/gi有/vyou一个/mq比较/gi细致/a的/ude1了解/v了/ule。/w水可载舟/nz，/w亦可覆舟/nz。/w下面/f，/w让/v我们/rr来/vf看看/v我们/rr可以/v用/p虚函数表/gi来/vf干点/nz什么/ry坏事/n吧/y。/w一/nz、/w通过/p父/ng类型/gi的/ude1指针/gi访问子/nz类/gi自己/rr的/ude1虚函数/nz我们/rr知道/v，/w子类/gm没有/v重载/vn父类/nz的/ude1虚函数/nz是/vshi一件/nz毫无意义/nz的/ude1事情/n。/w因为/c多态/gi也/d是/vshi要/v基于/p函数/gi重载/vn的/ude1。/w虽然/c在/p上面/f的/ude1图/gi中/f我们/rr可以/v看到/vbase/nz1/nz的/ude1虚表/gi中/f有/vyouderive/nz的/ude1虚函数/nz，/w但/c我们/rr根本/a不/d可能/v使用/gi下面/f的/ude1语句/gi来/vf调用/gi子类/gm的/ude1自有/b虚函数/nz：/w任何/rz妄图/v使用/gi父类/nz指针/gi想/v调用/gi子类/gm中的/v未/d覆盖/gi父类/nz的/ude1成员/nnt函数/gi的/ude1行为/n都会/n被/pbei编译器/gi视为/v非法/b，/w所以/c，/w这样/rzv的/ude1程序/gi根本无法/i编译/gi通过/p。/w但/c在/p运行/gi时/qt，/w我们/rr可以/v通过/p指针/gi的/ude1方式/n访问/gi虚函数表/gi来/vf达到/v违反/vc++/gi语义/n的/ude1行为/n。/w（/w关于/p这/rzv方面/n的/ude1尝试/v，/w通过/p阅读/gi后面/f附录/n的/ude1代码/gi，/w相信/v你/rr可以/v做到/v这一点/nz）/w二/nz、/w访问/ginon/nz-/nzpublic/nz的/ude1虚函数/nz另外/c，/w如果/c父类/nz的/ude1虚函数/nz是/vshiprivate/nz或/c是/vshiprotected/nz的/ude1，/w但/c这些/rz非/bpublic/nz的/ude1虚函数/nz同样/d会/v存在/v于/p虚函数表/gi中/f，/w所以/c，/w我们/rr同样/d可以/v使用/gi访问/gi虚函数表/gi的/ude1方式/n来/vf访问/gi这些/rznon/nz-/nzpublic/nz的/ude1虚函数/nz，/w这/rzv是/vshi很容易/nz做到/v的/ude1。/w如/v：/wclass base /nz{/nz     private/nz:/w             virtual void f/nz(/nz)/nz /x{/nz cout  /nz“/wbase/nz:/w:/wf/nz”/w  endl/nz;/nz /x}/nz}/nz;/nzclass derive /nz:/w public base/nz{/nz}/nz;/nztypedef void/nz(/nz*/nzfun/nz)/nz(/nzvoid/nz)/nz;/nzvoid main/nz(/nz)/nz /x{/nz     derive d/nz;/nz     fun  pfun /nz=/nz /x(/nzfun/nz)/nz(/nz(/nzint/nz)/nz(/nzint/nz)/nz(/nzd/nz)/nz+/nz0/nz)/nz;/nz     pfun/nz(/nz)/nz;/nz /x}/nz结束语/nc++/gi这/rzv门/n语言/gi是/vshi一门/nzmagic/nz的/ude1语言/gi，/w对于/p程序员/gi来说/uls，/w我们/rr似乎/d永远/d摸/v不/d清楚/a这/rzv门/n语言/gi背着/v我们/rr在/p干/v了/ule什么/ry。/w需要/v熟悉/v这/rzv门/n语言/gi，/w我们/rr就/d必/d需要/v了解/vc++/gi里面/f的/ude1那些/rz东西/n，/w需要/v去/vf了解/vc++/gi中/f那些/rz危险/an的/ude1东西/n。/w不然/c，/w这/rzv是/vshi一种/nz搬起/v石头砸/l自己/rr脚/n的/ude1编程语言/gi。/w在/p文章/gi束/q之前/f还是/c介绍/gi一下/m自己/rr吧/y。/w我/rr从事/vi软件/gi研发/gi有/vyou十个/nz年头/n了/ule，/w目前/t是/vshi软件开发/nz技术主管/nnt，/w技术/gi方面/n，/w主攻/vnunix/gi//nzc/nz//nzc++/gi，/w比较/gi喜欢/gi网络/gi上/f的/ude1技术/gi，/w比如/v分布式计算/nz，/w网格计算/gi，/wp/nz2/nzp/nz，/wajax/gi等/udeng一切/rz和/cc互联网/gi相关/vn的/ude1东西/n。/w管理方面/n比较/gi擅长于/v团队建设/gi，/w技术/gi趋势/gi分析/gi，/w项目管理/gi。/w欢迎/v大家/rr和/cc我/rr交流/gi，/w我/rr的/ude1msn/nz和/ccemail/nz是/vshi：/whaoel/nz@/nzhotmail/nz./nzcom /nz附录/n一/nz：/wvc/nz中/f查看/gi虚函数表/gi我们/rr可以/v在/pvc/nz的/ude1ide/nz环境/n中的/vdebug/gi状态/gi下/f展开/v类/gi的/ude1实例/gi就/d可以/v看到/v虚函数表/gi了/ule（/w并/cc不是/c很/d完整/a的/ude1）/w /x附录/n /x二/nz：/w例程/gi下面/f是/vshi一个/mq关于/p多重/b继承/gi的/ude1虚函数表/gi访问/gi的/ude1例程/gi：/w