#数据结构/gi（/wJava/gi）/w―/w―/w递归/gi
  /x回忆/v的/ude1伤/v，/w挂/v在/p窗/ng；/w曾经/d的/ude1梦/n，/w太/d忧伤/an。/w1./nz递归/gi的/ude1入门/gi学习/gi2./nz递归/gi编程/gi举例说明/nz：/w一个/mq累加/vi过程/gi的/ude1java/gi递归/gi算法/gi的/ude1实现/gi。/w递归/gi和/cc迭代/gi，/w递归/gi是/vshi某些/rz问题/gi优雅/a恰当/a的/ude1解决/v方式/n，/w但是/c在/p某些/rz问题/gi中/f使用/gi递归/gi没有/v迭代/gi显得/v直观/a。/w /x所有/b问题/gi都/d可以/v使用/gi迭代/gi解决/v，/w不过/c有些/rz情况下/nz使用/gi递归/gi太/d复杂/a了/ule。/w /x递归/gi可以/v分为/v直接/ad递归/gi和/cc间接/b递归/gi。/w3./nz递归/gi的/ude1使用/gi3.1/nz使用/gi递归/gi解决/v迷宫/gi问题/gi3.2/nz使用/gi递归/gi解决/v汉诺塔/nrf问题/gi4./nz递归/gi算法/gi分析/gi递归/gi算法/gi的/ude1算法/gi分析/gi：/w在/p分析/gi循环/gi的/ude1时候/n，/w我们/rr先/d判定/gi循环体/n的/ude1序/n，/w然后/c再/d乘以/v该/rz循环/gi的/ude1执行/v次数/gi。/w分析/gi递归/gi算法/gi也/d用/p类似/a的/ude1思路/gi。/w先/d判定/gi递归/gi的/ude1序/n（/w遵循/gi递归/gi定义/gi的/ude1次数/gi）/w，/w再/d乘以/v递归/gi方法/gi体/ng的/ude1序/n。/w以/p计算/gi整数/gi累加/vi（/w从/p1/nz累加/vi到/v某个/rz正数/v）/w的/ude1递归/gi方法/gi为/p例/n。/w递归/gi的/ude1方法/gi体/ng执行/v了/ule一次/nz加法/gi计算/gi其/rz复杂度/gi为/po/nz（/w1/nz）/w。/w /x每次/r调用/gi递归/gi算法/gi时/qt，/wnum/nz的/ude1值/n都会/n递减/vi1/nz，/w因此/c，/w这个/rz递归/gi方法/gi被/pbei调用/ginum/nz次/qv，/w因此/c递归/gi的/ude1序/n为/po/nz（/wn/nz）/w。/w