#全排列/gi算法/gi研究/gi
全排列/gi算法/gi研究/gi什么/ry是/vshi全排列/gi：/w给定/gi一个/mq序列/gi123/nz，/w求/v其/rz全排列/gi？/w结果/n为/p /x123/nz /x132/nz /x213/nz /x231/nz /x312/nz /x321/nz即为/c所有/b的/ude1排列组合/nz数/n全排列/gi的/ude1生成/v算法/gi就是/v从/p第一个/gi排列/gi开始/v逐个/d生成/v所有/b的/ude1排列/gi的/ude1方法/gi。/w每个/r排列/gi的/ude1后继/v都/d可以/v从/p它/rr的/ude1前驱/n经过/p最小/a的/ude1变化/gi而/cc得到/v。/w方法/gi一/nz /x递归/gi的/ude1方法/gi：/w我们/rr求/v123/nz的/ude1全排列/gi的话/udh /x首先/d固定/a第一位/nz /x比如/v第一位/nz为/p /x1/nz /x然后/c只/d需求/gi后/f两位数/n的/ude1全排列/gi，/w即/v /x23/nz的/ude1全排列/gi /x显然/ad这/rzv是/vshi一个/mq递归/gi的/ude1过程/gi方法二/nz /x直接/ad调用/gistl/gi：/wc /nz的/ude1stl/gi中/f已经/d定义/gi了/ule两/nz个/q关于/p全排列/gi的/ude1函数/gi：/w方法三/nz：/w接下来/vl以/p一个/mq例子/gi给出/v另一种/nz计算/gi一个/mq排列/gi后继/v的/ude1算法/gi：/w例/n：/w求/v839647521/nz的/ude1下一个/nz排列/gi？/w1/nz /x先/d找到/v从右到左/nz第一个/gi出现/v下降/vi的/ude1位置/gi的/ude1数/n，/w可得/v这个/rz为/p4/nz /x得/ude3后缀/n为/p4/nz以后/f的/ude1数/n串/q，/w即/v75212/nz /x交换/gi：/w再/d找到/v后缀/n中比/j4/nz大/a的/ude1最小/a的/ude1数/n，/w可得/v为/p5/nz，/w交换/gi4/nz和/cc5/nz，/w此时/r数/n变为/v8396574213/nz /x将/d后缀/n翻转/gi /x839657421/nz中的/v7421/nz翻转/gi，/w得到/v839651247/nz，/w即为/c原数/nz的/ude1下一个/nz排列/gi