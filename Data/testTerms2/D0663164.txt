#设计模式/nz中/f单件/n模式/gi的/ude1学习/gi记录-/nzjava/gi
有些/rz对象/gi其实/d我们/rr只/d需要/v一个/mq，/w比方说/l：/w线程池/gi、/w缓存/gi、/w对话框/gi、/w处理/vn偏好/gi设置/gi和/cc注册/gi表/n的/ude1对象/gi、/w日志/gi对象/gi，/w充当/v打印机/n和/cc显卡/gi等/udeng设备/gi的/ude1驱动程序/gi的/ude1对象/gi。/w这些/rz对象/gi只/d需要/v一个/mq，/w如果/c制造/gi出/vf多/a个/q实例/gi，/w就/d会/v导致/gi许/v多/a问题/gi产生/v，/w比如/v：/w程序/gi的/ude1行为/n异常/gi、/w资源/gi使用/gi过量/vi，/w或者/c是/vshi不/d一致/a的/ude1结果/n。/w设计模式/nz中的/v单件/n模式/gi，/w能够/v很好/ad地/ude2适应/v这种/r需求/gi。/w以下/f代码/gi考虑到/v了/ule，/w多线程/gi可能/v出现/v的/ude1单线程/gi中/f没有/v的/ude1问题/gi。/w给出/v了/ule几/d种/q常见/a的/ude1解决方案/gi。/w多线程/gi几/d种/q解决方案/gi综述/n：/w（/w1/nz）/w把/pba生产/gi单例/gi对象/gi的/ude1方法/gi设置成/n同步/gi方法/gi。/w（/w2/nz）/w在/pjvm/nz加载/gi类/gi时/qt，/w马上/d创建/gi一个/mq单例/gi实例/gi对象/gi，/w即/v不/d适用/vi实例化/gi的/ude1方法/gi。/w（/w3/nz）/w使用/gi双重/b检查/gi加锁/gi，/w首先/d检查/gi是否/v实例/gi已经/d创建/gi了/ule，/w若/c果/ng尚未/d创建/gi，/w“/w才/d”/w进行/vn同步/gi。/w这样/rzv，/w只有/c第一次会/nz同步/gi，/w这个/rz方法/gi是/vshi最好/d的/ude1。/w但是/c有一个/nz显示/gi，/w必须/d使用/gijava/gi5/nz以上/f的/ude1版本/n。/w