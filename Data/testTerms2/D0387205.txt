#UVa /nz1601/nz /x-/nz The Morning after Halloween/nz（/w双向/bBFS/nz版/n）/w
时间/gi限制/vn：/w12.000/nz秒/qt题目/gi链接/gi：/w　　/nz接下来/vl继续/v上次/t，/w接下来/vl向/p双向/bbfs/gi的/ude1方向/gi优化/gi。/w　　/nz那/rzv什么/ry是/vshi双向/bbfs/gi呢/y？/w就是/v从/p两/nz个/q方向/gi进行/vn搜索/gi嘛/y，/w一边/d从/p起点/gi开始/v向/p终点/gi搜索/gi，/w一边/d从/p终点/gi倒/vi着/uzhe向前/gi搜索/gi，/w然后/c从/p两头/n往/p中间/f接/v。/w在/p算法/gi中的/v实现/gi方法/gi是/vshi正反/b两/nz方向/gi的/ude1搜索/gi交替/d进行/vn，/w当/p搜索/gi出/vf相同/a的/ude1状态/gi时/qt，/w路/n就/d打通/v了/ule，/w步数/n就是/v两边/fbfs/gi步数/n的/ude1和/cc。/w　　/nz双向/bbfs/gi的/ude1好处/gi呢/y，/w就是/v避免/v了/ule单向/bbfs/gi步数/n太多/ad产生/v的/ude1组合性/nz爆炸/vn的/ude1情况/n，/w就是/v可能性/gi太多/ad，/w路/n又/d长/a，/w到/v后面/f分叉/n越来越/d多/a，/w“/w爆炸”/nz了/ule，/w而/cc双向/b搜索/gi则/d能/v在/p一定/b程度/n上/f延缓/v组合型/n爆炸/vn，/w也/d就/d大大提高/i了/ule效率/gi。/w当然/d，/w就算/d双向/b，/w如果/c算法/gi写/v得/ude3很烂/a，/w也/d就/d没救/nz了/ule…/w…/w所以/c之前/f这/rzv题/n卡/n到/v死/v啊/y…/w…/w　　/nz不过/c在/p写/v的/ude1时候/n需要/v注意/v双向/bbfs/gi是/vshi怎么/ryv个/q双向/b法/n。/w有些/rz同志/n误以为/i双向/bbfs/gi是/vshi交替/d节点/gi搜索/gi，/w也/d就是/v正着/v搜一个/nz点/gi，/w然后/c倒/vi着/uzhe搜一个/nz点/gi，/w搜到/v相同/a的/ude1点/gi就/d打/v通路/n了/ule。/w但是/c这样/rzv在/p某些/rz情况下/nz是/vshi会/v出错/gi的/ude1。/w例如/v下面/f的/ude1这个/rz图/gi（/w渣/ng鼠标/gi绘制/v，/w求/v不/d喷/v…/w…/w）/w：/w　　/nz上面/f是/vshi一个/mq环/n，/w用/p双向/bbfs/gi搜/v如果/c是/vshi交替/d搜/v节点/gi的话/udh就/d可能/v出错/gi。/w假如/c向/p队列/gi里面/f添加/gi节点/gi的/ude1是/vshi先/d加/v最小/a的话/udh，/w先/d从/p起点/gi开始/v，/w队列/gi里面/f是/vshi1/nz，/w,/nz4/nz，/w然后/c从/p终点/gi搜/v，/w队列/gi是/vshi3/nz，/w5。/nz然后/c再/d正着/v搜/v，/w该/rz搜/v1/nz了/ule，/w搜到/v了/ule5/nz，/w然后/c倒/vi着/uzhe搜/v，/w从/p3/nz搜出/v了/ule5/nz，/w是/vshi已经/d搜到/v的/ude1状态/gi了/ule，/w然后/c得出/v最短路/gi长度/gi是/vshi4。/nz然而/c很/d显然/ad，/w正确/a答案/gi应当/v是/vshi起点/gi→/nz4/nz→/nz5/nz→/nz终点/gi，/w长度/gi是/vshi3。/nz　/nz　/nz那/rzv怎么办/ryv呢/y？/w正确/a的/ude1方法/gi是/vshi，/w一层一层/nz的/ude1来/vf。/w这样/rzv，/w从/p起点/gi搜到/v了/ule1/nz和/cc4/nz，/w终点/gi搜到/v了/ule3/nz和/cc5/nz，/w然后/c从/p1/nz和/cc4/nz搜到/v了/ule2/nz和/cc5/nz，/w这样/rzv就/d和/cc5/nz接上/v了/ule。/w　　/nz现在/t知道/v双向/bbfs/gi是/vshi啥/ry和/cc怎么/ryv双向/b搜/v了/ule，/w接下来/vl把/pba上次/t单向/b的/ude1版本/n改成/v双向/b的/ude1就/d成/v了/ule。/w　　/nz关于/p怎么/ryv实现/gi一层一层/nz的/ude1搜/v，/w我/rr在/p这里/rzs的/ude1做法/n是/vshi记步/nz数/n，/w也/d就是/v这/rzv是/vshi搜/v的/ude1第几层/nz，/w在/p搜索/gi到/v下一层/nz的/ude1节点/gi之前/f继续/v本/rz方向/gi的/ude1bfs/gi，/w当/p搜到/v了/ule下一层/nz的/ude1节点/gi，/w就/d终止/v搜索/gi。/w不/d知道/v这个/rz方法/gi够不够/v好/a，/w欢迎/v大神/nz指正/v…/w…/w话说/vn这/rzv题/npoj/gi上/f也/d有/vyou，/w我/rr改成/v了/ule双向/bbfs/gi结果/nmle/nz了/ule，/w看来/v还/d得/ude3把/pba队列/gi改成/vstl/gi的/ude1队列/gi才/d行/ng啊/y…/w…/w不过/c好/a在/puva/gi直接/ad用/p数组/gi就/da/nz了/ule。/w　　/nz从/p单向/bbfs/gi改成/v双向/bbfs/gi，/w时间/gi从/p3.6/nz秒/qt降到/v2.4/nz秒/qt，/w虽然/c在/p集训队/nis里/f还是/c倒/vi着/uzhe排/v，/w看来/v是/vshi算法/gi写/v得/ude3太/d臭/a，/w不过/c满足/v了/ule…/w…/w{/nzcsdn/gi:/wcode/gi:/w599093/nz}/nz