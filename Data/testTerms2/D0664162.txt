#大话/n设计模式/nz读后/n感-工厂/nz模式/gi
1./nz简单工厂模式/gi的/ude1概念/gi:/w简单工厂模式/gi的/ude1实质/gi是/vshi由/p一个/mq工厂/gi类/gi根据/p传入/gi的/ude1参数/gi，/w动态/gi决定/v应该/v创建/gi哪/ry一个/mq产品/gi类/gi（/w这些/rz产品/gi类/gi继承/gi自/p一个/mq父类/nz或/c接口/gi）/w的/ude1实例/gi。/w2./nz简单工厂模式/gi的/ude1uml/gi图/gi3./nz简单工厂模式/gi的/ude1适用范围/nz1./nz根据/puml/gi图/gi我们/rr可以/v看出/v,/nz简单工厂模式/gi适用/vi的/ude1条件/n,/nz多/a个子/n类/gi继承/gi自/p一个/mq父类/nz,/nz也/d就是说/c一/nz些/q类/gi具有/v相/d的/ude1行为/n和/cc属性/gi./nz2./nz可以/v通过/p某些/rz特殊/a的/ude1判定/gi符/v知道/v要/v实例化/gi哪个/ry类/gi./nz4./nz简单工厂模式/gi的/ude1使用环境/gi1./nz在/p编码/gi时/qt不能/v预见/vn需要/v创建/gi哪些/ry类/gi的/ude1实例/gi2./nz系统/gi不/d依赖于/v产品/gi实例/gi如何/ryv被/pbei创建/gi最后/f的/ude1,/nz关于/p简单工厂模式/gi使用/gi的/ude1一/nz些/qjava/gi语法/gi中的/v小/a技巧-向上/nz转型/gi:/w一个/mq类/gi能/v做/v什么/ry由/p父类/nz定义/gi,/nz但/c怎么做/nz由/p自己/rr定义/gi./nz子类/gm可以/v强/a转为/gi父类/nz,/nz丢失/v他/rr的/ude1一/nz些/q父类/nz没有/v的/ude1方法/gi./nz但是/c父类/nz不能/v强/a转为/gi子类/gm,/nz因为/c编译器/gi不/d知道/v增加/v哪些/ry方法/gi./nz