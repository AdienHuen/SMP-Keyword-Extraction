#设计模式/nz之/uzhi单例模式/gi
单例模式/gi，/w就是/v在/p程序运行/n中/f只能/v实例/gi化出/v一个/mq实例/gi，/w不论/c在/p哪里/rys使用/gi这个/rz类/gi就是/v这/rzv同一个/b实例/gi，/w也/d就是说/c它/rr实例/gi的/ude1地址/gi、/w内容/gi是/vshi一样/uyy的/ude1。/w单例模式/gi首先/d要/v将/d类/gi的/ude1构造函数/gi私有化/vn，/w使/v这个/rz类/gi不能/v在/p外部/f实例化/gi。/w然后/c写/v一个/mq公共/b函数/gi，/w专门/d实例化/gi这个/rz类/gi /x----/nz /x如果/c这个/rz类/gi没有/v实例化/gi过/uguo，/w就/d实例化/gi一次/nz然后/c返回/v这个/rz实例/gi，/w如果/c实例化/gi过/uguo，/w就/d直接/ad返回/v实例化/gi过/uguo的/ude1类/gi。/w这/rzv正/d方法/gi在/p单线程/gi中/f有效/gi，/w但是/c在/p多线程/gi中/f，/w有可能/nz两/nz个/q或/c多/a个/q线程/gi同时/c调用/gi这个/rz方法/gi，/w而/cc之前/f都/d没有/v实例化/gi过/uguo，/w因此/c在/p每个/r线程/gi中/f它/rr的/ude1 instance /nz就/d都/d是/vshi null /nz，/w然后/c就/d都/d实例化/gi一次/nz，/w这样/rzv他们/rr实例/gi化出/v的/ude1类/gi就/d不是/c同一个/b实例/gi了/ule，/w因此/c在/p多线程/gi中/f不能/v这样/rzv写/v，/w要/v同时/c使用/gi到/v线/n程锁/nz。/w但是/c这种/r方法/gi每次/r调用/gi都/d要/v lock/nz，/w比较/gi影响/gi性能/gi，/w解决方法/gi就是/v使用/gi双重/b锁定/v，/w在/p lock /nz之前/f先/d判断/gi instance /nz有/vyou没有/v实例化/gi过/uguo。/w上面/f这种/r方法/gi被/pbei称为/v /x懒汉式/gi单例/gi类/gi，/w因为/c它/rr是/vshi在/p需要/v实例/gi的/ude1时候/n才/d实例化/gi自己/rr。/w而/cc还有/v一种/nz /x饿汉式单例/gi类/gi /x，/w它/rr是/vshi在/p加载/gi时/qt就/d实例化/gi。/wsealed /nz是/vshi为了/p防止/gi发生/v派生/v，/w而/cc派生/v可能会/nz增加/v实例/gi