#java /nz垃圾/n回收/vn机制/gi
（/w一/nz）/wjava gc/nz的/ude1意义/n1/nz、/wgc /nz可以/v有效/gi的/ude1防治/vn内存/gi泄露/gi2/nz、/w减轻/v程序员/gi编程/gi负担/n（/w二/nz）/wgc /nz潜在/b缺点/gi1/nz、/wgc /nz开销/n影响/gi程序/gi性能/gi2/nz、/w不能/v保证/v100%/nz回收/vn无用/vi内存/gi（/w三/nz）/w哪些/ry内存/gi需要/v被/pbei回收/vn？/w在/p主流/gi的/ude1商用/b程序语言/nz的/ude1主流/gi实现/gi中都/ns是/vshi通过/p可达性/gi分析/gi来/vf判断/gi对象/gi是否/v存活/vi（/w判断/gi哪些/ry对象/gi可以/v回收/vn）/w。/w算法/gi基本/a思想/gi：/w通过/p一系列/b的/ude1称为/v“/wgc roots/nz”/w /x的/ude1对象/gi作为/p起始/gi点/gi，/w从/p这些/rz节点/gi开始/v向下/vf搜索/gi，/w搜索/gi所/usuo走过/gi的/ude1路劲/nz称为/v引用/gi链/ng，/w当/p一个/mq对象/gi到/vgc roots /nz没有/v任何/rz引用/gi链/ng相连/vi时/qt则/d证明/v此/rzs对象/gi是/vshi不/d可用/v的/ude1（/w可/v被/pbei回收/vn的/ude1）/w。/w[/nz1/nz]/nz[/nz2/nz]/nz【/w可以/v作为/pgc roots /nz的/ude1对象/gi】/w1/nz、/w虚拟/gi机栈/nz（/w栈帧/nz中的/v本地/gi变量/gi表/n）/w中/f引用/gi的/ude1对象/gi2/nz、/w方法/gi区/n中/f静态/gi类/gi属性/gi引用/gi的/ude1对象/gi3/nz、/w方法/gi区/n中常量/nz引用/gi的/ude1对象/gi4/nz、/w本地/gi方法/gi栈中/nz（/w一般/ad说/v的/ude1native /nz方法/gi）/w引用/gi的/ude1对象/gi事实上/blgc/nz并不需要/l一个/mq不漏/v地/ude2检查/gi完/vi所有/bgc roots/nz，/w虚拟机/gi应当/v是/vshi有/vyou办法/gi直接/ad得到/v哪些地方/nz存放/v着/uzhe对象/gi引用/gi。/w在/photspot/nz的/ude1实现/gi中/f，/w是/vshi使用/gi一/nz组/n成为/voopmap/nz的/ude1数据结构/gi来/vf达到/v这个/rz目的/gi./nz在/p类/gi加载/gi完成/v的/ude1时候/n，/whotspot/nz就/d把/pba对象/gi内/f什么/ry偏移量/gi上/f是/vshi什么/ry类型/gi的/ude1数据/gi计算出来/l，/w在/pjit/nz编译/gi过程/gi中/f，/w也/d会/v在/p特定/b的/ude1位置/gi记录/gi下/f栈里/nz和/cc寄存器/gi里/f哪些/ry位置/gi是/vshi引用/gi。/w这样/rzvgc/nz在/p扫描/gi时/qt就/d就/d可以/v直接/ad得知/v这些/rz信息/gi了/ule。/w[/nz3/nz]/nz（/w二/nz）/w何时/ryt进行/vn垃圾/n回收/vn？/wjava/gi的/ude1垃圾/n回收/vn机制/gi是/vshijava/gi虚拟机/gi提供/v的/ude1能力/gi，/w用于/v在/p空闲/gi时间/gi以不定/nz时/qt的/ude1方式/n动态/gi回收/vn无/v任何/rz引用/gi的/ude1对象/gi占据/v的/ude1内存空间/nz。/wsystem/nz./nzgc/nz(/nz)/nzruntime/nz./nzgetruntime/nz(/nz)/nz./nzgc/nz(/nz)/nz /x上面/f的/ude1方法/gi调用/gi时/qt用于/v显/v式/k通知/gijvm/nz可以/v进行/vn一次/nz垃圾/n回收/vn，/w但/c真正/d垃圾/n回收/vn机制/gi具体/a在/p什么/ry时间/gi点/gi开始/v发生/v动作/gi这/rzv同样/d是/vshi不可/v预料/v的/ude1，/w这/rzv和/cc抢占/gi式/k的/ude1线程/gi在/p发生/v作用/gi时/qt的/ude1原理/gi一样/uyy。/w（/w三/nz）/w如何/ryv进行/vn垃圾/n回收/vn？/w当前/t商业/n虚拟机/gi的/ude1垃圾/n收集/v都/d采用/v“/w分代/nz收集/v”算法/nz。/w算法/gi思想/gi：/w根据/p对象/gi存活/vi周期/n的/ude1不同/a将/d内存/gi划分/v为/p几/d块/q。/w一般/ad把/pbajava /nz堆/gi分为/v新生代/n和/cc老年代/nz新生代/n：/w主要/b是/vshi用来/v存放/v新生/n的/ude1对象/gi。/w老年代/nz：/w主要/b存放/v应用程序/nz中/f生命周期/nz长/a的/ude1内存/gi对象/gi。/w（/w大/a对象/gi、/w长期/d存活/vi的/ude1对象/gi）/w在/p新生代/n中/f，/w每次/r垃圾/n收集/v时/qt都/d发现/v有/vyou大批/m对象/gi死去/v，/w只有/c少量/mq存活/vi，/w那/rzv就/d选用/v复制/gi算法/gi，/w只/d需要/v付出/v少量/mq存活/vi对象/gi的/ude1复制/gi成本/n就/d可以/v完成/v收集/v。/w而/cc老年代/nz中/f因为/c对象/gi存活率/n高/a、/w没有/v额外/b空间/n对/p它/rr进行/vn分配/gi担保/vn，/w就/d必须/d使用/gi“/w标记-清理/nz”/w或/c“/w标记-整理/nz”算法/nz来/vf进行/vn回收/vn。/w参考文献/nz：/w[/nz1/nz]/nz./nz《/w深入/ad理解/gijava/gi虚拟机/gi》/wp/nz64/nz-/nz80/nz[/nz2/nz]/nz./nz  /x[/nz3/nz]/nz./nz /x