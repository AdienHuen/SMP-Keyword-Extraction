#verilog /nz实际/n开发/gi时/qt应该/v注意/v的/ude1问题/gi
1./nz命名/v规范/gi，/w特别/d是/vshi注意/v时钟/gi的/ude1大小写/gi，/w形成/v固定/a的/ude1命名/v习惯/n2./nz时钟脉冲/gp宽度/n，/w在/p使用/gi使/v能/v和/cc数据/gi结合/v的/ude1方式/n传输数据/n时/qt注意/v使/v能/v的/ude1时间/gi最好/d有/vyou一定/b的/ude1冗余/n3./nz归纳/vfifo ram rom/nz的/ude1读写/gi时序/n4./nz在/p时序/n逻辑/n中/f存在/v比较复杂/l的/ude1组合/gi逻辑/n的/ude1时候/n，/w可以/v考虑/v使用/gi状态机/gi，/w应该/v使/v状态机/gi的/ude1每个/r状态/gi尽可能/d简化/gi，/w这样/rzv才能/n避免/v错误/gi5./nz仿真/vn时/qt一定/b要/v考虑/v各种/rz情况/n，/w这样/rzv才能/n发现自己/l设计/gi的/ude1时序/n和/cc当初/t设想/vn的/ude1是否/v一样/uyy6./nzcase/gi语句/gi中/f注意/vdefault/nz的/ude1状态/gi7./nz顶层/f模块/gi中的/v用于/v连接/gi两/nz个/q模块/gi的/ude1变量/gi需要/v定义/gi，/w否则/c会/v默认/v当做/v位/q宽/a为/p1/nz，/w这样/rzv当/p连接/gi的/ude1端口/gi位/q宽/a超过/v1/nz时/qt就/d会/v出现/v问题/gi8./nz一个/mq模块/gi不宜/v写/v得/ude3太/d过/uguo复杂/a，/w这样/rzv不利于/v进行/vn仿真/vn，/w即使/c需要/v写/v得/ude3很复杂/nz，/w也/d可以/v将/d其/rz分成/vi多/a个/q部分/n进行/vn仿真/vn9./nz当/p整个/b模块/gi因为/c牵涉到/l具体/a硬件/gi而/cc无法/v仿真/vn时/qt，/w可以/v把/pba与/cc硬件/gi相关/vn的/ude1部分/n删掉/v，/w或者/c模拟/gi硬件/gi的/ude1部分/n进行/vn仿真/vn10./nz在/p写/v状态机/gi时/qt，/w每个/r状态/gi尽可能/d简单/a，/w尽量/d将/d复杂/a的/ude1状态/gi拆分/gi成/v比较简单/l的/ude1状态/gi，/w这样/rzv可以/v避免/v因/p布局/gi布线/gp的/ude1错误/gi导致/gi实际/n的/ude1运行/gi情况/n跟/p设计/gi的/ude1不符/v的/ude1情况/n。/w