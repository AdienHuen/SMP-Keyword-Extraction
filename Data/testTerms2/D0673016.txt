#排序算法/gi就是/v那么/c回事儿/n</nz三/nz>/nz
  /x堆排序/gi：/w堆/gi每一次/ddeletemin/nz的/ude1时间复杂度/gi是/vshio/nz(/nzlogn/nz)/nz,/nz这/rzv看起/v很/d不错/a，/w因为/cn/nz次/qv出堆/nz也/d只/d需要/vo/nz(/nznlogn/gi)/nz次/qv。/w那/rzv我们/rr是否/v可以/v每次/r出/vf最/d小树/n，/w这样/rzv将/d数组排序/gi呢/y？/w   /x当然/d可以/v！/w我们/rr这/rzv就/d来/vf实现/gi一下/m！/w如果/c忘记/vdeletemin/nz的/ude1实现/gi，/w我们/rr不妨/d再/d重新/d复习/gi一下/m。/w堆排序/gi算法/gi如果/c我们/rr每次/r进行/vndeletemin/nz操作/gi，/w将/dmin/nz存储/gi到/v一个/mq数组/gi中/f，/w这样/rzvn/nz次/qv之后/f就/d会/v得到/v一个/mq排好/nz序/n的/ude1结果/n。/w这样/rzv的/ude1坏处/n是/vshi要求/n一个/mqo/nz(/nzn/nz)/nz的/ude1额外/b数组/gi，/w这/rzv很/d明显/a不如/v快排/nz。/w /x我们/rr这里/rzs有/vyou一个/mq小/a技巧/gi，/w可以/v去掉/v这个/rz额外/b数组/gi。/w /x每次/r将/d最/d顶端/n的/ude1数字/gi和/cc最末端/nz的/ude1数字/gi交换/gi，/wpq/nz./nzsize/nz(/nz)/nz-/nz /x-/nz，/w然后/c就/d可以/v利用/v原本/d的/ude1数组/gi来/vf存储/gi这个/rz结果/n（/w虽然/c是/vshi逆序/nz的/ude1）/w /x这个/rz算法/gi稍微/d复杂/a了/ule一/nz些/q，/w这次/r的/ude1数组/gi更/d“/w正式/ad”/w一/nz些/q(/nz回想/v一下/m，/wdeletemin/nz是/vshi一个/mq内部结构/nz)/nz，/w下标/gi0/nz处/n包含/v着/uzhe数据/gi。/w也许/d这段/r代码/gi比较/gi难以/d理解/gi，/w但是/c现在/t综合/vndeletemin/nz就/d比较简单/l了/ule，/w这个/rz过程/gi其实/d是/vshi在/p给/pa/nz[/nzi/nz]/nz寻找/v一个/mq合适/a的/ude1位置/gi堆排序/gi的/ude1正式/ad过程/gi