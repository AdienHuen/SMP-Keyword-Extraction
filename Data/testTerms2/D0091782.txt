#数据库/gi索引/gi的/ude1作用/gi和/cc优点/gi缺点/gi
原文/n地址/gi：/w为什么/ryv要/v创建/gi索引/gi呢/y？/w这/rzv是因为/c，/w创建/gi索引/gi可以/v大大提高/i系统/gi的/ude1性能/gi。/w第一/mq，/w通过/p创建/gi唯一性/n索引/gi，/w可以/v保证/v数据库表/gi中/f每/rz一行/n数据/gi的/ude1唯一性/n。/w第二/mq，/w可以/v大大/d加快/v /x数据/gi的/ude1检索/gi速度/n，/w这/rzv也/d是/vshi创建/gi索引/gi的/ude1最主要/nz的/ude1原因/n。/w第三，/nz可以/v加速/gi表/n和/cc表/n之间/f的/ude1连接/gi，/w特别是在/l实现/gi数据/gi的/ude1参考/gi完整性/gi方面/n特别/d有/vyou意义/n。/w第四/nz，/w在/p使用/gi分组/gi和/cc排序/gi /x子/ng句/q进行/vn数据检索/nz时/qt，/w同样/d可以/v显著/ad减少/v查询/gi中/f分组/gi和/cc排序/gi的/ude1时间/gi。/w第五/nz，/w通过/p使用/gi索引/gi，/w可以/v在/p查询/gi的/ude1过程/gi中/f，/w使用/gi优化/gi隐藏器/nz，/w提高/v系统/gi的/ude1性能/gi。/w也许/d会/v有人/r要/v问/v：/w增加/v索引/gi有/vyou如此/rzv多/a的/ude1优点/gi，/w为什么/ryv不/d对/p表/n中的/v每一个列/nz创建/gi一个/mq索引/gi呢/y？/w这种/r想法/gi固然/c有/vyou其/rz合理性/n，/w然而/c也/d有/vyou其/rz片面性/n。/w虽然/c，/w索引/gi有/vyou许多优/nz点/gi，/w /x但是/c，/w为/p表/n中的/v每一个列/nz都/d增加/v索引/gi，/w是/vshi非常/d不明智/i的/ude1。/w这/rzv是因为/c，/w增加/v索引/gi也/d有/vyou许多不利/nz的/ude1一个/mq方面/n。/w第一/mq，/w创建/gi索引/gi和/cc维护/gi索引/gi要/v耗费/v时间/gi，/w这种/r时间/gi随着/p数据/gi /x量/n的/ude1增加/v而/cc增加/v。/w第二/mq，/w索引/gi需要/v占/v物理/n空间/n，/w除了/p数据表/gi占/v数据/gi空间/n之外/f，/w每/rz一个/mq索引/gi还要/d占/v一定/b的/ude1物理/n空间/n，/w如果/c要/v建立/gi聚簇/nz索引/gi，/w那么/c需要/v的/ude1空间/n就/d会/v更大/d。/w第三/nz，/w当/p对/p表/n中的/v数据/gi进行/vn增加/v、/w删除/gi和/cc修改/gi的/ude1时候/n，/w索引/gi也/d要/v动态/gi的/ude1维护/gi，/w这样/rzv就/d降低/v了/ule数据/gi的/ude1维护/gi速度/n。/w索引/gi是/vshi建立/gi在/p数据库表/gi中的/v某些/rz列/v的/ude1上面/f。/w因此/c，/w在/p创建/gi索引/gi的/ude1时候/n，/w应该/v仔细/ad考虑/v在/p哪些/ry列上/v可以/v创建/gi索引/gi，/w在/p哪些/ry列上/v不能/v创建/gi索引/gi。/w一般来说/vl，/w应该/v在/p这些/rz列/v /x上/f创建/gi索引/gi，/w例如/v：/w在/p经常/d需要/v搜索/gi的/ude1列上/v，/w可以/v加快/v搜索/gi的/ude1速度/n；/w在/p作为/p主键/nz的/ude1列上/v，/w强制/vd该/rz列/v的/ude1唯一性/n和/cc组织/gi表/n中/f数据/gi的/ude1排列/gi结构/gi；/w在/p经常/d用/p在/p连接/gi的/ude1列上/v，/w这/rzv /x些/q列/v主要/b是/vshi一/nz些/q外键/gi，/w可以/v加快/v连接/gi的/ude1速度/n；/w在/p经常/d需要/v根据/p范围/n进行/vn搜索/gi的/ude1列上/v创建/gi索引/gi，/w因为/c索引/gi已经/d排序/gi，/w其/rz指定/v的/ude1范围/n是/vshi连续/gi的/ude1；/w在/p经常/d需要/v排序/gi的/ude1列上/v创/v /x建/v索引/gi，/w因为/c索引/gi已经/d排序/gi，/w这样/rzv查询/gi可以/v利用/v索引/gi的/ude1排序/gi，/w加快/v排序/gi查询/gi时间/gi；/w在/p经常/d使用/gi在/pwhere/nz子/ng句/q中的/v列/v上面/f创建/gi索引/gi，/w加快/v条件/n的/ude1判断/gi速度/n。/w同样/d，/w对于/p有些/rz列/v不/d应该/v创建/gi索引/gi。/w一般来说/vl，/w不/d应该/v创建/gi索引/gi的/ude1的/ude1这些/rz列/v具有/v下列/b特点/n：/w第一/mq，/w对于/p那些/rz在/p查询/gi中/f很少/ad使用/gi或者/c参考/gi的/ude1列/v不/d应该/v创建/gi索引/gi。/w这/rzv是/vshi因/p /x为/p，/w既然/c这些/rz列/v很少/ad使用/gi到/v，/w因此/c有/vyou索引/gi或者/c无索引/nz，/w并/cc不能/v提高/v查询/gi速度/n。/w相反/vi，/w由于/p增加/v了/ule索引/gi，/w反而/d降低/v了/ule系统/gi的/ude1维护/gi速度/n和/cc增大/v了/ule空间/n需求/gi。/w第二/mq，/w对于/p那/rzv /x些/q只有/c很少/ad数据/gi的/ude1列/v也/d不/d应该/v增加/v索引/gi。/w这/rzv是因为/c，/w由于/p这些/rz列/v的/ude1取/v很少/ad，/w例如/v人事表/nz的/ude1性别/n列/v，/w在/p查询/gi的/ude1结果/n中/f，/w结果/n集/q的/ude1数据/gi行/ng占/v了/ule表/n中/f数据行/nz的/ude1很大/d比/p /x例/n，/w即/v需要/v在/p表/n中/f搜索/gi的/ude1数据行/nz的/ude1比例/n很大/d。/w增加/v索引/gi，/w并/cc不能/v明显/a加快/v检索/gi速度/n。/w第三，/nz对于/p那些/rz定义/gi为/ptext/nz,/nz image/nz和/ccbit/nz数据类型/gi的/ude1列/v不/d应该/v增加/v索引/gi。/w这/rzv是因为/c，/w这些/rz列/v的/ude1数据量/n要么/c相当大/nz，/w要么/c取/v很少/ad。/w第四/nz，/w当/p修改/gi性能/gi远远/d大于/v检索/gi性能/gi时/qt，/w不/d应该/v创建/gi索/vg /x引/v。/w这/rzv是因为/c，/w修改/gi性能/gi和/cc检索/gi性能/gi是/vshi互相矛盾/l的/ude1。/w当/p增加/v索引/gi时/qt，/w会/v提高/v检索/gi性能/gi，/w但是/c会/v降低/v修改/gi性能/gi。/w当/p减少/v索引/gi时/qt，/w会/v提高/v修改/gi性能/gi，/w降低/v检索/gi性能/gi。/w因/p /x此/rzs，/w当/p修改/gi性能/gi远远/d大于/v检索/gi性能/gi时/qt，/w不/d应该/v创建/gi索引/gi。/w创建/gi索引/gi的/ude1方法/gi和/cc索引/gi的/ude1特征/gi创建/gi索引/gi的/ude1方法/gi创建/gi索引/gi有/vyou多/a种/q方法/gi，/w这些/rz方法/gi包括/v直接/ad创建/gi索引/gi的/ude1方法/gi和/cc间接/b创建/gi索引/gi的/ude1方法/gi。/w直接/ad创建/gi索引/gi，/w例如/v使用/gicreate index/nz语句/gi或者/c使用/gi创建/gi索引/gi向导/gi，/w间接/b创建/gi索引/gi，/w例如/v在/p表/n中/f定义/gi主键/nz约束/gi或者/c唯一性/n键/n约束/gi时/qt，/w同时/c也/d创建/gi了/ule索引/gi。/w虽然/c，/w这/rzv两/nz种/q方法/gi都/d可以/v创建/gi索引/gi，/w但/c /x是/vshi，/w它们/rr创建/gi索引/gi的/ude1具体内容/nz是/vshi有区别/nz的/ude1。/w使用/gicreate index/nz语句/gi或者/c使用/gi创建/gi索引/gi向导/gi来/vf创建/gi索引/gi，/w这/rzv是/vshi最/d基本/a的/ude1索引/gi创建/gi方式/n，/w并且/c这种/r方法/gi最/d具有/v柔性/n，/w可以/v定制/n创建/gi出/vf符合/v自己/rr需要/v的/ude1索引/gi。/w在/p使用/gi这种/r方式/n /x创建/gi索引/gi时/qt，/w可以/v使用/gi许/v多/a选项/gi，/w例如/v指定/v数据页/nz的/ude1充满/v度/qv、/w进行/vn排序/gi、/w整理/gi统计/gi信息/gi等/udeng，/w这样/rzv可以/v优化/gi索引/gi。/w使用/gi这种/r方法/gi，/w可以/v指定/v索引/gi的/ude1类型/gi、/w唯一性/n和/cc复合/vn /x性/ng，/w也/d就是说/c，/w既/c可以/v创建/gi聚簇/nz索引/gi，/w也/d可以/v创建/gi非/b聚簇/nz索引/gi，/w既/c可以/v在/p一个列/nz上/f创建/gi索引/gi，/w也/d可以/v在/p两/nz个/q或者/c两/nz个/q以上/f的/ude1列上/v创建/gi索引/gi。/w通过/p定义/gi主键/nz约束/gi或者/c唯一性/n键/n约束/gi，/w也/d可以/v间接/b创建/gi索引/gi。/w主键/nz约束/gi是/vshi一种/nz保持数据/n完整性/gi的/ude1逻辑/n，/w它/rr限制/vn表/n中的/v记录/gi有/vyou相同/a的/ude1主键/nz记录/gi。/w在/p创建/gi主键/nz约束/gi时/qt，/w系/v /x统/vi自动/d创建/gi了/ule一个/mq唯一性/n的/ude1聚簇/nz索引/gi。/w虽然/c，/w在/p逻辑上/nz，/w主键/nz约束/gi是/vshi一种/nz重要/a的/ude1结构/gi，/w但是/c，/w在/p物理/n结构上/nz，/w与/cc主键/nz约束/gi相/d对应/vi的/ude1结构/gi是/vshi唯一性/n的/ude1聚簇/nz索引/gi。/w换句话/c /x说/v，/w在/p物理/n实现/gi上/f，/w不存在/ns主键/nz约束/gi，/w而/cc只/d存在/v唯一性/n的/ude1聚簇/nz索引/gi。/w同样/d，/w在/p创建/gi唯一性/n键/n约束/gi时/qt，/w也/d同时/c创建/gi了/ule索引/gi，/w这种/r索引/gi则/d是/vshi唯一性/n的/ude1非/b聚簇/nz索引/gi。/w因此/c，/w /x当/p使用/gi约束/gi创建/gi索引/gi时/qt，/w索引/gi的/ude1类型/gi和/cc特征/gi基本上/d都/d已经/d确定/v了/ule，/w由/p用户/gi定制/n的/ude1余地/n比较/gi小/a。/w当/p在/p表/n上/f定义/gi主键/nz或者/c唯一性/n键/n约束/gi时/qt，/w如果/c表/n中/f已经/d有/vyou了/ule使用/gicreate index/nz语句/gi创建/gi的/ude1标准/gi索引/gi时/qt，/w那么/c主键/nz约束/gi或者/c唯一性/n键/n约束/gi创建/gi的/ude1索引/gi覆盖/gi以前/f创建/gi的/ude1标准/gi索引/gi。/w也/d就是说/c，/w主键/nz约束/gi或者/c唯一性/n键/n约束/gi创建/gi的/ude1索引/gi的/ude1优先/vd /x级/q高于/v使用/gicreate index/nz语句/gi创建/gi的/ude1索引/gi。/w索引/gi的/ude1特征/gi索引/gi有/vyou两/nz个/q特征/gi，/w即/v唯一性/n索引/gi和/cc复合/vn索引/gi。/w唯一性/n索引/gi保证/v在/p索引列/nz中的全部/nz数据/gi是/vshi唯一/b的/ude1，/w不会/v包含/v冗余/n数据/gi。/w如果/c表/n中/f已经/d有/vyou一个/mq主键/nz约束/gi或者/c唯一性/n键/n约束/gi，/w那么/c当/p创建/gi表/n或者/c修改/gi表/n时/qt，/wsql server/gi自动/d创建/gi一个/mq唯一性/n索引/gi。/w然而/c，/w如果/c必须/d保证/v唯一性/n，/w那么/c应该/v创建/gi主键/nz约束/gi或者/c唯一性/n键/n约束/gi，/w而/cc不是/c创建/gi一个/mq唯一性/n索引/gi。/w当/p创建/gi唯一性/n索引/gi /x时/qt，/w应该/v认真/ad考虑/v这些/rz规则/gi：/w当/p在/p表/n中/f创建/gi主键/nz约束/gi或者/c唯一性/n键/n约束/gi时/qt，/wsql server/gi自动/d创建/gi一个/mq唯一性/n索引/gi；/w如果/c表/n中/f已经/d包含/v有/vyou数据/gi，/w那么/c当/p创建/gi索引/gi时/qt，/wsql server/gi检查表/gi中/f已有/v数据/gi的/ude1冗余/n性/ng；/w每当/p使用/gi插入/gi语句/gi插入/gi数据/gi或者/c使用/gi修改/gi语句/gi修改/gi数据/gi时/qt，/wsql server/gi检查数据/n的/ude1冗余/n性/ng：/w如果/c有/vyou冗余/n，/w那么/csql server/gi取消/v该/rz语句/gi的/ude1执行/v，/w并且/c返回/v一个/mq错误/gi消息/n；/w确保/v表/n中的/v每/rz一行/n数据/gi都/d有/vyou一个/mq唯一/b，/w这样/rzv可以/v确保/v每一个/nz实体/n都/d可以/v唯一/b确认/v；/w只能/v在/p可以/v保证/v实体/n /x完整性/gi的/ude1列上/v创建/gi唯一性/n索引/gi，/w例如/v，/w不能/v在/p人事表/nz中的/v姓名列/nz上/f创建/gi唯一性/n索引/gi，/w因为/c人们/n可以/v有/vyou相同/a的/ude1姓名/gi。/w复合/vn索引/gi就是/v一个/mq索引/gi创建/gi在/p两/nz个/q列/v或者/c多/a个/q列上/v。/w在/p搜索/gi时/qt，/w当/p两/nz个/q或者/c多/a个/q列/v作为/p一个/mq关键/n时/qt，/w最好/d在/p这些/rz列上/v创建/gi复合/vn索引/gi。/w当/p创建/gi复合/vn索引/gi时/qt，/w应该/v考虑/v /x这些/rz规则/gi：/w最多/ad可以/v把/pba16/nz个/q列/v合并/gi成/v一个/mq单独/d的/ude1复合/vn索引/gi，/w构成/v复合/vn索引/gi的/ude1列/v的/ude1总长度/n不能/v超过/v900/nz字节/gi，/w也/d就是说/c复合列/nz的/ude1长度/gi不能/v太长/n；/w在/p复合/vn索引/gi中/f，/w所/usuo /x有的/rz列/v必须/d来自/v同一个表/nz中/f，/w不能/v跨/v表/n建立/gi复合/vn列/v；/w在/p复合/vn索引/gi中/f，/w列/v的/ude1排列/gi顺序/gi是/vshi非常/d重要/a的/ude1，/w因此/c要/v认真/ad排列/gi列/v的/ude1顺序/gi，/w原则上/nz，/w应该/v首先/d定义/gi最/d唯一/b的/ude1列/v，/w例/n /x如/v在/p（/wcol/nz1/nz，/wcol/nz2/nz）/w上/f的/ude1索引/gi与/cc在/p（/wcol/nz2/nz，/wcol/nz1/nz）/w上/f的/ude1索引/gi是/vshi不/d相同/a的/ude1，/w因为/c两/nz个/q索引/gi的/ude1列/v的/ude1顺序/gi不同/a；/w为了/p使/v查询/gi优化器/nz使用/gi复合/vn索引/gi，/w查询/gi语/ng /x句/q中的/vwhere/nz子/ng句/q必须/d参考/gi复合/vn索引/gi中/f第一个列/nz；/w当表/nz中/f有/vyou多/a个/q关键列/nz时/qt，/w复合/vn索引/gi是/vshi非常/d有/vyou用/p的/ude1；/w使用/gi复合/vn索引/gi可以/v提高/v查询/gi性能/gi，/w减少/v在/p一个表/nz中所/j创建/gi的/ude1 /x索引/gi数量/n。/w