#BASE/nz64/nz编码/gi C/nz实现/gi
base64/gi编码/gi可以/v看作/v是/vshi一种/nz数据可视化/gi的/ude1编码/gi集/q，/w也/d可以/v看作/v是/vshi一种/nz简单/a的/ude1数据加密/gi处理/vn。/w即/v展现出/v数据编码/nz的/ude1思路/gi，/w也/d满足/v了/ule数据可视化/gi的/ude1要求/n。/w同时/c展现出/v一种/nz简单/a的/ude1数据加密/gi方法/gi。/w在/p处理/vn很/d多/a数据/gi缓冲区/gi的/ude1时候/n，/w对于/p不/d可见/c字符/gi，/w都/d比较/gi头疼/a，/w不/d知道/v这些/rz不/d可见/c字符/gi到底/d是/vshi什么/ry，/w即使/c是/vshi比对/d他们/rr的/ude1asscii/nz，/w也/d比较/gi麻烦/an，/w需要/v中断/gi或者/c调试/gi或者/c修改/gi代码/gi等到/v。/w所以/c很/d多/a时候/n会/v将/d这些/rz不/d可见/c字符/gi转换/gi为/p可视化/gi的/ude1串/q，/w从而/c检查/gi调试/gi其数/nz是否/v正确/a。/w可视化/gi的/ude1过程/gi当然/d可以/v选择/gibase64/gi,/nz同样/d也/d可以/v选择/gi其他/rzv的/ude1方式/n，/w如/v直接/ad将/d每个/r字节/gi转换成/i两/nz位/q十六/nz进/vf制数/nz，/w也/d同样/d可以/v进行/vn比较/gi，/w而且/c不会/v破坏/v字节/gi与/cc字节/gi之间/f的/ude1关系/gi，/w显得/v更加/d方便/a。/w同样/d是/vshi三个字/nz节/q，/w转换/gi为/pbase64/gi编码/gi需要/v4/nz个/q字节/gi，/w转换/gi为/p16/nz进制/v则/d需要/v6/nz个/q字节/gi，/w因此/c，/w相对于/nz16/nz进制/v表示法/n，/wbase64/gi可以/v减少/v数据/gi长度/gi。/w从/p编码/gi学/v的/ude1角度/n来看/u，/w也/d可以/v很好/ad的/ude1理解/gi，/w对于/p每个/r字节/gi，/wbase64/gi使用/gi了/ule6/nz比特/q，/w而/cc十六/nz进制/v只/d使用/gi四字节/nz（/w编码/gi16/nz个字符/n只/d需要/v4/nz字节/gi，/w但是/c表示/v的话/udh，/w还是/c每个/r字节/gi表示/v一个/mq字符/gi）/w。/wbase64/gi编码/gi规则/gi：/w将/d原/b字符串/gi顺序/gi切割/v为/p长度/gi3/nz的/ude1分组/gi（/w最后/f一个/mq分组/gi长度/gi不一定/nz为/p3/nz）/w，/w然后/c将/d每个/r分组/gi转换/gi为/p4/nz字节/gi的/ude1base64/gi编码/gi，/w对于/p长度/gi为/p3/nz的/ude1分组/gi，/w将/d3/nz个/q字节/gi转换/gi为/p二进制/gi，/w总共/d24/nz比特/q，/w将/d这/rzv24/nz比特/q顺次/d切割/v为/p4/nz个/q6/nz比特/q的/ude1分组/gi，/w再/d把/pba每个/r分组/gi高位/n补/v两/nz个/q0/nz，/w补足/v8/nz比特/q。/w根据/p下面/f的/ude1base64/gi编码/gi表/n将/d4/nz个/q8/nz比特/q字节/gi转换/gi为/p对应/vi的/ude1字符/gi；/w对于/p长度/gi为/p1/nz的/ude1分组/gi，/w取/v高/a6/nz位/q生成/v第一位/nzbase64/gi编码/gi，/w低/a两/nz位/q右/f补/v4/nz个/q0/nz，/w并/cc转换/gi为/p第二个/nzbase64/gi编码/gi，/w然后/c在/p这/rzv两/nz个/q编码/gi后/f补/v两/nz个/q等/udeng号“/nz=/nz”/w，/w生成/v四位/nzbase64/gi编码/gi；/w对于/p长度/gi为/p2/nz的/ude1分组/gi，/w处理/vn逻辑/n类/gi与/cc长度/gi为/p1/nz的/ude1分组/gi，/w将/d2/nz字节/gi的/ude116/nz位/q二进制/gi从左到右/nz顺次/d分割/gi，/w第一个/gi6/nz比特/q生成/v第一个/gibase64/gi编码/gi，/w第二个/nz6/nz比特/q生成/v第二个/nzbase64/gi编码/gi，/w剩余/vn的/ude1四比特/nz右边/f补/v两/nz个/q0/nz，/w生成/v第三/nz个/qbase64/gi编码/gi，/w后面/f补一个/nz“=/nz”号/nz，/w凑足/v4/nz个/qbase64/gi编码/gi。/w然后/c按照/p顺序/gi，/w将/d多/a组/nbase64/gi编码/gi串/q起来/vf，/w生成/v最终/d的/ude1base64/gi编码/gi串/q。/wbase64/gi解码/gi规则/gi：/w将/dbase64/gi编码/gi的/ude1串/q切割/v为/p宽/a4/nz的/ude1分组/gi，/w对于/p每一个/nz分组/gi，/w将/d四个/nz字符/gi转换成/i对应/vi的/ude1base64/gi编码/gi二进制/gi，/w取/v每个/r字节/gi的/ude1低/a6/nz位/q，/w并/cc将/d这/rzv六位/nz按/p顺序/gi连接起来/l，/w得到/v24/nz比特/q，/w将/d这/rzv24/nz比特/q分割/gi为/p3/nz个/q8/nz比特/q字节/gi。/w然后/c还原/gi成三/nz个/qascii/gi字符/gi。/w如果/c带/vbase64/gi编码/gi带/v等号/n的话/udh，/w跟/p编码/gi规则/gi相反/vi，/w一个/mq等号/n时/qt，/w得到/v2/nz个/q原/b字符/gi，/w两/nz个/q等/udeng号/q时/qt，/w得到/v一个/mq原/b字符/gi。/w最后/f把/pba所有/b解码/gi得到/v的/ude1字符/gi分组/gi按/p顺序/gi串联/v起来/vf。/w下面/f给出/v基于/pc/nz的/ude1base64/gi实现/gi，/w使用/gi了/ule字典/gi表/n，/w比较/gi方便/a，/w高效/b：/w使用/gi字典/gi表/n，/w可以/v直接/ad通过/p字典/gi查/v使用/gi下标/gi转换/gi编码/gi。/w