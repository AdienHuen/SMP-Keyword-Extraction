#Unity/nz3d/gi与/cc设计模式/nz（/w三/nz）/w工厂模式/gi
这个/rz系列/n的/ude1文章/gi，/w并/cc不会/v将/d所有/b用/p到/v的/ude1设计模式/nz全部/m讲/v一/nz遍/qv，/w事实上/bl我/rr个人/n认为/v，/w并/cc不是/c所有/b的/ude1设计模式/nz都/d适用/vi于/punity/nz3d/gi。/w这里/rzs讲/v的/ude1主要/b还是/c一/nz些/q常用/a的/ude1设计模式/nz。/w /x那么/c，/w本章/r讲/v的/ude1就是/v常见/a的/ude1构建/gi型/k模式/gi当中/f的/ude1工厂模式/gi。/w简单工厂模式/gi讲/v工厂/gi，/w首先/d得/ude3从/p简单工厂/gi说起/v。/w /x简单工厂模式/gi的/ude1目的/gi是/vshi用来/v创建/gi不同/a类型/gi的/ude1对象/gi。/w需要/v指出/v的/ude1是/vshi它/rr并/cc不是/cgof/gi的/ude123/nz种/q模式/gi之一/rz。/w结构/gi实现/gi废话少说/n，/w直接/ad上/f代码/gi。/w简单工厂模式/gi的/ude1create/gi(/nz)/nz方法/gi里/f，/w可以/v添加/gi各种/rz逻辑/n，/w用于/v创建/gi对应/vi的/ude1实例/gi。/wunity/nz3d/gi中/f很/d多/a时候/n创建/gi的/ude1是/vshi游戏/gi中的/v物件/n，/w这时/rzt简单工厂模式/gi中/f创建者/n的/ude1参数/gi可以/v对应/viprefab/nz的/ude1名字/n。/w优点/gi简单/a，/w可以/v取名/v叫/vi『/w2/nz分钟/qt内/f可以/v学会/v的/ude1设计模式/nz』/w实现/gi逻辑/n清晰/a，/w根据/p不同/a的/ude1创建/gi参数/gi创建/gi对应/vi实例/gi。/w名为/v简单工厂/gi方法/gi，/w看起来/v果然/d是/vshi很/d简单/a，/w对/p不/d对/p？/w那么/c，/w本着/p”/wsimple is best/nz”/w的/ude1逻辑/n，/w是不是/v我们/rr应该/v大力推广/nz简单工厂模式/gi呢/y？/w /x答案/gi是/vshi「/nzno/nz」/nz。/w简单工厂模式/gi有/vyou其/rz固有/b的/ude1缺陷/gi，/w在/p使用/gi时/qt需要/v严格/ad限定/v其/rz范围/n。/w缺陷/gi让/v我们/rr首先/d考虑/v一个/mq问题/gi。/w此处/s使用/gi的/ude1create/gi(/nz)/nz方法/gi，/w直接/ad决定/v我们/rr产生/v实例/gi的/ude1逻辑/n。/w /x那么/c，/w现在/t问题/gi来/vf了/ule。/w /x假如/c我们/rr不/d希望/v通过/p判断/gi参数/gi是/vshi1/nz还是/c2/nz，/w来/vf进行/vn不同/a实例/gi的/ude1生成/v呢/y？/w /x显然/ad，/w一旦/d我们/rr需要/v新的/a逻辑/n来/vf产生/v实例/gi的话/udh，/w我们/rr就/d不得不/d对/p代码/gi进行/vn修改/gi。/w /x当然/d，/w从/p理论上/nz，/w我们/rr也/d可以/v发现/v简单工厂模式/gi的/ude1一些/m问题/gi。/w open/nz-/nzclosed/nz原则/gi，/w即是/c对/p扩展/gi开放/gi，/w对/p修改/gi封闭/gi。/w使用/gi简单工厂模式/gi时/qt，/w很/d多/a时候/n违背/v了/ule这/rzv一/nz原则/gi。/w同时/c，/w由于/p产生/v不同/a实例/gi的/ude1方法/gi在/p可/v预见/vn的/ude1将来/t有可能会/nz变得/vi很复杂/nz，/w是否/v满足/v单一/gi职责/gi这一点/nz也/d值得/v商榷/vi。/w /x那么/c，/w我们/rr有/vyou办法/gi解决/v这个/rz问题/gi吗/y？/w嗯/e，/w接下来/vl就是/v抽象/gi程度/n更高/d的/ude1方法/gi出场/vi了/ule。/w工厂方法/gi工厂方法/gi与/cc简单工厂/gi最大/gm的/ude1区别/gi，/w在于/v工厂方法/gi将/d工厂/gi进行/vn了/ule抽象/gi，/w将/d实现/gi逻辑/n延迟/v到/v工厂/gi的/ude1子类/gm。/w结构/gi实现/gi为了/p让/v我们/rr例子/gi更/d贴近/v生产/gi环境/n，/w在/p这里/rzs采用/v一个/mq更加/d实际/n的/ude1问题/gi。/w /x场景/gi当中/f有/vyou两/nz个/q物体/gi，/w我们/rr希望/v其中/rz一个/mq向左/d走/v，/w一个/mq向右走/nz。/w /x我们/rr用/p工厂方法/gi来/vf生成/v这/rzv两/nz个/q向左/d向右/d的/ude1控制器/n，/w并/cc添加/gi到/v对应/vi的/ude1物体/gi上/f。/w当然/d，/w事实上/bl这个/rz例子/gi依然/d很/d单薄/a，/w实际/n面对/v这个/rz问题/gi我们/rr肯定/v不会/v这样/rzv实现/gi就是/v了/ule。/w /x上/f代码/gi /x*/nz iwalkerleftwalkerrightwalkeriwalkerfactoryleftwalkerfactoryrightwalkerfactory/nz优点/gi工厂方法/gi比/p简单工厂/gi多/a了/ule一层/nz抽象/gi。/w /x由于/p抽象工厂/gi层/gi的/ude1存在/v，/w当/p我们/rr需要/v修改/gi一个/mq实现/gi的/ude1时候/n，/w我们/rr不/d需要/v修改/gi工厂/gi的/ude1角色/gi，/w只/d需要/v修改/gi实现/gi的/ude1子类/gm就/d可以/v完成/v这个/rz工作/gi。/w /x同样/d，/w当/p我们/rr需要/v增加/v一个/mq新产品/nz的/ude1时候/n，/w我们/rr也/d不/d需要/v修改/gi工厂/gi的/ude1角色/gi，/w只/d需要/v增加/v一个/mq新的/a实现/gi工厂/gi来/vf完成/v实现/gi就/d可以/v了/ule。/w /x显然/ad，/w这样/rzv更/d易于/vd扩展/gi，/w并且/c，/w整体/n代码/gi的/ude1层级/n结构/gi更加/d分明/a，/w创建/gi实际/n产品/gi的/ude1职责/gi更加/d单一/gi。/w /x此外/c，/w很/d显然/ad客户/n在/p定义/gi工厂/gi角色/gi的/ude1时候/n不/d需要/v知道/v实现/gi子类/gm。/w只有/c当/p实际/n需要/v创建/gi的/ude1时候/n，/w才/d动态/gi指定/v子类/gm。/w这/rzv同样/d带来/v了/ule代码/gi的/ude1稳定性/n和/cc最小/a可知性/nz。/w缺陷/gi显然/ad，/w使用/gi工厂方法/gi的/ude1代码/gi量/n是/vshi多于/v简单工厂/gi的/ude1。/w /x同时/c，/w每/rz增加/v一个/mq新的/a产品/gi，/w就/d会/v增加/v一个/mq新的/a工厂/gi类/gi，/w代码/gi的/ude1复杂程度/n自然/n也/d随之/d上升/vi了/ule。/w我们/rr会/v为此/bl创建/gi很/d多/a的/ude1工厂/gi。/w抽象工厂/gi抽象工厂/gi和/cc工厂方法/gi实际上/d是/vshi很/d像/v的/ude1，/w不过/c抽象工厂/gi增加/v了/ule另外/c一个/mq概念/gi，/w就是/v产品/gi族/ng。/w也/d就是说/c，/w一个/mq工厂/gi可以/v生产/gi一系列/b的/ude1产品/gi，/w这些/rz产品/gi的/ude1定义/gi都/d在/p工厂/gi当中/f。/w结构/gi实现/giok/nz。/w这个/rz模式/gi老实/a说/v意义/n不是/c很大/d。/w直接/ad上/f代码/gi吧/y，/w就/d不加/v注释/gi了/ule优点/gi当/p我们/rr需要/v增加/v一个/mq产品/gi族/ng的/ude1时候/n，/w我们/rr只/d需要/v增加/v一个/mq工厂/gi，/w实现/gi其中/rz所有/b产品/gi的/ude1实现/gi就行了/l。/w /x抽象工厂/gi的/ude1设计/gi，/w使得/vi我们/rr可以/v很容易/nz的/ude1增加/v一个/mq产品/gi系列/n。/w缺点/gi抽象工厂/gi当中/f，/w产品/gi族/ng的/ude1定义/gi使得/vi子类/gm必须/d去/vf实现/gi所有/b的/ude1产品/gi生产/gi。/w /x因此/c，/w抽象工厂/gi并不/d适合于/v横向/n扩展/gi，/w即/v需要/v增加/v产品/gi的/ude1情况/n。/w /x一旦/d需要/v增加/v产品/gi，/w那么/c我们/rr甚至/d需要/v去/vf修改/gi抽象/gi的/ude1基类/nz。/w这/rzv是/vshi比较/gi违反/v开闭/nz原则/gi，/w不/d太/d符合/v面向对象设计/gi的/ude1做法/n。/w总结/gi从/p简单工厂/gi到/v工厂方法/gi再/d到/v抽象工厂/gi。/w我们/rr可以/v看到/v，/w抽象/gi的/ude1程度/n越来越/d高/a，/w能够/v解决/v的/ude1问题/gi也/d越来越/d复杂/a。/w /x不过/c，/w个人/n的/ude1经验/gi而言/uls，/w一般/ad在/punity/nz3d/gi当中/f也/d顶多/d用/p到/v工厂方法/gi而已/y。/w抽象工厂/gi事实上/bl并/cc不是/c一个/mq很/d灵活/a的/ude1解决方案/gi。/w /x而且/c，/w对于/punity/nz3d/gi中/f组件/gi的/ude1创建/gi，/w事实上/bl是/vshi有/vyou一/nz些/q非常灵活/i的/ude1解决方案/gi可以/v处理/vn的/ude1。/w实体/n与/cc组件/gi系统/gi，/w相当/d适合于/v组件/gi的/ude1构建/gi，/w比起/v工厂方法/gi来说/uls更加/d灵活/a和/cc易于/vd扩展/gi。/w /x以后/f有/vyou时间/gi的/ude1时候/n再/d对此/d进行/vn说明/v。/w本章/r的/ude1例子/gi /x