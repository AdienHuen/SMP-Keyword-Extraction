#金币/n阵列/gi
问题/gi描述/gi：/w有/vyoum/nz*/nzn/nz枚/q金币/n在/p桌面上/n排列成/v一个/mqm/nz行/ngn/nz列/v的/ude1金币/n阵列/gi。/w每/rz一/nz枚/q金币/n或/c正面/b朝/tg上/f，/w或/c背面/f朝/tg上/f。/w用/p数字/gi表示/v金币/n状态/gi，/w0/nz表示/v正面/b朝/tg上/f，/w1/nz表示/v背面/f朝/tg上/f。/w金币/n阵列/gi游戏/gi的/ude1规则/gi是/vshi：/w /x（/w1/nz）/w每次/r将/d任/v一行/n金币/n翻过来/l放在/v原来/d的/ude1位置/gi上/f。/w /x（/w2/nz）/w每次/r可以/v任选/v2/nz列/v，/w交换/gi这/rzv2/nz列/v金币/n的/ude1位置/gi。/w任务/gi：/w给/p定金币/nz的/ude1初始状态/gi和/cc目标/gi状态/gi，/w编程/gi计算/gi按/p金币/n游戏规则/nz，/w将/d金币/n排列/gi从/p初始状态/gi变换/gi到/v目标/gi状态/gi所需/nz的/ude1最少/d变换/gi次数/gi。/w /x解题/gi思路/gi：/w /x本例/nz的/ude1实质/gi是/vshi将/d一个/mq二进制/gi矩阵/gi从/p一种/nz形式/gi利用/v相应/vi规则/gi变换/gi到/v另一种/nz形式/gi。/w提供/v的/ude1规则/gi有/vyou两/nz种/q：/w /x（/w1/nz）/w将/d某/rz一行/n的/ude1金币/n翻转/gi；/w /x（/w2/nz）/w将/d某/rz两/nz列/v进行/vn交换/gi。/w在/p这/rzv两/nz种/q操作/gi中/f，/w第一/mq种/q操作/gi可能会/nz影响/gi到/v某/rz一行/n或者/c某/rz一列中/nz已经/d排列/gi好/a的/ude1相关/vn元素/gi，/w因此/c，/w首先/d利用/v该/rz规则/gi进行/vn变换/gi，/w而/cc后续/vn的/ude1操作/gi则/d不再/d利用/v该/rz规则/gi。/w算法/gi的/ude1具体/a思路/gi如下/vi：/w（/w1/nz）/w将/d矩阵/gi中的/v每/rz一/nz列/v作为/p第/mq1/nz列/v，/w并/cc利用/v第一个/gi规则/gi将第/nz1/nz列/v中的/v相关/vn元素/gi与/cc目标/gi矩阵/gi中第/nz1/nz列/v的/ude1元素/gi进行/vn配对/vi，/w如果/c不/d相同/a，/w则/d利用/v每/rz1/nz个/q规则/gi进行/vn翻转/gi；/w（/w2/nz）/w从第/nz2/nz列/v开始/v，/w将/d处理/vn后/f的/ude1列/v与/cc目标/gi列/v进行/vn比较/gi，/w如果/c相同/a，/w则/d转下/v一列/nz；/w如果/c不/d相同/a，/w看/v是否/v可以/v通过/p列/v的/ude1交换/gi完成/v，/w如果/c不/d可以/v，/w则/d无法/v做到/v，/w如果/c可以/v，/w则/d继续/v扫描/gi，/w直至/v所有/b的/ude1列/v描述/gi完成/v为止/u。/w参考/gi代码/gi：/w