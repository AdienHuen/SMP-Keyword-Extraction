#java /nz网络/gi编程-/nz（/w1/nz）/w引入/v网络编程/gi
网络编程/gi现在/t是/vshi非常/d普遍/ad的/ude1编程技术/nz了/ule，/w网络编程/gi无非/d就是/v两/nz台/q或者/c多/a台/q设备/gi（/w通常/d是/vshi计算机/gi）/w之间/f的/ude1相互/d通信/gi，/w相互之间/bl的/ude1数据传输/gi。/w网络编程/gi的/ude1实质/gi其实/d就是/v程序/gi和/cc程序/gi之间/f的/ude1相互/d通信/gi，/w相互/d传递数据/n。/w在/p网络通信/gi中/f，/w第一次/nz主动/ad发起/v通信/gi请求/gi的/ude1成为/v客户端/gi（/wclient/nz）/w，/w第一次/nz通信/gi中/f等待/gi连接/gi的/ude1称为/v服务器端/gi（/wserver/gi）/w，/w在/p网络通信/gi的/ude1过程/gi中/f，/wclient/nz端/v和/ccserver/gi端/v没有/v本质/n的/ude1区别/gi。/w那么/c，/w怎样才能/nz通过/p客户端/gi找到/v服务器/gi从而/c进行/vn网络通信/gi呢/y？/w答案/gi就是/v通过/pip/gi来/vf找到/v服务器/gi，/w我们/rr都/d知道/v，/w服务器/gi上/f运行/gi着/uzhe多/a个/q程序/gi，/w也/d就是/v多/a个/q进程/gi，/w那么/c这/rzv是/vshi就要/d通过/p端口号/n来/vf唯一/b的/ude1确定/v某/rz台/q服务器/gi上/f的/ude1某个/rz运行/gi的/ude1程序/gi了/ule，/w式/k为/p“/wip/gi:/wport/nz”/w，/w因此/c，/w当/p你/rr在/p浏览器/gi（/w客户端/gi）/w中/f输入/vip/gi:/wport/nz后/f，/w就/d会/v发送/gi请求/gi，/w服务器/gi响应/v后/f返回/v结果/n给/p浏览器/gi，/w你/rr就/d可以/v看到/v内容/gi了/ule。/w但是/c，/wip/gi:/wport/nz很难/d记忆/n，/w这/rzv是/vshi就/d出现/v了/ule域名/gi的/ude1概念/gi，/w如/v：/w当/p你/rr输入/vwww/nz./nzbaidu/nz./nzcom/nz的/ude1时候/n，/w就/d会/v跳转/vi到/v百度/ntc的/ude1服务器/gi，/w你/rr会/v看到/v百度/ntc的/ude1首页/gi，/w但/c实际上/d还是/c通过/pip/gi:/wport/nz来/vf访问/gi服务器/gi的/ude1，/w你/rr可以/v输入/v103.235.46.39/nz:/w80/nz看/v一/nz下/f，/w会/v和/cc你/rr输入/vwww/nz./nzbaidu/nz./nzcom/nz的/ude1结果/n一样/uyy。/w那么/c，/w是/vshi怎样/ryv将/d一个/mq域名解析/gi成/v指定/v的/ude1ip/gi:/wport/nz呢/y，/w这时/rzt就/d会/v存在/v一个/mqdns/nz服务器/gi（/w域名解析/gi服务器/gi）/w，/w用来/v动态/gi的/ude1讲/v域名解析/gi到/v指定/v的/ude1服务器/gi上/f某/rz一个/mq运行/gi的/ude1程序/gi，/w以/p实现/gi客户端/gi和/cc服务器之间/n的/ude1互联/vi。/w在/p网络通信/gi的/ude1过程/gi中/f，/w最/d常见/a的/ude1通信模型/n就是/v“/w请求-相应/nz”模型/nz，/w也/d就是说/c，/w客户端/gi发/v一个/mq请求/gi，/w服务器端/gi接收/gi到/v请求/gi处理/vn后/f响应/v给/p客户端/gi的/ude1过程/gi。/w那么/c现在/t问题/gi来/vf了/ule，/w客户端/gi怎样/ryv发送/gi一个/mq请求/gi，/w服务器/gi成功/a接收/gi处理/vn后/f，/w响应/v给/p客户端/gi呢/y，/w这时/rzt，/w就/d需要/v网络协议/nz了/ule。/w协议/gi，/w顾名思义/vl就是/v客户端/gi和/cc服务器之间/n的/ude1约定/v，/w按照/p约定/v的/ude1请求/gi数据式/nz和/cc响应/v数据式/nz来/vf实现/gi网络通信/gi，/w显然/ad，/w这种/r约定/v应该/v遵循/gi“/w简单/a，/w方便/a，/w实用/a”/w的/ude1原则/gi，/w这样/rzv才能/n保证/v客户端/gi和/cc服务器端/gi通信/gi的/ude1成功率/n。/w其实/d，/w协议/gi就/d可以/v随意/ad编写/gi的/ude1，/w只要/c按照/p编写/gi的/ude1协议/gi式/k能够/v生成/v唯一/b的/ude1编码/gi，/w按照/p该/rz编码/gi可以/v唯一/b的/ude1解析/gi出/vf发送数据/n的/ude1内容/gi就/d可以/v了/ule。/w正/d因为/c各个/rz网络/gi程序/gi之间/f协议/gi式/k的/ude1不同/a，/w所以/c客户端程序/n都/d是/vshi专用/gi的/ude1、/w特殊/a的/ude1结构/gi。/w实际/n的/ude1网络编程/gi中/f，/w基本/a就是/v发送/gi（/wsend/nz）/w和/cc接收/gi（/waccept/nz）/w两/nz个/q操作/gi。/w大多/d数/n支持/v网络/gi编程技术/nz的/ude1编程语言/gi，/w都/d有/vyou特定/b的/ude1api/gi，/w内部/f封装/gi了/ule这/rzv两/nz个/q操作/gi的/ude1接口/gi，/w编程/gi的/ude1时候/n直接/ad调用/gi就/d可以/v了/ule。/w其实/d，/w网络编程/gi中/f最难/a的/ude1就是/v网络协议/nz的/ude1设计/gi，/w这/rzv是/vshi网络编程/gi中/f最/d核心/n的/ude1内容/gi，/w有兴趣/v的/ude1可以/v研究/gi下/frfc/nz原理/gi。/w