#设计模式/nz04/nz_/nz抽象工厂模式/gi
本文/r是/vshi在/p学习/gi中的/v总结/gi，/w欢迎/v转载/v但/c请/v注明/v出处/n：/w抽象工厂模式/gi是/vshi对象/gi的/ude1创建/gi模式/gi，/w它/rr是/vshi工厂方法模式/gi的/ude1进一步/d推广/gi。/w抽象工厂模式/gi与/cc工厂方法模式/gi的/ude1最大/gm区别/gi就/d在于/v工厂方法模式/gi针对/gi的/ude1是/vshi一个/mq产品/gi等级/n结构/gi；/w而/cc抽象工厂模式/gi则/d需要/v面对/v多/a个/q产品/gi等级/n结构/gi。/w假设/gi一个子/nz系统/gi需要/v一/nz些/q产品/gi对象/gi，/w而/cc这些/rz产品/gi又/d属于/v一个/mq以上/f的/ude1产品/gi等级/n结构/gi。/w那么/c为了/p将/d消费/vn这些/rz产品/gi对象/gi的/ude1责任/n和/cc创建/gi这些/rz产品/gi对象/gi的/ude1责任/n分割/gi开来/v，/w可以/v引进/v抽象工厂模式/gi。/w这样的话/l，/w消费/vn产品/gi的/ude1一方/nz不/d需要/v直接参与/nz产品/gi的/ude1创建/gi工作/gi，/w而/cc只/d需要/v向/p一个/mq公用/gi的/ude1工厂/gi接口/gi请求/gi所/usuo需要/v的/ude1产品/gi。/w优点/gi:/w（/w1/nz）/w分离/vi接口/gi和/cc实现/gi　　/nz客户端/gi使用/gi抽象工厂/gi来/vf创建/gi需要/v的/ude1对象/gi，/w而/cc客户端/gi根本/a就/d不/d知道/v具体/a的/ude1实现/gi是/vshi谁/ry，/w客户端/gi只是/d面向/v产品/gi的/ude1接口/gi编程/gi而已/y。/w也/d就是说/c，/w客户端/gi从/p具体/a的/ude1产品/gi实现/gi中/f解耦/gi。/w（/w2/nz）/w使/v切换/vn产品/gi族/ng变得/vi容易/ad　　/nz因为/c一个/mq具体/a的/ude1工厂/gi实现/gi代表/nnt的/ude1是/vshi一个/mq产品/gi族/ng，/w比如/v上面/f例子/gi的/ude1从/pa/nz产品/gi到/vb/nz产品/gi只/d需要/v切换/vn一/nz下/f具体/a工厂/gi。/w缺点/gi:/w（/w1/nz）/w不/d太/d容易/ad扩展/gi新的/a产品/gi　　/nz如果/c需要/v给/p整个/b产品/gi族/ng添加/gi一个/mq新的/a产品/gi，/w那么/c就/d需要/v修改/gi抽象工厂/gi，/w这样/rzv就/d会/v导致/gi修改/gi所有/b的/ude1工厂/gi实现/gi类/gi。/w通过/p下面/f代码/gi来/vf熟悉/v抽象工厂模式/gi：/w不同/a的/ude1抽象工厂/gi：/w不同/a的/ude1具体/a工厂/gi：/w定义/gi不同/a的/ude1产品/gi接口/gi：/w不同/a的/ude1具体/a产品/gi：/w客户端/gi实现/gi：/w测试/gi结果/n：/wa/nz1/nz产品/gi生产/gia/nz1/nzb/nz1/nz生产/gi产品/gib/nz1/nz