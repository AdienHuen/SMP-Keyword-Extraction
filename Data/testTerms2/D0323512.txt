#什么/ry叫/vi三次/nz握手/vi？/w什么/ry叫/vi四次/nz断开/gi？/w
为了/p提供/v可靠/a的/ude1传送/v，/wtcp/gi在/p发送/gi新的/a之前/f，/w以/p特定/b的/ude1顺序/gi将/d数据包/gi的/ude1序号/n，/w并/cc需要/v这些/rz包/v传送/v给/p目标/gi机/ng之后/f的/ude1确认/v消息/n。/wtcp/gi总是/d用来/v发送/gi大批量/d的/ude1。/w当/p在/p收到/v后/f要/v做出/v确认/v时/qt也/d要用/v到/vtcp/gi。/w在/ptcp/ip/gi中/f，/w采用/v三次/nz握手/vi来/vf建立/gi一次/nz连接/gi。/w第一次/nz握手/vi：/w建立/gi连接/gi时/qt，/w发送包/nz（/wsyn/nz=/nzj/nz）/w到/v，/w并/cc进入状态/n，/w等待/gi服务器/gi确认/v；/wsyn/nz：/w同步序列/l编号/gi（/wsynchronize sequence numbers/nz）/w。/w：/w收到/v包/v，/w必须/d确认/v客户/n的/ude1syn/nz（/w=/nzj/nz1/nz）/w，/w同时/c自己/rr也/d发送/gi一个/mqsyn/nz包/v（/wsyn/nz=/nzk/nz）/w，/w即/vsynack/nz包/v，/w此时/r服务器/gi进入状态/n；/w第三次/nz握手/vi：/w收到/v器/ng的/ude1synack/nz包/v，/w向/p发送/gi确认/v包/vack/nz(/nz=/nzk/nz1/nz）/w，/w此/rzs包/v发送/gi完毕/vi，/w客户端/gi和/cc服务器/gi进入/v（/wtcp/gi连接/gi成功/a）/w状态/gi，/w两者/rzv可以/v进行/vn数据交换/nz了/ule，/w完成/v三次/nz握手/vi。/w由于/ptcp/gi连接/gi是/vshi全双工/nz的/ude1，/w因此/c每个/r方向/gi都/d必须/d单独/d进行/vn关闭/gi。/w这/rzv原则/gi是/vshi当/p一方/nz完成/v它/rr的/ude1数据/gi发送/gi任务/gi后/f就/d能/v发送/gi一个/mqfin/nz来/vf终止/v这个/rz方向/gi的/ude1连接/gi。/w收到/v一个/mq fin/nz只/d意味着/v这/rzv一方/nz向上/vi没有/v数据/gi流动/vn，/w一个/mqtcp/gi连接/gi在/p收到/v一个/mqfin/nz后/f仍/d能/v发送数据/n。/w首先/d进行/vn关闭/gi的/ude1一方/nz将/d执行/v主动/ad关闭/gi，/w而/cc另一方/nz执行/v被动/a关闭/gi。/w四次/nz断开/gi过程/gi如下/vi：/w（/w1/nz）/w tcp/nz客户端/gi发送/gi一个/mqfin/nz，/w用来/v关闭/gi客户/n到/v服务器/gi的/ude1数据/gi传送/v，/w提出/v断开连接/i要求/n。/w（/w2/nz）/w /x服务器/gi收到/v这个/rzfin/nz，/w它/rr发回/v一个/mqack/nz，/w确认/v序号/n为/p收到/v的/ude1序号/n加/v1。/nz和/ccsyn/nz一样/uyy，/w一个/mqfin/nz将/d占用/v一个/mq序号/n。/w确定/v这/rzv一方/nz连接/gi将/d关闭/gi。/w（/w3/nz）/w /x服务器/gi关闭/gi客户端/gi的/ude1连接/gi，/w发送/gi一个/mqfin/nz给/p客户端/gi，/w请求/gi关闭/gi连接/gi。/w（/w4/nz）/w /x客户端/gi发回/vack/nz报文/n确认/v，/w并/cc将/d确认/v序号/n设置/gi为/p收到/v序号/n加/v1。/nz采用/v三次/nz握手/vi是/vshi为了/p防止/gi失效/vi的/ude1连接/gi请求/gi报/n文段/n突然/ad又/d传送/v到/v服务器端/gi，/w因而/c产生/v错误/gi。/w在/p第四步/nz时/qt，/w为什么/ryv需要/vtime/nz_/nzwait/nz?/nzhost/nz1/nz发送/gi的/ude1ack/nz可能/v丢失/v并/cc导致/gihost/nz2/nz重新/d发送/gifin/nz消息/n，/wtime/nz_/nzwait/nz维护/gi连接/gi状态/gi。/w如果/c执行/v主动/ad关闭/gi的/ude1一方/nzhost/nz1/nz不/d进入/v到/vtime/nz_/nzwait/nz状态/gi就/d关闭/gi连接/gi，/w当/p重传/gi的/ude1fin/nz消息/n到达/v时/qt，/w因为/ctcp/gi已经/d不再/d有/vyou连接/gi的/ude1信息/gi了/ule，/w所以/c就/d用/prst/nz（/w重新启动/gi）/w消息/n应答/gi，/w导致/gihost/nz2/nz进入/v到/v错误/gi的/ude1状态/gi而/cc不是/c有序/gi终止/v状态/gi。/w如果/c发送/gi最后/fack/nz消息/n的/ude1一方/nz处于/vtime/nz_/nzwait/nz状态/gi并/cc仍然/d记录/gi着/uzhe连接/gi的/ude1信息/gi，/w它/rr就/d可以/v正确地/nz响应/v对等/vn方/qhost/nz2/nz的/ude1fin/nz消息/n了/ule。/w其次/c，/wtime/nz_/nzwait/nz为/p连接/gi中/f“离群/nz的/ude1段/q“/w提供/v从/p网络/gi中/f消息/n的/ude1时间/gi。/w引申/vi：/w为什么/ryv建立/gi连接/gi是/vshi三次/nz握手/vi，/w而/cc关闭/gi连接/gi却是/d四次/nz握手/vi？/w因为/c服务端/nz的/ude1listen/nz状态/gi下/f的/ude1socket/gi收到/vsyn/nz报文/n的/ude1建立/gi连接/gi请求/gi后/f，/w它/rr可以/v把/pbaack/nz和/ccsyn/nz放在/v一个/mq报文/n里/f发送/gi。/w但/c关闭/gi连接/gi时/qt，/w当/p收到/v对方/n的/ude1fin/nz报文/n通知/gi时/qt，/w它/rr仅仅/d表示/v对方/n没有/v数据/gi发给你/l了/ule，/w但/c未必/d你/rr所有/b的/ude1数据/gi都/d已经/d发给/v对方/n了/ule，/w所以/c你/rr未必/d会/v马上/d关闭/gisocket/gi，/w也/d即/v你/rr可能/v还/d需要/v发送/gi一/nz些/q数据/gi给/p对方/n之后/f，/w再/d发送/gifin/nz报文/n给/p对方/n同意/v现在/t可以/v关闭/gi连接/gi了/ule，/w所以/c这里/rzs的/ude1ack/nz和/ccfin/nz报文/n多数/a情况下/nz都/d是/vshi分开/vi发送/gi的/ude1。/w