#交换/gi相邻/vi法/n（/w2/nz）/w
通过/p上篇/b文章/gi可以/v看到/v，/w如果/c想要/v生成/v{/nz1/nz,/nz2...../nz,/nzn/nz}/nz的/ude1全排列/gi，/w那么/c在/p生成/v的/ude1过程/gi中/f我们/rr需要/v将/d{/nz1/nz}/nz /x{/nz1/nz,/nz2/nz}/nz /x{/nz1/nz,/nz2/nz,/nz3/nz}/nz /x....../w /x{/nz1/nz,/nz2/nz,/nz3...../nzn/nz}/nz的/ude1排列/gi进行/vn保存/gi。/w那么/c如何/ryv才能/n做到/v，/w排列/gi覆盖/gi当前/t排列/gi而/cc不必/d保留/v所有/b排列/gi呢/y？/weven /nz给出/v一种/nz描述/gi如下/vi：/w生成/v{/nz1/nz,/nz2/nz,/nz.../w./nz./nzn/nz}/nz的/ude1排列/gi算法/gi从/p1/nz,/nz2/nz,/nz3/nz，/wn/nz开始/v（/w---/nz /x每/rz一个/mq数字/gi都/d需要/v加上/v方向/gi）/w可移动/nz：/w当/p数字/gi指向/v方向/gi上/f的/ude1相邻/vi数字/gi比/p该/rz数字/gi小时/n那么/c表示/v该/rz数字/gi可以/v移动/vn。/w当然/d当/p处于/v集合/gi开始/v，/w或者/c结尾/n，/w并且/c方向/gi是/vshi向左/d或者/c向右/d时/qt是/vshi不可/v移动/vn的/ude1。/w（/w1/nz）/w求出/v最大/gm的/ude1可移动/nz整数/gim/nz（/w2/nz）/w交换/gim/nz和/cc它/rr的/ude1箭头/n所指/n的/ude1方向/gi的/ude1与/cc它/rr相邻/vi的/ude1整数/gi（/w3/nz）/w交换/gi所有/b满足/vpm/nz的/ude1整数/gip/nz上/f的/ude1箭头/n的/ude1方向/gi。/w（/wm/nz经过/p交换/gi后/f变成/v不可/v移动/vn，/w然后/c找到/v次/qv大/a来/vf代替/vm/nz，/w此时/r将/dm/nz重新/d赋/ng，/w那么/c必然/d有/vyou原始/a的/ude1大于/v当前/tm/nz此/rzs整数/gi便是/vp/nz)/nz