#基于/pRedis Lua/nz脚本/gi实现/gi的/ude1分布式锁/nz
最近/t项目/gi中/f需要/v用/p到/v一个/mq分布式/gi的/ude1锁/v，/w考虑到/v基于/p会话/v节点/gi实现/gi的/ude1zookeeper/nz锁/v性能/gi不够/a，/w于是/cc想/v使用/giredis/gi来/vf实现/gi一个/mq分布式/gi的/ude1锁/v。/w简单/a的/ude1说/v，/w锁/v是/vshi一个/mq单一/gi的/ude1参考点/nz，/w多/a个/q线程/gi基于/p它/rr来/vf检查/gi是否/v允许/v访问/gi资源/gi。/w例如/v，/w一个/mq想/v写/v数据/gi的/ude1线程/gi，/w它/rr必须/d先/d检查/gi是否/v存在/v一个/mq写锁/nz。/w如果/c写/v锁/v存在/v，/w需要/v等待/gi直到/v锁/v释放/gi后/f它/rr才能/n获取/gi到/v属于/v它/rr的/ude1锁/v并/cc执行/v写/v操作/gi。/w这样/rzv，/w通过/p锁/v就/d可以/v避免/v多/a个/q线程/gi的/ude1同时/c写/v造成/v的/ude1数据/gi冲突/gi。/w现代/ntc的/ude1操作系统/gi提供/v了/ule内置/vn的/ude1函数/gi来/vf帮助/v程序员/gi实现/gi并发/gi控制/vn，/w例如/v flock /nz函数/gi。/w但是/c如果/c多线程/gi的/ude1程序运行/n在/p多/a台/q机器/gi上/f呢/y？/w如何/ryv在/p分布式系统/gi下/f控制/vn对/p资源/gi的/ude1访问/gi呢/y？/w使用/gi一个/mq中心化/j的/ude1锁/v服务/gi首先/d，/w我们/rr需要/v一个/mq所有/b线程/gi都/d可以/v访问/gi到/v的/ude1地方/n来/vf存储锁/nz。/w这个/rz锁/v只能/v存在/v于/p一个/mq地方/n，/w从而/c保证/v只有/c一个/mq权威/n的/ude1地方/n可以/v定义/gi锁/v的/ude1建立/gi和/cc释放/gi。/wredis/gi是/vshi实现/gi锁/v的/ude1一个/mq理想/n的/ude1候选/b方案/gi。/w作为/p一个/mq轻量级/gi的/ude1内存数据库/gi，/w快速/d，/w事务性/n和/cc一致性/gi是/vshi选择/giredis/gi作为/p锁/v服务/gi的/ude1主要/b原因/n。/w设计/gi锁锁/nz本身/rz是/vshi很/d简单/a的/ude1，/w就是/vredis/gi数据库/gi中/f一个/mq简单/a的/ude1key/gi。/w建立/gi和/cc释放/gi锁/v，/w并/cc保证/v绝对/d的/ude1安全/gi，/w是/vshi这个/rz锁/v的/ude1设计/gi比较/gi棘手/a的/ude1地方/n。/w有/vyou两/nz个/q潜在/b的/ude1陷阱/gi：/w1/nz）/w、/w应用程序/nz通过/p网络/gi和/ccredis/gi交互/gi，/w这/rzv意味着/v从/p应用程序/nz发出/v命令/gi到/vredis/gi结果/n返回/v之间/f会/v有/vyou延迟/v。/w这段/r时间/gi内/f，/wredis/gi可能/v正在/d运行/gi其他/rzv的/ude1命令/gi，/w而/ccredis/gi内/f数据/gi的/ude1状态/gi可能/v不是/c你/rr的/ude1程序/gi所/usuo期待/v的/ude1。/w如何/ryv保证/v程序/gi中/f获取/gi锁/v的/ude1线程/gi和/cc其他/rzv线程/gi不/d发生冲突/n？/w2/nz）/w、/w如果/c程序/gi在/p获取/gi锁/v后/f突然/adcrash/nz，/w而/cc无法/v释放/gi它/rr？/w这个/rz锁/v会/v一直/d存在/v而/cc导致/gi程序/gi进入/v“/w饿死/vi”/w（/w原文/n成为/v“死/nz锁”/nz，/w感觉/gi不/d太/d准确/a）/w。/w建立/gi锁/v可能/v想到/v的/ude1最简单/nz的/ude1方法/gi是/vshi“/w用/pget/gi方法/gi检查/gi锁/v，/w如果/c锁/v不存在/ns，/w就/d用/pset/nz方式/n设置/gi一个/mq”/w。/w这个/rz方法/gi虽然/c简单/a，/w但是/c不能/v保证/v独占锁/nz。/w回顾/v前面/f所说/c的/ude1第/mq1/nz个/q陷阱/gi：/w因为/c在/pget/gi和/ccset/nz操作/gi之间/f有/vyou延迟/v，/w我们/rr没法/v知道/v从/p“/w发送/gi命令/gi”/w到/v“/wredis/gi服务器返回/n结果/n”/w之间/f的/ude1这段/r时间/gi内/f是否/v有/vyou其他/rzv线程/gi也/d去/vf建立/gi锁/v。/w当然/d，/w这些/rz都/d在/p几/d毫秒/q之内/f，/w发生/v的/ude1可能性/gi相当/d低/a。/w但是/c如果/c在/p一个/mq繁忙/a的/ude1环境中运行/nt着/uzhe大量/m的/ude1并发/gi线程/gi和/cc命令/gi，/w重叠/vi的/ude1可能性/gi并/cc不是/c微不足道/vl的/ude1。/w为了/p解决/v这个/rz问题/gi，/w应该/v用/psetnx/nz命令/gi。/wsetnx/nz消除/v了/uleget/gi命令/gi需要/v等待/gi返回/v得/ude3问题/gi，/wsetnx/nz只有/c在/pkey/gi不存在/ns时/qt才/d返回/v成功/a。/w这/rzv意味着/v只有/c一个/mq线程/gi可以/v运行/gisetnx/nz命令/gi，/w而/cc其他/rzv线程/gi会/v失败/vi，/w然后/c不断/d重试/gi，/w直到/v它们/rr能/v建立/gi锁/v。/w释放/gi锁/v一旦/d线程/gi成功/a执行/v了/ulesetnx/nz命令/gi，/w它/rr就/d建立/gi了/ule锁/v并且/c可以/v基于/p资源/gi进行/vn工作/gi。/w工作/gi完成/v后/f，/w线程/gi需要/v通过/p删除/giredis/gi的/ude1key/gi来/vf释放/gi这个/rz锁/v，/w从而/c允许/v其他/rzv线程/gi能/v尽快/d的/ude1获取/gi锁/v。/w尽管如此/dl，/w也/d有/vyou需要/v小心/a的/ude1地方/n！/w回顾/v前面/f说/v的/ude1第/mq2/nz个/q陷阱/gi：/w如果/c线程/gicrash/nz了/ule，/w它/rr永远/d都/d不会/v删除/giredis/gi的/ude1key/gi，/w所以/c这个/rz锁/v会/v一直/d存在/v，/w从而/c导致/gi“/w饿死/vi”/w现象/n。/w那么/c如何/ryv避免/v这个/rz问题/gi呢/y？/w锁/v的/ude1存活/vi时间/gi我们/rr可以/v给/p锁/v加/v一个/mq存活/vi时间/gi（/wttl/nz）/w，/w这样/rzv一旦/dttl/nz超时/v，/w这个/rz锁/v的/ude1key/gi会/v被/pbeiredis/gi自动/d删除/gi。/w任何/rz由于/p线程/gi错误/gi而/cc遗留下来/l的/ude1锁/v在/p一个/mq合适/a的/ude1时间/gi之后/f都会/n被/pbei释放/gi，/w从而/c避免/v了/ule“/w饿死/vi”/w。/w这/rzv存粹/nz是/vshi一个/mq安全/gi特性/gi，/w更/d有效/gi的/ude1方式/n仍然/d是/vshi确保/v尽量/d在线/vn程/n里面/f释放/gi锁/v。/w可以/v通过/ppexpire/nz命令/gi为/predis/gi的/ude1key/gi设置/gittl/nz，/w而且/c线程/gi里/f可以/v通过/pmulti/nz//nzexec/nz事物/n的/ude1方式/n在/psetnx/nz命令/gi后/f立即/d执行/v，/w例如/v：/w尽管如此/dl，/w这/rzv会/v产生/v另外/c一个/mq问题/gi。/wpexpire/nz命令/gi没有/v判断/gisetnx/nz命令/gi的/ude1返回/v结果/n，/w无论如何/dl都会/n设置/gikey/gi的/ude1ttl/nz。/w如果/c这个/rz地方/n无法/v获取/gi到/v锁/v或有/c异常/gi，/w那么/c多/a个/q线程/gi每次/r想/v获取/gi锁/v时/qt，/w都会/n频繁/a更新/gikey/gi的/ude1ttl/nz，/w这样/rzv会/v一直/d延长/vkey/gi的/ude1ttl/nz，/w导致/gikey/gi永远/d都/d不会/v过期/gi。/w为了/p解决/v这个/rz问题/gi，/w我们/rr需要/vredis/gi在/p一个/mq命令/gi里面/f处理/vn这个/rz逻辑/n。/w我们/rr可以/v通过/predis/gi脚本/gi的/ude1方式/n来/vf实现/gi。/w注意-如果/nz不/d采用/v脚本/gi的/ude1方式/n来/vf实现/gi，/w可以/v使用/giredis /nz2.6.12/nz之后/f版本/n命令/gi的/ude1px/nz和/ccnx/nz参数/gi来/vf实现/gi。/w为了/p考虑/v兼容/vi2.6.0/nz之前/f的/ude1版本/n，/w我们/rr还是/c采用/v脚本/gi的/ude1方式/n来/vf实现/gi。/wredis/gi脚本/gi由于/predis/gi支持/v脚本/gi，/w我们/rr可以/v写/v一个/mqlua/nz脚本/gi在/predis/gi服务端/nz运行/gi多/a个/qredis/gi命令/gi。/w应用程序/nz通过/p一条/nzeval sha/nz命令/gi就/d可以/v调用/gi被/pbeiredis/gi服务端/nz缓存/gi的/ude1脚本/gi。/w这里/rzs强大/a的/ude1地方/n在于/v你/rr的/ude1程序/gi只/d需要/v运行/gi一条/nz命令/gi（/w脚本/gi）/w就/d可以/v以/p事物/n的/ude1方式/n运行/gi多/a个/qredis/gi命令/gi，/w还/d能避免/nz并发/gi冲突/gi，/w因为/c一个/mqredis/gi脚本/gi同一/b时刻/n只能/v运行/gi一次/nz。/w这/rzv是/vshiredis/gi里面/f一个/mq设置/gi带/vttl/nz的/ude1锁/v的/ude1lua/nz脚本/gi：/w还/d缺少/v一个/mq释放/gi锁/v的/ude1脚本/gi，/w如果/c一直/d依赖/vttl/nz来/vf释放/gi锁/v，/w效率/gi会/v很低/d。/wredis/gi的/ude1set/nz操作/gi文档/gi就/d提供/v了/ule一个/mq释放/gi锁/v的/ude1脚本/gi：/w应用程序/nz中/f只要/c加锁/gi的/ude1时候/n指定/v一个/mq随机/b数/n或/c特定/b的/ude1value/nz作为/pkey/gi的/ude1，/w解锁/gi的/ude1时候/n用/p这个/rzvalue/nz去/vf解锁/gi就/d可以/v了/ule。/w当然/d，/w每次/r加锁/gi时/qt的/ude1value/nz必须/d要/v保证/v是/vshi唯一/b的/ude1。/w