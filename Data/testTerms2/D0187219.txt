#什么/ry是/vshi垃圾/n回收/vn
乍一看/l，/w垃圾/n回收/vn所/usuo做/v的/ude1事情/n应当/v恰如/v其/rz名/q―/w―/w查找/gi并/cc清除/v垃圾/n。/w事实上/bl却/d恰恰相反/c。/w垃圾/n回收/vn会/v跟踪/vn所有/b仍/d在/p使用/gi的/ude1对象/gi，/w然后/c将/d剩余/vn的/ude1对象/gi标记/gi为/p垃圾/n。/w牢记/v了/ule这/rzv点/gi之后/f，/w我们/rr再来/d深入/ad地/ude2了解/v下/f这个/rz被/pbei称为/v“/w垃圾/n回收/vn”/w的/ude1自动化/gi内存/gi回收/vn在/p中/f到底/d是/vshi如何/ryv实现/gi的/ude1。/w手动/b管理/gi内存/gi在/p介绍/gi现代版/vn的/ude1垃圾/n回收/vn之前/f，/w我们/rr先/d来/vf简单/a地/ude2回顾/v下/f需要/v手动/b地/ude2显式/nz分配/gi及/cc释放/gi内存/gi的/ude1那些/rz日子/n。/w如果/c你/rr忘了/v去/vf释放/gi内存/gi，/w那么/c这块/r内存/gi就/d无法/v重用/gi了/ule。/w这块/r内存/gi被/pbei占有/v了却/v没/d被/pbei使用/gi。/w这种/r场景/gi被/pbei称之为/v内存/gi泄露/gi。/w下面/f是/vshi用/p写/v的/ude1一个/mq手动/b管理/gi内存/gi的/ude1简单/a例子/gi：/w可以/v看到/v，/w你/rr很容易/nz就/d会/v忘了/v释放/gi内存/gi。/w内存/gi泄露/gi曾经/d是/vshi个/q非常/d普遍/ad的/ude1问题/gi。/w你/rr只能/v通过/p不断/d地/ude2修复/gi自己/rr的/ude1代码/gi来/vf与/cc它们/rr进行/vn抗争/vi。/w因此/c，/w需要/v有/vyou一种/nz更/d优雅/a的/ude1方式/n来/vf自动/d释放/gi无用/vi内存/gi，/w以便/d减少/v人/n为/p错误/gi的/ude1可能性/gi。/w这种/r自动化/gi过程/gi又/d被/pbei称为/v垃圾/n回收/vn（/w简称/v）/w。/w智能指针/gi自动/d垃圾/n回收/vn早期/f的/ude1一种/nz实现/gi便是/v引用/gi计数/vi。/w你/rr知晓/v每一个/nz对象/gi被/pbei引用/gi了/ule几次/nz，/w当/p计数器/gi归/v的/ude1时候/n，/w这个/rz对象/gi就/d可以/v被/pbei安全/gi地/ude2回收/vn掉/v了/ule。/w的/ude1共享/gi指针/gi就是/v一个/mq非常/d著名/a的/ude1例子/gi：/w我们/rr使用/gi的/ude1会/v记录/gi这个/rz对象/gi被/pbei引用/gi的/ude1次数/gi。/w如果/c你/rr将/d它/rr传递/v给/p别人/rr则/d计数/vi加/v一/nz，/w当/p它/rr离开了/v作用域/gi后/f便/d会/v减/v一/nz。/w一旦/d这个/rz计数/vi为/p，/w会/v自动/d地/ude2删除/gi底层/n对应/vi的/ude1。/w当然/d这/rzv只是/d个/q示例/gi，/w因为/c也/d有/vyou读者/n指/v出来/vf了/ule，/w这个/rz在/p现实/n中/f是/vshi不太可能/i出现/v的/ude1，/w但/c作为/p演示/gi是/vshi足够/v了/ule。/w自动/d内存/gi管理/gi在/p上面/f的/ude1代码/gi中/f，/w我们/rr还/d得/ude3显/v式/k地/ude2声明/gi我们/rr需要/v使用/gi内存/gi管理/gi。/w那/rzv如果/c所有/b的/ude1对象/gi都/d采用/v这个/rz机制/gi会/v怎样/ryv呢/y？/w那/rzv简直/d就/d太/d方便/a了/ule，/w这样/rzv开发人员/n便/d无需/v考虑/v清理/gi内存/gi的/ude1事情/n了/ule。/w运行/gi时会/n自动/d知晓/v哪些/ry内存/gi不再/d使用/gi了/ule，/w然后/c释放/gi掉/v它/rr。/w也/d就是说/c，/w它/rr自动/d地/ude2回收/vn了/ule这些/rz垃圾/n。/w第一代/nz的/ude1垃圾/n回收器/nz是/vshi年/qt引入/v的/ude1，/w这项/r技术/gi迄今为止/dl一直/d在/p不断/d演进/vn。/w引用/gi计数/vi刚才/t我们/rr用/p的/ude1共享/gi指针/gi所/usuo演示/gi的/ude1想法/gi可以/v应用/gi到/v所有/b的/ude1对象/gi上来/vf。/w许多语言/nz比如说/vl,/nz /x以及/cc，/w采用/v的/ude1都/d是/vshi这种/r方式/n。/w这个/rz通过/p一/nz张/q图/gi可以/v很容易/nz说明/v：/w绿色/n的/ude1云/gi代表/nnt的/ude1是/vshi程序/gi中/f仍/d在/p使用/gi的/ude1对象/gi。/w从/p技术/gi层面/n上/f来说/uls，/w这/rzv有点像/v是/vshi正在/d执行/v的/ude1某个/rz方法/gi里面/f的/ude1局部/n变量/gi，/w亦/d或/c是/vshi静态/gi变量/gi之类/rz的/ude1。/w不同/a编程语言/gi的/ude1情况/n可能会/nz不/d一样/uyy，/w因此/c这/rzv并/cc不是/c我们/rr关注/v的/ude1重点/n。/w蓝色/n的/ude1圆圈/n代表/nnt的/ude1是/vshi内存/gi中的/v对象/gi，/w可以/v看到/v有/vyou多少/ry对象/gi引用/gi了/ule它们/rr。/w灰色/n圆圈/n的/ude1对象/gi是/vshi已经/d没有/v任何人/r引用/gi的/ude1了/ule。/w因此/c，/w它们/rr属于/v垃圾/n对象/gi，/w可以/v被/pbei垃圾/n回收器/nz清理/gi掉/v。/w看起来/v还/d不错/a对/p吧/y？/w没错/vi，/w不过/c这里/rzs存在/v着/uzhe一个/mq重大/a的/ude1缺陷/gi。/w很容易/nz会/v出现/v一/nz些/q孤立/a的/ude1环/n，/w它们/rr中的/v对象/gi都/d不在/v任何/rz域内/d，/w但/c彼此/rr却/d互相/d引用/gi导致/gi引用/gi数/n不为/c。/w下面/f便是/v一个/mq例子/gi：/w看到/v了/ule吧/y，/w红色/gi部分/n其实/d就是/v应用程序/nz不再/d使用/gi的/ude1垃圾/n对象/gi。/w由于/p引用/gi计数/vi的/ude1缺陷/gi，/w因此/c会/v存在/v内存/gi泄露/gi。/w有/vyou几/d种/q方法/gi可以/v解决/v这/rzv一/nz问题/gi，/w比如说/vl使用/gi特殊/a的/ude1“弱/nz”/w引用/gi，/w或者/c使用/gi一个/mq特殊/a的/ude1算法/gi回收/vn循环/gi引用/gi。/w之前/f提到/v的/ude1,/nz以及/cc等/udeng语言/gi，/w都/d是/vshi使用/gi类似/a的/ude1方法/gi来/vf回收/vn循环/gi引用/gi的/ude1，/w不过/c这/rzv已经/d超出/v本文/r讲述/v的/ude1范围/n了/ule。/w我们/rr准备/v详细介绍/gi下/f所/usuo采用/v的/ude1方法/gi。/w标记/gi删除/gi首先/d，/w对于/p对象/gi可达性/gi的/ude1定义/gi要/v明确/a一/nz些/q。/w它/rr可不/dl像/v前面/f那样/rzv用/p绿色/n的/ude1云/gi便/d含/v糊/v了事/vi的/ude1，/w而是/c有着/v非常/d明确/a及/cc具体/a的/ude1垃圾/n回收/vn根/n对象/gi（/w）/w的/ude1定义/gi：/w局部/n变量/gi活动/gi线程/gi静态/gi字段/gi引用/gi其它/rz（/w后面/f将/d会/v讨论/gi到/v）/w通过/p标记/gi删除/gi的/ude1算法/gi来/vf记录/gi所有/b可达/nz（/w存活/vi）/w对象/gi，/w同时/c确保/v不/d可达/nz对象/gi的/ude1那些/rz内存/gi能够/v被/pbei重用/gi。/w这/rzv包含/v两/nz个/q步骤/gi：/w标记/gi是/vshi指/v遍历/gi所有/b可达/nz对象/gi，/w然后/c在/p本地/gi内存/gi中/f记录/gi这些/rz对象/gi的/ude1信息/gi删除/gi会/v确保/v不/d可达/nz对象/gi的/ude1内存地址/nz可以/v在下/r一次/nz内存/gi分配/gi中/f使用/gi。/w中的/v不同/a算法/gi，/w比如说/vl，/w，/w /x都/d是/vshi这/rzv一算法/nz的/ude1不同/a实现/gi，/w只是/d各/rz阶段/gi略有不同/i而已/y，/w从/p概念/gi上/f来讲/uls仍然/d是/vshi对应/vi着/uzhe上面/f所说/c的/ude1那/rzv两/nz个/q步骤/gi。/w这种/r实现/gi最重要/nz的/ude1就是/v不会/v再/d出现/v泄露/gi的/ude1对象/gi环/n了/ule：/w缺点/gi就是/v应用程序/nz的/ude1线程/gi需要/v被/pbei暂停/v才能/n完成/v回收/vn，/w如果/c引用/gi一直/d在/p变/v的话/udh你/rr是/vshi无法/v进行/vn计数/vi的/ude1。/w这个/rz应用程序/nz被/pbei暂停/v以便/d可以/v收拾/v家务/n的/ude1情况/n又/d被/pbei称为/v。/w这种/r暂停/v被/pbei触发/gi的/ude1可能性/gi有/vyou很/d多/a，/w不过/c垃圾/n回收/vn应该/v是/vshi最/d常见/a的/ude1一种/nz。/w