#程序员/gi面试/gi宝典/n(/nz19/nz)/nz－/w反转/gm链表/gi
题目/gi输入/v一个/mq链表/gi的/ude1头/n结点/gm，/w反转/gm该/rz链表/gi，/w并/cc返回/v反转/gm后/f链表/gi的/ude1头/n结点/gm。/w链表/gi结点/gm定义/gi如下/vi：/wstruct listnode /nz{/nz     int       m/nz_/nznkey/nz;/nz     listnode/nz*/nz m/nz_/nzpnext/nz;/nz /x}/nz;/nz分析/gi为了/p正确地/nz反转/gm一个/mq链表/gi，/w需要/v调整/vn指针/gi的/ude1指向/v。/w与/cc指针/gi操作/gi相关代码/gi总是/d容易/ad出错/gi的/ude1，/w因此/c最好/d在/p动手/gi写/v程序/gi之前/f作/v全面/ad的/ude1分析/gi。/w为了/p将/d调整/vn指针/gi这个/rz复杂/a的/ude1过程/gi分析/gi清楚/a，/w我们/rr可以/v借助/v图形/gi来/vf直观/a地/ude2分析/gi。/w假设/gi下图/n中/fl/nz、/wm/nz和/ccn/nz是/vshi三个/nz相邻/vi的/ude1结点/gm：/wa/nz?/nzb/nz?/nz…/w?/nzl m/nzà/nzn/nzà/nz…/w假设/gi经过/p若干/m操作/gi，/w我们/rr已经/d把/pba结点/gml/nz之前/f的/ude1指针/gi调整/vn完毕/vi，/w这些/rz结点/gm的/ude1m/nz_/nzpnext/nz指针/gi都/d指向/v前面/f一个/mq结点/gm。/w现在/t我们/rr遍历/gi到/v结点/gmm/nz。/w当然/d，/w我们/rr需要/v把/pba调整/vn结点/gm的/ude1m/nz_/nzpnext/nz指针/gi让/v它/rr指向/v结点/gml/nz。/w但/c注意/v一旦/d调整/vn了/ule指针/gi的/ude1指向/v，/w链表/gi就/d断开/gi了/ule，/w如下/vi图/gi所示/nz：/wa/nz?/nzb/nz?/nz…/wl/nz?/nzm  n/nzà/nz…/w因为/c已经/d没有/v指针/gi指向/v结点/gmn/nz，/w我们/rr没有/v办法/gi再/d遍历/gi到/v结点/gmn/nz了/ule。/w因此/c为了/p避免/v链表/gi断开/gi，/w我们/rr需要/v在/p调整/vnm/nz的/ude1m/nz_/nzpnext/nz之前/f要/v把/pban/nz保存/gi下来/vf。/w接下来/vl我们/rr试着/v找到/v反转/gm后/f链表/gi的/ude1头/n结点/gm。/w不难/d分析/gi出/vf反转/gm后/f链表/gi的/ude1头/n结点/gm是/vshi原始/a链表/gi的/ude1尾位/nz结点/gm。/w什么/ry结点/gm是/vshi尾结/nz点/gi？/w就是/vm/nz_/nzpnext/nz为/p空/ng指针/gi的/ude1结点/gm。/w基于/p上述/b分析/gi，/w我们/rr不难/d写出/v如下/vi代码/gi（/wjava/gi版本/n）/w：/w