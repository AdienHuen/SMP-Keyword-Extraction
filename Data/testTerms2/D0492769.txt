#（/w2/nz）/w设计模式/nz之/uzhi工厂模式/gi
工厂模式/gi是/vshi专门/d负责/v将/d大量/m共同/d接口/gi的/ude1类/gi实例化/gi，/w而且/c事先/d不/d知道/v每次/r是/vshi要/v实例/gi哪/ry一个/mq类/gi的/ude1模式/gi。/w它/rr定义/gi一个/mq用于/v创建对象/n的/ude1接口/gi，/w由/p子类/gm决定/v实例化/gi哪/ry一个/mq类/gi。/w我们/rr把/pbajava/gi工厂模式/gi归纳/v为/p两/nz种/q:/w简单工厂模式/gi和/cc抽象工厂模式/gi。/w1/nz、/w简单工厂模式/gi简单工厂模式/gi的/ude1结构/gi代码/gi演示/gi：/w实用/a范围/n：/w?/nz /x在/p编码/gi时/qt不能/v预见/vn需要/v创建/gi哪/ry一/nz种类/n的/ude1实例/gi。/w /x?/nz /x一个/mq类/gi使用/gi它/rr的/ude1子类/gm来/vf创建对象/n。/w /x?/nz /x开发人员/n不/d希望/v创建/gi了/ule哪个/ry类/gi的/ude1实例/gi以及/cc如何/ryv创建/gi实例/gi的/ude1信息/gi暴露/v给/p外部/f程序/gi。/w2/nz、/w抽象工厂模式/gi抽象工厂模式/gi可以/v说/v是/vshi简单工厂模式/gi的/ude1扩展/gi，/w它们/rr主要/b的/ude1区别/gi在于/v需要/v创建对象/n的/ude1复杂程度/n上/f。/w /x在/p抽象工厂模式/gi中/f，/w抽象/gi产品/gi可能/v是/vshi一个/mq或/c多/a个/q，/w从而/c构成/v一个/mq或/c多/a个/q产品/gi族/ng。/w /x在/p只有/c一个/mq产品/gi族/ng的/ude1情况下/nz，/w抽象工厂模式/gi实际上/d退化/vi到/v工厂方法模式/gi。/w抽象工厂模式/gi的/ude1结构/gi代码/gi小结/n /x在/p以下/f情况下/nz，/w应当/v考虑/v使用/gi抽象工厂模式/gi。/w /x　　/nz首先/d，/w一个/mq系统/gi应当/v不/d依赖于/v产品/gi类/gi实例/gi被/pbei创立/v，/w组成/gi，/w和/cc表示/v的/ude1细节/gi。/w这/rzv对于/p所有/b形态/n的/ude1工厂模式/gi都/d是/vshi重要/a的/ude1。/w /x　　/nz其次/c，/w这个/rz系统/gi的/ude1产品/gi有/vyou多于一个/nz的/ude1产品/gi族/ng。/w /x　/nz　/nz第三/nz，/w同/p属于/v同一个/b产品/gi族/ng的/ude1产品/gi是/vshi设计/gi成/v在/p一起/s使用/gi的/ude1。/w这/rzv一/nz约束/gi必须/d得/ude3在/p系统/gi的/ude1设计/gi中/f体现/v出来/vf。/w /x　　/nz最后/f，/w不同/a的/ude1产品/gi以/p一系列/b的/ude1接口/gi的/ude1面貌/n出现/v，/w从而/c使/v系统/gi不/d依赖于/v接口/gi实现/gi的/ude1细节/gi。/w /x　　/nz其中/rz第二丶/nz第三/nz个/q条件/n是/vshi我们/rr选用/v抽象工厂模式/gi而非/c其它/rz形态/n的/ude1工厂模式/gi的/ude1关键性/n条件/n。/w