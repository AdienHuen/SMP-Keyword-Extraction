#BigInteger/gi用/p法-/nzJava/gi大数据存储/gi、/w运算/gi
用/p这样/rzv一组/nz数字/gi，/w0/nz，/w1/nz，/w1/nz，/w2/nz，/w3/nz，/w5/nz，/w8......../nz，/w求第/nz100/nz个数/n是/vshi多少/ry！/w初看/nz这/rzv道/qv题/n很/d简单/a，/w我们/rr只/d需要/v设定/v一个/mq数组/gi，/w然后/c往里面/n放入/v对应/vi的/ude1，/w除了/p前/f两/nz个/q数字/gi位/q，/w后面/f每个/r数字/gi位/q都/d是/vshi前/f两/nz个/q数字/gi位/q的/ude1和/cc。/w刚开始/nz我/rr用/p了/uleint/nz数组/gi来/vf存放/v这/rzv组/n数/n，/w发现/v根本/a放/v不/d下去/vf，/w到/v了/ule第/mq47/nz位数/n的/ude1时候/n就/d存在/v数/n溢出/gi了/ule，/w然后/c我/rr换为/clong/nz型/k数组/gi，/w同样/d放/v不/d下去/vf，/w到/v了/ule第/mq93/nz位数/n的/ude1时候/n也/d存在/v数/n溢出/gi了/ule。/w这样/rzv，/w只能/v用/pbiginteger/nz类/gi了/ule，/w这/rzv是/vshijava/gi提供/v的/ude1可以/v存储/gi任意/d精度/n的/ude1整数/gi的/ude1类/gi，/w用/p它/rr我们/rr不/d需要/v考虑/v数/n溢出/gi的/ude1错误/gi。/w即使/c我们/rr求第/nz1000/nz个数/n也/d没有/v什么/ry问题/gi。/w不过/c，/w它/rr的/ude1数/n运算/gi必须/d以/p方法/gi调用/gi方式/n取代/v运算符/gi方式/n来/vf实现/gi，/w由于/p这么/rz做/v复杂/a了/ule许多/m，/w运算速度/gi会/v比较慢/l，/w所以/c在/p确定/v数/n不会/v溢出/gi的/ude1情况下/nz，/w是/vshi不/d推荐/gi用/p这种/r型/k式/k来/vf进行/vn数/n存储/gi和/cc运算/gi的/ude1。/w以下/f是/vshi具体/a代码/gi。/w补充/vn知识/gi：/w结果/n：/w补充/vn：/wint/nz[/nz]/nz和/cclong/nz[/nz]/nz发生/v溢出/gi但/c并/cc没有/v报错/nz，/w而是/c给/p了/ule一个/mq错误/gi的/ude1结果/n，/w改进/gi方法/gi如下/vi。/w