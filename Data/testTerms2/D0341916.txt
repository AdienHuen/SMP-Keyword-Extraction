#C++/gi设计/gi模式---策略/nz模式/gi
转载自/nz：/w软件/gi领域/gi中的/v设计模式/nz为/p开发人员/n提供/v了/ule一种/nz使用/gi专家/gi设计/gi经验/gi的/ude1有效途径/nz。/w设计模式/nz中/f运用/v了/ule面向对象编程/gi语言/gi的/ude1重要/a特性/gi：/w封装/gi、/w继承/gi、/w多态/gi，/w真正/d领悟/v设计模式/nz的/ude1精髓/n是/vshi可能/v一个/mq漫长/a的/ude1过程/gi，/w需要/v大量/m实践经验/nz的/ude1积累/gi。/w最近/t看/v设计模式/nz的/ude1书/gi，/w对于/p每个/r模式/gi，/w用/pc++/gi写/v了/ule个/q小/a例子/gi，/w加深/v一/nz下/f理解/gi。/w主要/b参考/gi《/w大话/n设计模式/nz》/w和/cc《/w设计模式/nz:/w可/v复用/gi面向对象/gi软件/gi的/ude1基础/gi》/w两本书/nz。/w本文/r介绍/gi策略模式/gi的/ude1实现/gi。/w策略模式/gi是/vshi指定/v义/ng一系列/b的/ude1算法/gi，/w把/pba它们/rr一个/mq个/q封装/gi起来/vf，/w并且/c使/v它们/rr可/v相互/d替换/v。/w本/rz模式/gi使得/vi算法/gi可/v独立/a于/p使用/gi它/rr的/ude1客户/n而/cc变化/gi。/w也/d就是说/c这些/rz算法所/nz完成/v的/ude1功能/gi一样/uyy，/w对外/vn的/ude1接口/gi一样/uyy，/w只是/d各自/rr实现/gi上/f存在/v差异/n。/w用/p策略模式/gi来/vf封装/gi算法/gi，/w效果/gi比较/gi好/a。/w下面/f以/p高速缓存/gi（/wcache/gi）/w的/ude1替换算法/gi为/p例/n，/w实现/gi策略模式/gi。/w什么/ry是/vshicache/gi的/ude1替换算法/gi呢/y？/w简单/a解释一下/i，/w /x当/p发生/vcache/gi缺失/n时/qt，/wcache/gi控制器/n必须/d选择/gicache/gi中的/v一行/n，/w并用/vi欲/d获得/v的/ude1数据/gi来/vf替换/v它/rr。/w所/usuo采用/v的/ude1选择/gi策略/gi就是/vcache/gi的/ude1替换算法/gi。/w下面/f给出/v相应/vi的/ude1uml/gi图/gi。/wreplacealgorithm/nz是/vshi一个/mq抽象类/gi，/w定义/gi了/ule算法/gi的/ude1接口/gi，/w有/vyou三个类/nz继承/gi自/p这个/rz抽象类/gi，/w也/d就是/v具体/a的/ude1算法/gi实现/gi。/wcache/gi类/gi中/f需要/v使用/gi替换算法/gi，/w因此/c维护/gi了/ule一个/mq  replacealgorithm/nz的/ude1对象/gi。/w这个/rzuml/gi图/gi的/ude1结构/gi就是/v策略模式/gi的/ude1典型/n结构/gi。/w下面/f根据/puml/gi图/gi，/w给出/v相应/vi的/ude1实现/gi。/w首先/d给出/v替换算法/gi的/ude1定义/gi。/w接着/c给出/vcache/gi的/ude1定义/gi，/w这里/rzs很/d关键/n，/wcache/gi的/ude1实现/gi方式/n直接影响/v了/ule客户/n的/ude1使用/gi方式/n，/w其/rz关键在于/n如何/ryv指定/v替换算法/gi。/w方式/n一直/d接/v通过/p参数/gi指定/v，/w传入/gi一个/mq特定/b算法/gi的/ude1指针/gi。/w如果/c用/p这种/r方式/n，/w客户/n就/d需要/v知道/v这些/rz算法/gi的/ude1具体/a定义/gi。/w只能/v以/p下面/f这种/r方式/n使用/gi，/w可以/v看到/v暴露/v了/ule太多/ad的/ude1细节/gi。/w方式二/nz也/d是/vshi直接/ad通过/p参数/gi指定/v，/w只不过/d不是/c传入/gi指针/gi，/w而是/c一个/mq标签/gi。/w这样/rzv客户/n只要/c知道/v算法/gi的/ude1相应/vi标签/gi即可/v，/w而/cc不/d需要/v知道/v算法/gi的/ude1具体/a定义/gi。/w相比/vi方式/n一/nz，/w这种/r方式/n用/p起来/vf方便/a多/a了/ule。/w其实/d这种/r方式/n将/d简单工厂模式/gi与/cc策略模式/gi结合/v在/p一起/s，/w算法/gi的/ude1定义/gi使用/gi了/ule策略模式/gi，/w而/cccache/gi的/ude1定义/gi其实/d使用/gi了/ule简单工厂模式/gi。/w上面/f两/nz种/q方式/n，/w构造函数/gi都/d需要/v形参/gi。/w构造函数/gi是否/v可以/v不用/d参数/gi呢/y？/w下面/f给出/v第三种/nz实现/gi方式/n。/w方式/n三利用/nz模板/gi实现/gi。/w算法/gi通过/p模板/gi的/ude1实参/gi指定/v。/w当然/d了/ule，/w还是/c使用/gi了/ule参数/gi，/w只不过/d不是/c构造函数/gi的/ude1参数/gi。/w在/p策略模式/gi中/f，/w参数/gi的/ude1传递/v难以避免/nz，/w客户/n必须/d指定/v某种/rz算法/gi。/w使用/gi方式/n如下/vi：/w