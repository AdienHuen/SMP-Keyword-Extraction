#数据结构/gi学习笔记/gi6/nz-动态/nz规划/gi（/w钢条/n切割/v问题/gi）/w
下面/f记下/v在/p学习/gi算法导论/gi的/ude1动态规划/gi过程/gi中的/v笔记/gi及/cc代码/gi：/w动态规划/gi含义/n：/w  /x动态规划/gi一般/ad也/d只能/v应用于/v有/vyou最/d优子/nz结构/gi的/ude1问题/gi。/w最优/ad子结构/n的/ude1意思/n是/vshi局部/n最优解/gi能/v决定/v全局/n最优解/gi(/nz对/p有些/rz问题/gi这个/rz要求/n并/cc不能/v完全/ad满足/v，/w故/c有时/d需要/v引入/v一定/b的/ude1近似/a)/nz。/w简单/a地/ude2说/v，/w问题/gi能够/v分解/gi成子/nz问题/gi来/vf解决/v。/w动态规划/gi算法分/nz以下/f4/nz个/q步骤/gi：/w1./nz描述/gi最优解/gi的/ude1结构/gi /x2./nz递归/gi定义/gi最优解/gi的/ude1值/n /x3./nz按/p自/p底向上/l的/ude1方式/n计算/gi最优解/gi的/ude1值/n   /x//nz//nz此/rzs3/nz步/qv构成/v动态规划/gi解/v的/ude1基础/gi。/w /x4./nz由/p计算/gi出/vf的/ude1结果/n构造/n一个/mq最优解/gi。/w   /x//nz//nz此/rzs步/qv如果/c只/d要求/n计算/gi最优解/gi的/ude1值/n时/qt，/w可/v省略/v。/w动态规划/gi应用/gi1/nz钢条/n切割/v问题/gi问题/gi：/w公司/nis购买/gi长/a钢条/n，/w将/d其/rz切割/v为/p短/a钢条/n出售/v。/w切割/v工序/n本身/rz没有/v成本/n支出/n。/w公司/nis管理层/n希望/v知道/v最佳/z的/ude1切割/v方案/gi。/w假定/v我们/rr知道/v公司/nis出售/v一/nz段/q长度/gii/nz英寸/q的/ude1钢条/n的/ude1价格/n为/ppi/gi（/wi/nz=/nz1/nz，/w2/nz，/w…/w，/w单位/n为/p美元/q）/w。/w钢条/n的/ude1长度/gi均/d为/p整/v英寸/q。/w图/gi给出/v了/ule一个/mq价格/n表/n的/ude1样例/nz。/w /x切割/v钢条/n的/ude1问题/gi是/vshi这样/rzv的/ude1：/w给定/gi一/nz段/q长度/gi为/pn/nz英寸/q的/ude1钢条/n和/cc一个/mq价格/n表/npi/gi（/wi/nz=/nz1/nz,/nz2/nz…/wn/nz）/w，/w求/v切割/v方案/gi，/w使得/vi销售/gi收益/girn/nz最大/gm。/w解决/v思路/gi：/w  /x钢条/n切割/v问题/gi还/d存在/v一种/nz相似/a的/ude1但/c更为/d简单/a的/ude1递归/gi求解/gi方法/gi：/w将/d钢条/n从/p左边/f切割/v下/f长度/gi为/pi/nz的/ude1一段/nz，/w只/d对/p右边/f剩下/v的/ude1长度/gi为/pn/nz-/nzi/nz的/ude1一段/nz继续/v进行/vn切割/v，/w对/p左边/f的/ude1一段/nz则/d不再/d进行/vn切割/v。/w这样/rzv得到/v的/ude1公式/gi为/p：/w。/w这样/rzv原/b问题/gi的/ude1最优解/gi只/d包含/v一个/mq相关/vn子问题/gi（/w右端/nz剩余/vn部分/n）/w的/ude1解/v，/w而/cc不是/c两/nz个/q。/w朴素/a递归/gi算法/gi之所以/c效率/gi很低/d，/w是因为/c它/rr反复/d求解/gi相同/a的/ude1子问题/gi。/w因此/c，/w动态规划/gi方法/gi仔细/ad安排/v求解/gi顺序/gi，/w对/p每个/r子问题/gi只求/v解/v一次/nz，/w并/cc将/d结果/n保存/gi下来/vf。/w如果/c随后/d再次/d需要/v此子/nz问题/gi的/ude1解/v，/w只需/v查找/gi保存/gi的/ude1结果/n，/w而/cc不必/d重新/d计算/gi。/w因此/c，/w动态规划/gi方法/gi是/vshi付出/v额外/b的/ude1内存空间/nz来/vf节省/v计算/gi空间/n。/w动态规划/gi两/nz种/q解决方法/gi：/w /x动态规划/gi的/ude1实现/gi方法/gi：/w1./nz带/v备忘/nz的/ude1自顶/nz向下/vf法/n：/w此/rzs方法/gi仍按/nz自然/n的/ude1递归形式/gi编写/gi过程/gi，/w但/c过程/gi会/v保存/gi每个/r子问题/gi的/ude1解/v（/w通常/d保存/gi在/p一个/mq数组/gi或/c散列表/gi中/f）/w。/w当/p需要/v一个子/nz问题/gi的/ude1解/v时/qt，/w过程/gi首先/d检查/gi是否/v已经/d保存/gi过/uguo此/rzs解/v。/w如果/c是/vshi，/w则/d直接/ad返回/v保存/gi的/ude1值/n，/w从而/c节省/v了/ule计算/gi时间/gi；/w否则/c，/w按/p通常/d方式/n计算/gi这个/rz子问题/gi。/w2./nz自底/nz向上/vi法/n：/w这种/r方法/gi一般/ad需要/v恰当/a定义/gi子问题/gi“/w规模/gi”/w的/ude1概念/gi，/w使得/vi任何/rz子问题/gi的/ude1求解/gi都/d依赖于/v“/w更/d小/a的/ude1”子/nz问题/gi的/ude1求解/gi。/w因而/c我们/rr可以/v将子/nz问题/gi按/p规模/gi排序/gi，/w按/p由/p小/a至/p大/a的/ude1顺序/gi进行/vn求解/gi。/w当/p求解/gi某个子/nz问题/gi时/qt，/w它/rr所/usuo依赖/v的/ude1那些/rz更/d小/a的/ude1子问题/gi都/d已经/d求解/gi完毕/vi，/w结果/n已经/d保存/gi。/w每个/r子问题/gi只/d需要/v求解/gi一次/nz，/w当/p我们/rr求解/gi它/rr（/w也/d是/vshi第一次/nz遇到/v它/rr）/w时/qt，/w它/rr的/ude1所有/b前/f提子/nf问题/gi都/d已/d求解/gi完成/v。/w注意/v：/w两/nz种/q方法/gi得到/v的/ude1算法/gi具有/v相同/a的/ude1渐进/v运行时间/gi，/w仅有/nz的/ude1差异/n是/vshi在/p某些/rz特殊/a情况下/nz，/w自/p顶向下/n方法/gi并未/d真正/d递归/gi地/ude2考察/v所有/b可能/v的/ude1子问题/gi。/w由于/p没有/v频繁/a的/ude1递归函数/gm调用/gi的/ude1开销/n，/w自底/nz向上/vi方法/gi的/ude1时间复杂度/gi函数/gi通常/d具有/v更/d小/a的/ude1系数/n。/w带/v备忘/nz的/ude1自顶/nz向下/vf法/n先/d看/v伪/ag代码/gi：/w  /x根据/p伪/ag代码/gi写/v的/ude1c语言/gi代码/gi：/w输出/gi结果/n：/w /x自/p底向上/l法/n（/w只求/v出/vf最优解/gi，/w并未/d求出/v切割/v方案/gi）/w（/wc语言/gi代码/gi:/w）/w上述/b代码/gi仅/d能/v输出/gi最优解/gi，/w但是/c还/d未/d保存/gi最优/ad切割/v方案/gi：/w /x下述/nz代码/gi能够/v输出/gi切割/v方法/gi：/w