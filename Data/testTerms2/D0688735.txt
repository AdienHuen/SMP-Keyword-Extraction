#已知/nz一个/mq数/n出现/v的/ude1次数/gi超过/v了/ule一半/mq，/w请用/vO/nz(/nzn/nz)/nz的/ude1复杂度/gi的/ude1算法/gi找出/v这个/rz数/n
现在/t有/vyou一个/mq整数/gi数组/gi，/w已知/nz一个/mq数/n出现/v的/ude1次数/gi超过/v了/ule一半/mq，/w请用/vo/nz(/nzn/nz)/nz的/ude1复杂度/gi的/ude1算法/gi找出/v这个/rz数/n。/w算法/gi：/w充分利用/n出现/v次数/gi超过/v一半/mq这个/rz特点/n，/w使用/gi两/nz个/q变量/gicandidate/nz和/ccvote/nz，/w分别/d代表/nnt候选人/nnt和/cc票数/n，/w遍/qv历数/nz组/n按/p如下/vi方式/n投票/vi和/cc更换/v候选人/nnt：/w若/c当前/t数/n与/cc候选人/nnt一样/uyy，/w则/d把/pba候选人/nnt的/ude1票数/n加/v1/nz若/c当前/t数/n与/cc候选人/nnt不/d一样/uyy,/nz /x则/d把/pba它/rr的/ude1票数/n减/v1/nz，/w如果/c减掉/v后/f票数/n小于/v0/nz，/w则/d把/pba候选人/nnt踢掉/nz，/w用/p当前/t数/n作为/p新的/a候选人/nnt最后/f剩下/v的/ude1候选人/nnt就是/v出现/v次数/gi超过/v一半/mq的/ude1数/n。/w算法/gi的/ude1正确性/gi证明/v：/w /x数组/gi中/f，/w数/n相同/a的/ude1数/n都会/n投/v赞成票/n，/w数/n不同/a的/ude1都会/n投/v反对票/n，/w有/vyou一个/mq数/n出现/v的/ude1次数/gi超过/v一半/mq，/w其它/rz数/n得到/v的/ude1反对票/n必然/d大于/v一半/mq，/w所以/c其它/rz数/n中/f，/w任何/rz一个/mq得票/nz都会/n小于/v0/nz，/w遭到/v淘汰/v。/w剩下/v来/vf的/ude1只能/v是/vshi超过/v一半/mq的/ude1那个/rz数/n。/w