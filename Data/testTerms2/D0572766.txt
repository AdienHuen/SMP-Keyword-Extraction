#Redis/gi的/ude1pipeline/nz方式/n
redis/gi的/ude1pipeline/nz方式/n的/ude1实现/gi原理/gi是/vshi先/d把/pba指令/gi发送/gi服务器端/gi，/w让/vredis/gi编译/gi（/w发送到/l服务器/gi并/cc编译/gi，/w这/rzv是/vshi猜测/v，/w因为/c如果/c不/d这样/rzv做/v，/wpipeline/nz方式/n不/d应该/v有/vyou那么/c大/a的/ude1性能/gi提升/gi。/w影响/gi一条/nz指令/gi执行/v时间/gi的/ude1因素/gi有/vyou网络/gi、/w编译/gi、/w执行/v，/w后/f两/nz个/q是/vshi在/p服务器端/gi，/w第一个/gi因素/gi是/vshi可以/v忽略/v的/ude1，/w所以/c如果/c指令/gi不是/c预先/d发送到/l服务器端/gi并/cc编译/gi，/w性能/gi不会/v有/vyou那么/c大/a的/ude1提升/gi。/w）/w，/w但是/c此时/r不/d执行/v，/w当/p客户端/gi调用/gi执行/v接口/gi的/ude1时候/n才/d执行/v相应/vi指令/gi。/w具体步骤/nz如下/vi：/w     /x1/nz、/w客户端/gi发送/gi指令/gi    /x2/nz、/w服务器端/gi编译/gi并/cc缓存/gi    /x3/nz、/w当/p指令/gi达到/v一定/b数量/n后/f，/w客户端/gi开始/v执行/v。/w（/w这个/rz数/n是/vshi由/p客户端/gi应用程序/nz控制/vn的/ude1，/w另外/c针对/gic/nz接口/gi，/w每/rz调用/gi一次/nzredisgetreply/nz接口/gi都会/n有/vyou相应/vi的/ude1指令/gi执行/v，/w但是/c，/w当/predis/gi达到/v了/ule配置文件/gi中/f设置/gi的/ude1内存/gi上限/n，/w调用/gi这个/rz接口/gi返回/v的/ude1结构体/gi中会/j有/vyou内存/gi不够/a的/ude1错误信息/nz，/w相应/vi的/ude1指令/gi被/pbei丢弃/v）/w。/w非/b内存数据库/gi提供/v了/ule一个/mq类/gi的/ude1功能/gi，/w不同/a的/ude1是/vshi，/wredis/gi的/ude1pipeline/nz方式/n是/vshi可以/v缓存/gi所有/b类型/gi的/ude1指令/gi，/w非/b内存数据库/gi是/vshi针对/gi某/rz一类/b指令/gi进行/vn数据/gi填充/v，/w比如/v insert a to b/nz，/w非/b内存数据库/gi会/v允许/v预先/d把/pbainsert   to  /nz这样/rzv的/ude1指令/gi模板/gi送到/v服务器端/gi并/cc编译/gi，/w然后/c客户端/gi缓存数据/n，/w当/p达到/v一定量/n之后/f，/w客户端/gi发送/gi所有/b的/ude1缓存数据/n到/v服务器端/gi，/w服务器端/gi将/d指令/gi结果/n返回/v。/w