#java/gi之/uzhi数组/gi中/f出现/v次数/gi超过/v一半/mq的/ude1数字/gi
题目/gi：/w数组/gi中/f有/vyou一个/mq数字/gi出现/v的/ude1次数/gi超过/v数组/gi长度/gi的/ude1一半/mq，/w请/v找出/v这个/rz数字/gi。/w例如/v输入/v一个/mq长度/gi为/p9/nz的/ude1数组/gi{/nz1/nz,/nz2/nz,/nz3/nz,/nz2/nz,/nz2/nz,/nz2/nz,/nz5/nz,/nz4/nz,/nz2/nz}/nz。/w由于/p数字/gi2/nz在/p数组/gi中/f出现/v5/nz次/qv，/w超过/v数组/gi长度/gi的/ude1一半/mq，/w因此/c输出/gi2./nz分析/gi：/w有/vyou两/nz种/q解法/gi：/w1./nz基于/p快速排序/gi中的/vpartition/nz函数/gi的/ude1o/nz(/nzn/nz)/nz算法/gi。/w如果/c把/pba这个/rz数组排序/gi，/w那么/c排序/gi后/f的/ude1数组/gi中间/f的/ude1数字/gi一定/b是/vshi那个/rz出现/v次数/gi超过/v数组/gi长度/gi一半/mq的/ude1数字/gi。/w2./nz根据/p数组/gi特性/gi，/w可以/v考虑/v遍/qv历数/nz组/n的/ude1时候/n保存/gi两/nz个/q：/w一个/mq是/vshi数组/gi中的/v数字/gi，/w一个/mq是/vshi这个/rz数字/gi出现/v的/ude1次数/gi。/w当/p我们/rr遍历/gi下一个/nz数字/gi的/ude1时候/n，/w如果/c下一个/nz数字/gi和/cc之前/f保存/gi的/ude1数字/gi相同/a，/w则/d次数/gi加/v1/nz，/w否则/c次数/gi减/v1./nz如果/c次数/gi为/p0/nz，/w我们/rr需要/v保存/gi下一个/nz数字/gi，/w并/cc把/pba次数/gi设为/v1./nzjava/gi代码/gi：/w