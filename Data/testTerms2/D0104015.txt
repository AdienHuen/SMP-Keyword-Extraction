#换/v种/q思路/gi去/vf理解/gi设计模式/nz（/w中/f）/w
7/nz /x多/a个/q对象/gi组成/gi结构/gi7.1/nz /x过程/gi描述/gi　　/nz上/f一/nz节/q介绍/gi了/ule如何/ryv创建/gi一个/mq对象/gi。/w但/c大/a多数/a情况/n，/w一个/mq对象/gi是/vshi不够/a用/p的/ude1，/w这时候/rzt就/d需要/v把/pba对象/gi包装/n、/w封装/gi、/w多/a对象/gi组合/gi。/w有时候/d还/d需要/v将/d一个/mq组合/gi作为/p一个/mq整体/n使用/gi，/w组合/gi要/v提供/v对外/vn的/ude1接口/gi，/w也/d可能会/nz用/p到/v系统/gi原有/v的/ude1接口/gi。/w　　/nz下面/f针对/gi每种/r情况/n详细介绍/gi。/w7.2/nz   /x情况/n1/nz：/w借用/v外部/f接口/gi　　/nz有/vyou开发/gi经验/gi的/ude1人/n知道/v，/w日常/b大部分/n开发/gi都/d是/vshi在/p已有/v系统/gi基础上/nz开发/gi的/ude1。/w即便/c是从/v新/a开发/gi的/ude1系统/gi，/w也/d要/v依赖于一个/nz框架/gi或者/c库/n。/w　　/nz所以/c，/w我们/rr每时每刻/bl都/d在用/b系统/gi已有/v的/ude1接口/gi。/w但是/c如果/c这些/rz接口/gi不/d满足/v我们/rr的/ude1需求/gi，/w我们/rr就/d需要/v重新/d对接口/n封装/gi一下/m，/w让/v其/rz符合/v当前/t的/ude1规则/gi。/w就是/v这个/rz我们/rr日常/b用/p的/ude1技巧/gi，/w被/pbeigof/gi总结/gi成为/v一个/mq模式/gi―/w―/w适配器模式/gi。/w　　/nz不用/d看/v代码/gi和/cc类图/gi，/w也/d能/v明白/v它/rr的/ude1意思/n。/w不必/d太/d计较/v代码/gi和/cc类图/gi的/ude1细节/gi，/w重点/n在于/v理解/gi设计/gi思想/gi。/w　　/nz顾名思义/vl，/w适配器/n就是/v做/v一个/mq隔离/vn，/w起到/v了解/v耦/nz的/ude1作用/gi。/w例如/v我们/rr日常/b用/p的/ude1笔记本电脑/nz适配器/n。/w7.3/nz  /x情况/n2/nz：/w给/p对象/gi增加/v新功能/nz　　/nz系统/gi总是/d在/p不断/d的/ude1维护/gi和/cc升级/vi当中/f，/w也/d可能/v在/p不断/d的/ude1需求/gi变更/gi当中/f，/w因此/c为/p对象/gi增加/v新功能/nz，/w是/vshi再/d常见/a不过/c的/ude1了/ule。/w那么/c如何/ryv为/p对象/gi增加/v新功能/nz呢/y？/w　/nz　/nz最/d直接/ad的/ude1回答/v就是/v改/v代码/gi呗/y。/w改类型/nz的/ude1代码/gi，/w增加/v方法/gi、/w属性/gi等/udeng。/w　　/nz　　/nz对于/p这种/r修改/gi，/w首先/d想到/v的/ude1应该/v是/vshi违反/v了/ule“/w开放/gi封闭/gi原则”/nz和/cc“/w单一/gi职责/gi原则”/nz，/w违反/v这种/r原则/gi带来/v的/ude1坏处/n很/d多/a。/w代码/gi越/d改/v越多/ad；/w每次/r更改/gi都/d有可能/nz影响/gi以前/f代码/gi；/w多/a人/n维护/gi一个/mq文件/gi，/w不利于/v协同/vd开发/gi…/w…/w　　/nz　　/nz如果/c用/p“/w抽象/gi”“/nz隔离/vn”/w的/ude1思想/gi来/vf思考/gi这/rzv一/nz问题/gi，/w很容易/nz就/d能/v找出/v思路/gi：/w第一/mq，/w把/pba原有/v功能/gi和/cc新增/v功能/gi隔离/vn；/w第二/mq，/w两者/rzv都/d依赖于一个/nz抽象/gi，/w这个/rz抽象/gi就是/v对象/gi应该/v有的/rz所有/b功能/gi；/w第三，/nz外部/f客户/n将/d依赖于/v抽象/gi，/w它/rr不会/v察觉/v内部/f的/ude1变化/gi（/w依赖/v倒置/vi原则/gi）/w。/w　　/nz这/rzv就是/v装饰模式/gi。/w　　/nz　　/nz从/p上面/f的/ude1类图/gi看/v，/wconretecomponent/nz是/vshi原始/a类型/gi，/wdecorator/gi是/vshi一个/mq抽象类/gi，/w它/rr的/ude1派生类/n负责/v添加/gi新功能/nz。/w这里/rzs理解/gi的/ude1重点/n，/w在于/vdecorator/gi类/gi中/f有/vyou一个/mqcomponent/nz属性/gi，/w相当于/vdecorator/gi封装/gi了/ule一个/mqcomponent/nz，/w直接/ad调用/gi他/rr原有/v的/ude1功能/gi，/w并且/c可以/v新增/v功能/gi。/w当然/d，/w这些/rz操作/gi都/d是/vshi可以/v派生/v在/p子类/gm中/f实现/gi的/ude1。/w而且/c不同/a的/ude1子类/gm可以/v实现/gi增加/v不同/a的/ude1功能/gi。/w　　/nz这样/rzv的/ude1抽象/gi和/cc分离/vi就/d符合/v开放/gi封闭/gi原则/gi和/cc单一职责原则/gi，/w也/d不会/v出现/v代码/gi量/n过多/d、/w多/a人/n维护/gi不便/an等/udeng问题/gi。/w7.4/nz  /x情况/n3/nz：/w封装/gi功能/gi　　/nz对于/p有些/rz功能/gi，/w我们/rr不/d希望/v客户端/gi直接/ad调用/gi，/w而是/c在/p调用/gi时候/n先/d做/v一个/mq判断/gi，/w或者/c加/v一个/mq缓存/gi。/w其实/d就是/v在/p真实/a功能/gi和/cc客户端/gi之间/f，/w加/v一个/mq中间层/nz。/w而/cc这/rzv不能/v让/v客户端/gi调用/gi察觉/v。/w　　/nz如果/c你/rr把/pba这个/rz中间层/nz直接/ad加入/v到/v真是/d功能/gi中/f，/w虽然/c这/rzv可以/v不让/v客户端/gi察觉/v，/w那/rzv将/d会/v给/p系统/gi带来/v隐患/gi，/w违反/v“/w单一职责原则/gi”/w。/w如下/vi：/w　　/nz　　/nz首先/d，/w如何/ryv不让/v客户端/gi察觉/v？/w答案/gi很/d简单/a―/w―/w依赖/v倒置/vi原则/gi―/w―/w让/v客户端/gi依赖于一个/nz抽象/gi。/w这个/rz抽象/gi将/d如何/ryv实现/gi呢/y？/w /x具体/a的/ude1实现/gi和/cc中间层/nz都/d要/v去/vf实现/gi。/w如下/vi：/w　　/nz　　/nz类图/gi如下/vi：/w　　/nz这/rzv就是/v代理模式/gi。/w　　/nz每个/r设计模式/nz要/v体现/v的/ude1都/d是/vshi一种/nz设计/gi的/ude1思路/gi，/w代理模式/gi就是/v要/v在/p客户端/gi和/cc底层/n实现/gi加/v一层/nz，/w在/p该层/nz中/f实现/gi一/nz些/q业务/gi场景/gi。/w4/nzs/nz店/n就是/v客户/n于/p汽车厂家/nz的/ude1代理/gi。/w　　/nz具体/a是否/v要/v都/d去/vf实现/gi同一个/b接口/gi，/w这种/r细节/gi不/d重要/a，/w不要/d去/vf过于/d纠结/vi这些/rz类图/gi和/cc代码/gi。/w7.5/nz  /x情况/n4/nz：/w递归/gi关系/gi的/ude1组合/gi　　/nz上文/n提到/v如何/ryv更/d有效率/n的/ude1维护/gi对象/gi功能/gi和/cc新增/v功能/gi，/w以及/cc更/d有效率/n的/ude1封装/gi对象/gi。/w这/rzv两/nz种/q做法/n的/ude1输出/gi，/w其实/d还是/c一个/mq单个/b的/ude1对象/gi。/w如何/ryv将/d一个/mq个/q对象/gi组合成/l一个/mq视图/gi，/w系统/gi中/f最/d常见/a的/ude1无非/d是/vshi两/nz种/q―/w―/w列表/vi、/w树/gi，/w以及/cc两者/rzv的/ude1结合体/nz―/w―/wtreegrid/nz　　/nz列表/vi是/vshi比较简单/l的/ude1结构/gi，/w按/p实际/n的/ude1需求/gi应用/gi，/w不会/v产生/v太多/ad误解/gi。/w而/cc树/gi结构/gi却/d有得/v讨论/gi之处/r。/w最简单/nz的/ude1树/gi节点/gi实现/gi的/ude1代码/gi如下/vi：/w代码/gi很/d简单/a，/w只有/c节点/gi的/ude1名称/n，/w和/cc对/p代码/gi下级/n节点/gi的/ude1管理/gi。/w　　/nz　　/nz如果/c我们/rr应对/v的/ude1业务/gi很/d简单/a，/w例如/v类/gi于/pwindows系统/gi的/ude1文件/gi夹树/nz，/w即/v每个/r节点/gi的/ude1类型/gi都/d一样/uyy，/w每个/r节点/gi的/ude1功能/gi也/d都/d一样/uyy，/w叶子节点/gi和/cc摘要/n节点/gi在/p功能/gi上/f没有/v区别/gi。/w这种/r情况下/nz，/w可以/v用/p以上/f代码/gi轻松/a应对/v。/w　　/nz但是/c如果/c遇到/v以下/f情况/n呢/y，/w如下/vi图/gi：/w　　/nz　　/nz这/rzv也/d是/vshi个/q树/gi结构/gi，/w但是/c每个/r节点/gi类型/gi都/d不/d一样/uyy，/w形式/gi的/ude1功能/gi也/d不/d一样/uyy，/w“/w个人/n”/w是/vshi个/q叶子节点/gi，/w不能/v再/d添加/gi下级/n节点/gi。/w这种/r情况下/nz，/w再/d用/p以上/f那段/r代码/gi就/d会/v出现/v许/v多/a问题/gi，/w如/v多/a个/q功能/gi集中/v在/p一个/mq代码/gi文件/gi中/f，/w多/a人/n维护/gi一段/nz代码/gi等/udeng。/w　　/nz如何/ryv解决/v这/rzv一/nz问题/gi，/w组合模式/gi给予/vn我们/rr灵感/n。/w　　/nz　　/nz根据/p以上/f类图/gi，/w可以/v看出/v组合模式/gi解决/v这/rzv一/nz问题/gi的/ude1思路/gi是/vshi：/w将/d树/gi结构/gi中的/v节点/gi的/ude1统一/vn功能/gi抽象/gi出来/vf，/w不同/a类型/gi的/ude1节点/gi，/w用/p不同/a的/ude1子类/gm去/vf实现/gi。/w类图/gi中/f只有/c两个子/nz类/gi，/w我们/rr可以/v根据/p自己/rr的/ude1实际/n情况/n来/vf派生/v多/a个子/n类/gi。/w　　/nz这样/rzv解释/gi想必/d大部分/n人/n都/d能/v理解/gi该/rz模式/gi的/ude1设计思路/gi，/w不必/d再/d用/p代码/gi挨着/v表达/gi了/ule。/w关键在于/n理解/gi如何/ryv分析/gi问题/gi，/w如何/ryv抽象/gi，/w如何/ryv隔离/vn，/w如何/ryv解耦/gi，/w最终/d就是/v如何/ryv设计/gi。/w　　/nz这样/rzv设计/gi符合/v开放/gi封闭/gi原则/gi、/w职责/gi单一/gi原则/gi，/w对于/p客户端/gi也/d符合/v依赖/v倒置/vi原则/gi。/w7.6/nz  /x情况/n5/nz：/w分离/vi多/a层/gi继承/gi　　/nz在/p对象/gi组合/gi过程/gi中/f，/w难免会/l出现/v继承/gi的/ude1情况/n，/w甚至/d会/v出现/v多/a层/gi继承/gi。/w根据/p设计原则/gi―/w―/w少/a继承/gi、/w多/a聚合/gi。/w因此/c不/d建议/gi我们/rr使用/gi多/a层/gi继承/gi。/w而是/c尽量/d把/pba这种/r多/a层/gi继承/gi的/ude1关系/gi，/w变成/v聚合/gi的/ude1关系/gi。/w　　/nz在/p一个/mq多/a层/gi继承/gi结构/gi中/f，/w如果/c底层/n节点/gi可以/v抽象/gi出/vf相同/a的/ude1功能/gi，/w即可/v变为/v聚合/gi关系/gi。/w如/v：/w　　/nz　　/nz如上图/i，/w子类/gm可以/v提取/v出/vf一个/mq抽象/gi。/w变成/v这样/rzv的/ude1设计/gi：/w　　/nz　　/nz这样/rzv就/d把/pba多/a继承/gi变成/v了/ule聚合/gi。/w　　/nz可以/v总结/gi归纳/v以下/f这种/r情况/n。/w我们/rr把/pba左侧/f“/w发送/gi消息/n”/w及其/cc子类/gm叫做/v“/w抽象/gi”/w，/w右侧/f的/ude1“/w发送/gi方式/n”/w及其/cc子类/gm叫做/v“/w实现/gi”/w。/w那么/c我们/rr现在/t做/v的/ude1就是/v从/p“/w实现/gi”/w和/cc“/w抽象/gi”/w的/ude1继承/gi关系/gi，/w变成/v了/ule两者/rzv的/ude1聚合/gi关系/gi。/w　　/nz这/rzv就是/v―/w―/w桥接模式/gi。/w以下/f是/vshi类图/gi：/w　　/nz　　/nz他/rr应对/v的/ude1场景/gi是/vshi抽象/gi有/vyou多样性/n，/w实现/gi也/d有/vyou多样性/n。/w抽象/gi的/ude1抽象/gi只/d依赖于/v实现/gi的/ude1抽象/gi。/w从而/c解耦/gi抽象/gi和/cc实现/gi的/ude1关联/vn。/w7.7/nz  /x情况/n6/nz：/w封装/gi组合/gi，/w供/vi外部/f使用/gi　　/nz当/p一个/mq组合/gi封装/gi完成/v后/f，/w要/v提供/v统一/vn的/ude1接口/gi供/vi外部/f客户端/gi使用/gi。/w而/cc不是/c让/v客户端/gi在/p组合/gi内部/f任意/d的/ude1调用/gi。/w　　/nz这/rzv就是/v外观模式/gi。/w很好/ad理解/gi，/w也/d经常/d用/p到/v，/w可能/v只是/d不/d知道/v这个/rz名字/n而已/y。/w它/rr像/v一个/mq包袱/n一样/uyy包/v起来/vf组合/gi，/w只/d留/v规定/n的/ude1接口/gi。/w　　/nz　　/nz外观模式/gi简单/a易懂/gi，/w不/d需要/v类图/gi和/cc代码/gi过多/d解释/gi。/w7.8/nz  /x总结/gi：/w　　/nz（/w注/v：/w未/d包括/v“/wflyweight/gi享元模式/gi”/w。/w将/d在/p后续/vn版本/n更新/gi中/f加入/v。/w）/w　　/nz其实/d以上/f这/rzv几种/nz情况/n，/w就是/v结构性/n的/ude1设计模式/nz对应/vi的/ude1问题/gi，/w每种/r情况/n对应/vi一种/nz设计模式/nz。/w结合/v自己/rr或多或少/d的/ude1开发/gi经验/gi，/w仔细/ad考虑/v分析/gi这/rzv几种/nz情况/n，/w肯定/v每种/r情况/n都/d是/vshi你/rr在/p编码/gi中/f遇到/v的/ude1，/w也/d是/vshi一个/mq对象/gi组合/gi很可能/nz需要/v的/ude1。/w　　/nz遇到/v这些/rz问题/gi时/qt，/w你/rr当时/t是/vshi怎么/ryv解决/v的/ude1？/w不一定/nz非得/d按照/p设计模式/nz上/f的/ude1解决/v方式/n。/w但是/c要/v已定/d符合/v设计原则/gi。/w设计模式/nz只是/d一个/mq“术/nz”/w，/w提供/v一个/mq解决/v思路/gi或者/c灵感/n，/w而/cc设计原则/gi、/w设计/gi思想/gi才/d是/vshi“道/nz”/w。/w原文/n链接/gi：/w