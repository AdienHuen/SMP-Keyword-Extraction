#java/gi之/uzhi栈/gi的/ude1压入/nz和/cc弹出/vf
题目/gi：/w输入/v两/nz个/q整数/gi序列/gi，/w第一个/gi序列/gi表示/v栈/gi的/ude1压入/nz顺序/gi，/w请/v判断/gi第二个/nz序列/gi是否/v为/p该栈/nz的/ude1弹出/vf顺序/gi。/w假设/gi压/v入栈/nz的/ude1所有/b数字/gi均/d不等/vi。/w例如/v序列/gi1/nz、/w2/nz、/w3/nz、/w4/nz、/w5/nz是/vshi某栈/nz的/ude1压栈/nz序列/gi，/w序列/gi4/nz、/w5/nz、/w3/nz、/w2/nz、/w1/nz是/vshi该/rz压栈/nz序列/gi对应/vi的/ude1一个/mq弹出/vf序列/gi，/w但/c4/nz、/w3/nz、/w5/nz、/w1/nz、/w2/nz就/d不是/c该/rz压栈/nz序列/gi的/ude1弹出/vf序列/gi。/w分析/gi：/w如果/c下一个/nz弹出/vf的/ude1数字/gi刚好/d是/vshi栈顶/nz数字/gi，/w那么/c直接/ad弹出/vf。/w如果/c下一个/nz弹出/vf的/ude1数字/gi不是/c栈顶/nz，/w我们/rr把/pba压入/nz序列/gi中/f没有/v入栈/nz的/ude1数字/gi压入/nz到/v辅助/vn栈/gi，/w直到/v把/pba下一个/nz需要/v弹出/vf的/ude1数字/gi压入/nz栈顶/nz为止/u。/w如果/c所有/b的/ude1数字/gi都/d压/v入栈/nz了/ule仍然/d没有/v找到/v下一个/nz弹出/vf的/ude1数字/gi，/w那么/c该/rz序列/gi不/d可能/v是/vshi一个/mq弹出/vf序列/gi。/w结果/n为/p：/wfalse/nz